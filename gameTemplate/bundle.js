'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/******/(function (modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/var installedModules = {};
    /******/
    /******/ // The require function
    /******/function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) {
            /******/return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = installedModules[moduleId] = {
            /******/i: moduleId,
            /******/l: false,
            /******/exports: {}
            /******/ };
        /******/
        /******/ // Execute the module function
        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/__webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/__webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/__webpack_require__.d = function (exports, name, getter) {
        /******/if (!__webpack_require__.o(exports, name)) {
            /******/Object.defineProperty(exports, name, {
                /******/configurable: false,
                /******/enumerable: true,
                /******/get: getter
                /******/ });
            /******/
        }
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/__webpack_require__.n = function (module) {
        /******/var getter = module && module.__esModule ?
        /******/function getDefault() {
            return module['default'];
        } :
        /******/function getModuleExports() {
            return module;
        };
        /******/__webpack_require__.d(getter, 'a', getter);
        /******/return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/__webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/__webpack_require__.p = "";
    /******/
    /******/ // Load entry module and return exports
    /******/return __webpack_require__(__webpack_require__.s = 51);
    /******/
})(
/************************************************************************/
/******/[
/* 0 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME: defs.js
    //  DESC:      misc defines
    //


    var DEG_TO_RAD = 0.0174532925199432957,
        RAD_TO_DEG = 57.29577951308232,
        EPSILON = 8.854187817e-12,
        RGB_TO_DEC = 0.00390625;
    /* harmony export (immutable) */__webpack_exports__["g"] = DEG_TO_RAD;

    /* unused harmony export RAD_TO_DEG */

    /* unused harmony export EPSILON */

    /* harmony export (immutable) */__webpack_exports__["_59"] = RGB_TO_DEC;

    // EGenerationType
    var EGT_NULL = 0,
        EGT_QUAD = 1,
        EGT_SPRITE_SHEET = 2,
        EGT_SCALED_FRAME = 3,
        EGT_MESH_FILE = 4,
        EGT_FONT = 5;
    /* harmony export (immutable) */__webpack_exports__["_20"] = EGT_NULL;

    /* harmony export (immutable) */__webpack_exports__["_21"] = EGT_QUAD;

    /* harmony export (immutable) */__webpack_exports__["_23"] = EGT_SPRITE_SHEET;

    /* harmony export (immutable) */__webpack_exports__["_22"] = EGT_SCALED_FRAME;

    /* harmony export (immutable) */__webpack_exports__["_19"] = EGT_MESH_FILE;

    /* harmony export (immutable) */__webpack_exports__["_18"] = EGT_FONT;

    // EProjectionType
    var EPT_NULL = 0,
        EPT_PERSPECTIVE = 1,
        EPT_ORTHOGRAPHIC = 2;
    /* unused harmony export EPT_NULL */

    /* harmony export (immutable) */__webpack_exports__["_45"] = EPT_PERSPECTIVE;

    /* harmony export (immutable) */__webpack_exports__["_44"] = EPT_ORTHOGRAPHIC;

    // EHorzAlignment
    var EHA_HORZ_LEFT = 0,
        EHA_HORZ_CENTER = 1,
        EHA_HORZ_RIGHT = 2;
    /* harmony export (immutable) */__webpack_exports__["_25"] = EHA_HORZ_LEFT;

    /* harmony export (immutable) */__webpack_exports__["_24"] = EHA_HORZ_CENTER;

    /* harmony export (immutable) */__webpack_exports__["_26"] = EHA_HORZ_RIGHT;

    // EVertAlignment
    var EVA_VERT_TOP = 0,
        EVA_VERT_CENTER = 1,
        EVA_VERT_BOTTOM = 2;
    /* harmony export (immutable) */__webpack_exports__["_54"] = EVA_VERT_TOP;

    /* harmony export (immutable) */__webpack_exports__["_53"] = EVA_VERT_CENTER;

    /* harmony export (immutable) */__webpack_exports__["_52"] = EVA_VERT_BOTTOM;

    // Character codes
    var CHAR_CODE_SPACE = 32,
        CHAR_CODE_PIPE = 124;
    /* harmony export (immutable) */__webpack_exports__["e"] = CHAR_CODE_SPACE;

    /* harmony export (immutable) */__webpack_exports__["d"] = CHAR_CODE_PIPE;

    // EActionPress
    var EAP_IDLE = 0,
        EAP_DOWN = 1,
        EAP_UP = 2;
    /* harmony export (immutable) */__webpack_exports__["l"] = EAP_IDLE;

    /* harmony export (immutable) */__webpack_exports__["k"] = EAP_DOWN;

    /* harmony export (immutable) */__webpack_exports__["m"] = EAP_UP;

    // EDeviceId
    var DEVICE_NULL = -1,
        KEYBOARD = 0,
        MOUSE = 1,
        GAMEPAD = 2;
    /* harmony export (immutable) */__webpack_exports__["h"] = DEVICE_NULL;

    /* harmony export (immutable) */__webpack_exports__["_56"] = KEYBOARD;

    /* harmony export (immutable) */__webpack_exports__["_57"] = MOUSE;

    /* harmony export (immutable) */__webpack_exports__["_55"] = GAMEPAD;

    // Sprite transform Bitmask

    // Visible bit
    var VISIBLE = 0x01;
    /* harmony export (immutable) */__webpack_exports__["_65"] = VISIBLE;

    // Transform parameters
    var TRANSLATE = 0x02,
        ROTATE = 0x04,
        SCALE = 0x08,
        CENTER_POINT = 0x10,
        CROP_OFFSET = 0x20;
    /* harmony export (immutable) */__webpack_exports__["_64"] = TRANSLATE;

    /* harmony export (immutable) */__webpack_exports__["_60"] = ROTATE;

    /* harmony export (immutable) */__webpack_exports__["_61"] = SCALE;

    /* harmony export (immutable) */__webpack_exports__["c"] = CENTER_POINT;

    /* harmony export (immutable) */__webpack_exports__["f"] = CROP_OFFSET;

    // Translate parameters
    var TRANSFORM = 0x40,
        WAS_TRANSFORMED = 0x80;
    /* harmony export (immutable) */__webpack_exports__["_63"] = TRANSFORM;

    /* harmony export (immutable) */__webpack_exports__["_66"] = WAS_TRANSFORMED;

    // Matrix rotation
    var MATRIX_ROTATION = 0x100;
    /* unused harmony export MATRIX_ROTATION */

    // The end of the bot mask
    var OBJECT_BITMASK_END = 0x200;
    /* unused harmony export OBJECT_BITMASK_END */

    // EGameEvent
    // Menu events
    var EGE_MENU_TRANS_IN = 100,
        EGE_MENU_TRANS_OUT = 101,
        EGE_MENU_ESCAPE_ACTION = 102,
        EGE_MENU_TOGGLE_ACTION = 103,
        EGE_MENU_BACK_ACTION = 104,
        EGE_MENU_TO_TREE = 105,
        EGE_MENU_TO_MENU = 106,
        EGE_MENU_GAME_STATE_CHANGE = 107,
        EGE_MENU_UP_ACTION = 108,
        EGE_MENU_DOWN_ACTION = 109,
        EGE_MENU_LEFT_ACTION = 110,
        EGE_MENU_RIGHT_ACTION = 111,
        EGE_MENU_CONTROL_STATE_CHANGE = 112,
        EGE_MENU_SELECT_ACTION = 113,
        EGE_MENU_SELECT_EXECUTE = 114,
        EGE_MENU_SET_ACTIVE_CONTROL = 115,
        EGE_MENU_REACTIVATE = 116,
        EGE_MENU_SCROLL_UP = 117,
        EGE_MENU_SCROLL_DOWN = 118,
        EGE_MENU_SCROLL_LEFT = 119,
        EGE_MENU_SCROLL_RIGHT = 120,
        EGE_MENU_TAB_LEFT = 121,
        EGE_MENU_TAB_RIGHT = 122;
    /* harmony export (immutable) */__webpack_exports__["_15"] = EGE_MENU_TRANS_IN;

    /* harmony export (immutable) */__webpack_exports__["_16"] = EGE_MENU_TRANS_OUT;

    /* harmony export (immutable) */__webpack_exports__["Y"] = EGE_MENU_ESCAPE_ACTION;

    /* harmony export (immutable) */__webpack_exports__["_12"] = EGE_MENU_TOGGLE_ACTION;

    /* harmony export (immutable) */__webpack_exports__["V"] = EGE_MENU_BACK_ACTION;

    /* harmony export (immutable) */__webpack_exports__["_14"] = EGE_MENU_TO_TREE;

    /* harmony export (immutable) */__webpack_exports__["_13"] = EGE_MENU_TO_MENU;

    /* harmony export (immutable) */__webpack_exports__["Z"] = EGE_MENU_GAME_STATE_CHANGE;

    /* harmony export (immutable) */__webpack_exports__["_17"] = EGE_MENU_UP_ACTION;

    /* harmony export (immutable) */__webpack_exports__["X"] = EGE_MENU_DOWN_ACTION;

    /* harmony export (immutable) */__webpack_exports__["_0"] = EGE_MENU_LEFT_ACTION;

    /* harmony export (immutable) */__webpack_exports__["_2"] = EGE_MENU_RIGHT_ACTION;

    /* harmony export (immutable) */__webpack_exports__["W"] = EGE_MENU_CONTROL_STATE_CHANGE;

    /* harmony export (immutable) */__webpack_exports__["_7"] = EGE_MENU_SELECT_ACTION;

    /* harmony export (immutable) */__webpack_exports__["_8"] = EGE_MENU_SELECT_EXECUTE;

    /* harmony export (immutable) */__webpack_exports__["_9"] = EGE_MENU_SET_ACTIVE_CONTROL;

    /* harmony export (immutable) */__webpack_exports__["_1"] = EGE_MENU_REACTIVATE;

    /* harmony export (immutable) */__webpack_exports__["_6"] = EGE_MENU_SCROLL_UP;

    /* harmony export (immutable) */__webpack_exports__["_3"] = EGE_MENU_SCROLL_DOWN;

    /* harmony export (immutable) */__webpack_exports__["_4"] = EGE_MENU_SCROLL_LEFT;

    /* harmony export (immutable) */__webpack_exports__["_5"] = EGE_MENU_SCROLL_RIGHT;

    /* harmony export (immutable) */__webpack_exports__["_10"] = EGE_MENU_TAB_LEFT;

    /* harmony export (immutable) */__webpack_exports__["_11"] = EGE_MENU_TAB_RIGHT;

    // ESelection Message Arguments
    var ESMA_PRESS_TYPE = 0,
        ESMA_DEVICE_TYPE = 1,
        ESMA_MOUSE_X = 2,
        ESMA_MOUSE_Y = 3;
    /* harmony export (immutable) */__webpack_exports__["_49"] = ESMA_PRESS_TYPE;

    /* harmony export (immutable) */__webpack_exports__["_46"] = ESMA_DEVICE_TYPE;

    /* harmony export (immutable) */__webpack_exports__["_47"] = ESMA_MOUSE_X;

    /* harmony export (immutable) */__webpack_exports__["_48"] = ESMA_MOUSE_Y;

    // EMenu State Change Arguments
    var EMSC_STATE = 0,
        EMSC_CONTROL = 1;
    /* harmony export (immutable) */__webpack_exports__["_28"] = EMSC_STATE;

    /* harmony export (immutable) */__webpack_exports__["_27"] = EMSC_CONTROL;

    // EMenuTreeState
    var EMTS_INACTIVE = 0,
        EMTS_IDLE = 1,
        EMTS_ACTIVE = 2,
        EMTS_MAX_MENU_TREE_STATES = 3;
    /* unused harmony export EMTS_INACTIVE */

    /* harmony export (immutable) */__webpack_exports__["_37"] = EMTS_IDLE;

    /* harmony export (immutable) */__webpack_exports__["_36"] = EMTS_ACTIVE;

    /* unused harmony export EMTS_MAX_MENU_TREE_STATES */

    // EMenuState
    var EMS_INACTIVE = 0,
        EMS_IDLE = 1,
        EMS_ACTIVE = 2,
        EMS_MAX_MENU_STATES = 3;
    /* harmony export (immutable) */__webpack_exports__["_35"] = EMS_INACTIVE;

    /* harmony export (immutable) */__webpack_exports__["_34"] = EMS_IDLE;

    /* harmony export (immutable) */__webpack_exports__["_33"] = EMS_ACTIVE;

    /* unused harmony export EMS_MAX_MENU_STATES */

    // EMenuNavigationState
    var EMNS_NULL = 0,
        EMNS_MOUSE = 1,
        EMNS_GAMEPAD_KEYBAORD = 2;
    /* unused harmony export EMNS_NULL */

    /* unused harmony export EMNS_MOUSE */

    /* unused harmony export EMNS_GAMEPAD_KEYBAORD */

    // ETransCode
    var ETC_RESET = 0,
        ETC_BEGIN = 1,
        ETC_END = 2;
    /* unused harmony export ETC_RESET */

    /* harmony export (immutable) */__webpack_exports__["_50"] = ETC_BEGIN;

    /* harmony export (immutable) */__webpack_exports__["_51"] = ETC_END;

    // EActiveControl
    var EAC_NULL = 0,
        EAC_FIRST_ACTIVE_CONTROL = 1,
        EAC_LAST_ACTIVE_CONTROL = 2;
    /* unused harmony export EAC_NULL */

    /* harmony export (immutable) */__webpack_exports__["i"] = EAC_FIRST_ACTIVE_CONTROL;

    /* harmony export (immutable) */__webpack_exports__["j"] = EAC_LAST_ACTIVE_CONTROL;

    // EActionResponse
    var EAR_UP = 1,
        EAR_DOWN = 2,
        EAR_LEFT = 4,
        EAR_RIGHT = 8;
    /* harmony export (immutable) */__webpack_exports__["q"] = EAR_UP;

    /* harmony export (immutable) */__webpack_exports__["n"] = EAR_DOWN;

    /* harmony export (immutable) */__webpack_exports__["o"] = EAR_LEFT;

    /* harmony export (immutable) */__webpack_exports__["p"] = EAR_RIGHT;

    // EDynamicOffset
    var EDO_NULL = 0,
        EDO_LEFT = 1,
        EDO_RIGHT = 2,
        EDO_HORZ_CENTER = 4,
        EDO_TOP = 8,
        EDO_BOTTOM = 16,
        EDO_VERT_CENTER = 32;
    /* unused harmony export EDO_NULL */

    /* harmony export (immutable) */__webpack_exports__["R"] = EDO_LEFT;

    /* harmony export (immutable) */__webpack_exports__["S"] = EDO_RIGHT;

    /* harmony export (immutable) */__webpack_exports__["Q"] = EDO_HORZ_CENTER;

    /* harmony export (immutable) */__webpack_exports__["T"] = EDO_TOP;

    /* harmony export (immutable) */__webpack_exports__["P"] = EDO_BOTTOM;

    /* harmony export (immutable) */__webpack_exports__["U"] = EDO_VERT_CENTER;

    // ENavNode
    var ENAV_NODE_UP = 0,
        ENAV_NODE_DOWN = 1,
        ENAV_NODE_LEFT = 2,
        ENAV_NODE_RIGHT = 3;
    /* harmony export (immutable) */__webpack_exports__["_41"] = ENAV_NODE_UP;

    /* harmony export (immutable) */__webpack_exports__["_38"] = ENAV_NODE_DOWN;

    /* harmony export (immutable) */__webpack_exports__["_39"] = ENAV_NODE_LEFT;

    /* harmony export (immutable) */__webpack_exports__["_40"] = ENAV_NODE_RIGHT;

    var TOGGLE_STATE_ON = true,
        TOGGLE_STATE_OFF = false;
    /* harmony export (immutable) */__webpack_exports__["_62"] = TOGGLE_STATE_ON;

    /* unused harmony export TOGGLE_STATE_OFF */

    // Value for no active control
    var NO_ACTIVE_CONTROL = -1;
    /* harmony export (immutable) */__webpack_exports__["_58"] = NO_ACTIVE_CONTROL;

    // Increment/Decement constants
    var BTN_DEC = 0,
        BTN_INC = 1;
    /* harmony export (immutable) */__webpack_exports__["a"] = BTN_DEC;

    /* harmony export (immutable) */__webpack_exports__["b"] = BTN_INC;

    // EControlType
    var ECT_NULL = 0,
        ECT_LABEL = 1,
        ECT_BUTTON = 2,
        ECT_BUTTON_LIST = 3,
        ECT_CHECK_BOX = 4,
        ECT_SLIDER = 5,
        ECT_SCROLL_BOX = 6,
        ECT_SUB_CONTROL = 7,
        ECT_METER = 8,
        ECT_TAB_CONTROL = 9,
        ECT_PROGRESS_BAR = 10,
        ECT_AMOUNT_BUTTON = 11;
    /* unused harmony export ECT_NULL */

    /* harmony export (immutable) */__webpack_exports__["J"] = ECT_LABEL;

    /* harmony export (immutable) */__webpack_exports__["G"] = ECT_BUTTON;

    /* harmony export (immutable) */__webpack_exports__["H"] = ECT_BUTTON_LIST;

    /* harmony export (immutable) */__webpack_exports__["I"] = ECT_CHECK_BOX;

    /* harmony export (immutable) */__webpack_exports__["N"] = ECT_SLIDER;

    /* harmony export (immutable) */__webpack_exports__["M"] = ECT_SCROLL_BOX;

    /* harmony export (immutable) */__webpack_exports__["O"] = ECT_SUB_CONTROL;

    /* harmony export (immutable) */__webpack_exports__["K"] = ECT_METER;

    /* unused harmony export ECT_TAB_CONTROL */

    /* harmony export (immutable) */__webpack_exports__["L"] = ECT_PROGRESS_BAR;

    /* unused harmony export ECT_AMOUNT_BUTTON */

    // EControlState
    var ECS_NULL = 0,
        ECS_INIT = 1,
        ECS_DISABLED = 2,
        ECS_INACTIVE = 3,
        ECS_ACTIVE = 4,
        ECS_SELECTED = 5;
    /* harmony export (immutable) */__webpack_exports__["E"] = ECS_NULL;

    /* harmony export (immutable) */__webpack_exports__["D"] = ECS_INIT;

    /* harmony export (immutable) */__webpack_exports__["B"] = ECS_DISABLED;

    /* harmony export (immutable) */__webpack_exports__["C"] = ECS_INACTIVE;

    /* harmony export (immutable) */__webpack_exports__["A"] = ECS_ACTIVE;

    /* harmony export (immutable) */__webpack_exports__["F"] = ECS_SELECTED;

    // EControlActionType
    var ECAT_NULL = 0,
        ECAT_ACTION = 1,
        ECAT_TO_TREE = 2,
        ECAT_TO_MENU = 3,
        ECAT_BACK = 4,
        ECAT_CLOSE = 5,
        ECAT_CHANGE_FOCUS = 6,
        ECAT_GAME_STATE_CHANGE = 7,
        ECAT_QUIT_GAME = 8;
    /* harmony export (immutable) */__webpack_exports__["w"] = ECAT_NULL;

    /* harmony export (immutable) */__webpack_exports__["r"] = ECAT_ACTION;

    /* harmony export (immutable) */__webpack_exports__["z"] = ECAT_TO_TREE;

    /* harmony export (immutable) */__webpack_exports__["y"] = ECAT_TO_MENU;

    /* harmony export (immutable) */__webpack_exports__["s"] = ECAT_BACK;

    /* harmony export (immutable) */__webpack_exports__["u"] = ECAT_CLOSE;

    /* harmony export (immutable) */__webpack_exports__["t"] = ECAT_CHANGE_FOCUS;

    /* harmony export (immutable) */__webpack_exports__["v"] = ECAT_GAME_STATE_CHANGE;

    /* harmony export (immutable) */__webpack_exports__["x"] = ECAT_QUIT_GAME;

    // EControlScriptFunctions
    var ECSF_ON_ACTIVE = 0,
        ECSF_ON_SELECTED = 1;
    /* unused harmony export ECSF_ON_ACTIVE */

    /* unused harmony export ECSF_ON_SELECTED */

    // EMeterScriptFunctions
    var EMSF_ON_INIT = 0,
        EMSF_ON_START = 1,
        EMSF_ON_STOP = 2,
        EMSF_ON_CLEAR = 3;
    /* harmony export (immutable) */__webpack_exports__["_30"] = EMSF_ON_INIT;

    /* harmony export (immutable) */__webpack_exports__["_31"] = EMSF_ON_START;

    /* harmony export (immutable) */__webpack_exports__["_32"] = EMSF_ON_STOP;

    /* harmony export (immutable) */__webpack_exports__["_29"] = EMSF_ON_CLEAR;

    // EOrientation
    var EO_HORIZONTAL = 0,
        EO_VERTICAL = 1;
    /* harmony export (immutable) */__webpack_exports__["_42"] = EO_HORIZONTAL;

    /* harmony export (immutable) */__webpack_exports__["_43"] = EO_VERTICAL;

    /***/
},
/* 1 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME:  size.js
    //  DESC:       size class
    //


    var Size = function () {
        function Size() {
            var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var h = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            _classCallCheck(this, Size);

            this.w = w;
            this.h = h;
        }

        _createClass(Size, [{
            key: 'copy',
            value: function copy(obj) {
                this.w = obj.w;
                this.h = obj.h;
            }

            // 
            //  Set the size data
            //

        }, {
            key: 'set',
            value: function set() {
                var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var h = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                this.w = w;
                this.h = h;
            }

            // 
            //  DESC: Reset the data
            //

        }, {
            key: 'reset',
            value: function reset() {
                this.w = 0;
                this.h = 0;
            }

            // 
            //  DESC: Does this size not have any data?
            //

        }, {
            key: 'isEmpty',
            value: function isEmpty() {
                if (this.w == 0 && this.h == 0) return true;

                return false;
            }

            // 
            //  DESC: Round out the floating point number
            //

        }, {
            key: 'round',
            value: function round() {
                this.w = Math.round(this.w);
                this.h = Math.round(this.h);
            }

            // 
            //  DESC: Access members as UV data
            //

        }, {
            key: 'u',
            set: function set(value) {
                this.w = value;
            },
            get: function get() {
                return this.w;
            }
        }, {
            key: 'v',
            set: function set(value) {
                this.h = value;
            },
            get: function get() {
                return this.h;
            }
        }]);

        return Size;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Size;

    /***/
},
/* 2 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return device;
    });
    /* harmony export (binding) */__webpack_require__.d(__webpack_exports__, "b", function () {
        return gl;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__utilities_settings__ = __webpack_require__(9);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_matrix__ = __webpack_require__(10);

    // 
    //  FILE NAME: device.js
    //  DESC:      Singleton class used for openGL management
    //


    var Device = function () {
        function Device() {
            _classCallCheck(this, Device);

            this.perspectiveMatrix = new __WEBPACK_IMPORTED_MODULE_1__utilities_matrix__["a" /* Matrix */]();
            this.orthographicMatrix = new __WEBPACK_IMPORTED_MODULE_1__utilities_matrix__["a" /* Matrix */]();
            this.canvas = null;
            this.glContext = null;

            // Create the OpenGL context
            this.create();
        }

        // 
        //  DESC: Create the OpenGL context
        //


        _createClass(Device, [{
            key: 'create',
            value: function create() {
                this.canvas = document.getElementById('game-surface');
                this.glContext = this.canvas.getContext('webgl', { premultipliedAlpha: false, alpha: false, stencil: true, preserveDrawingBuffer: true });

                if (!this.glContext) {
                    console.log('WebGL not supported, falling back on experimental-webgl');
                    this.glContext = this.canvas.getContext('experimental-webgl', { premultipliedAlpha: false, alpha: false, stencil: true, preserveDrawingBuffer: true });
                }

                if (!this.glContext) {
                    alert('Your browser does not support WebGL');
                }
            }

            // 
            //  DESC: Create the projection matrixes
            //

        }, {
            key: 'createProjMatrix',
            value: function createProjMatrix() {
                this.perspectiveMatrix.perspectiveFovRH(__WEBPACK_IMPORTED_MODULE_0__utilities_settings__["a" /* settings */].viewAngle, __WEBPACK_IMPORTED_MODULE_0__utilities_settings__["a" /* settings */].screenAspectRatio.w, __WEBPACK_IMPORTED_MODULE_0__utilities_settings__["a" /* settings */].minZdist, __WEBPACK_IMPORTED_MODULE_0__utilities_settings__["a" /* settings */].maxZdist);

                this.orthographicMatrix.orthographicRH(__WEBPACK_IMPORTED_MODULE_0__utilities_settings__["a" /* settings */].defaultSize.w, __WEBPACK_IMPORTED_MODULE_0__utilities_settings__["a" /* settings */].defaultSize.h, __WEBPACK_IMPORTED_MODULE_0__utilities_settings__["a" /* settings */].minZdist, __WEBPACK_IMPORTED_MODULE_0__utilities_settings__["a" /* settings */].maxZdist);
            }
        }]);

        return Device;
    }();

    var device = new Device();
    var gl = device.glContext;

    /***/
},
/* 3 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (immutable) */
    __webpack_exports__["b"] = downloadFile;
    /* harmony export (immutable) */__webpack_exports__["a"] = countStrOccurrence;
    /* harmony export (immutable) */__webpack_exports__["c"] = modulus;
    /* harmony export (immutable) */__webpack_exports__["d"] = randomInt;
    /* unused harmony export randomArbitrary */
    /* harmony export (immutable) */__webpack_exports__["e"] = shuffle;
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__managers_signalmanager__ = __webpack_require__(18);

    // 
    //  FILE NAME: genfunc.js
    //  DESC:      General mutipurpose functions
    //


    // 
    //  DESC: Load files
    //
    function downloadFile(fileType, filepath, callback) {
        var request = null;

        if (fileType !== 'img') request = new XMLHttpRequest();

        if (fileType === 'xml') {
            //console.log(`Load XML: ${filepath}`);
            request.responseType = 'document';
            request.overrideMimeType('text/xml');
        } else if (fileType === 'txt') {
            //console.log(`Load Text: ${filepath}`);
            request.responseType = 'text';
            request.overrideMimeType('text/plain');
        } else if (fileType === 'binary') {
            //console.log(`Load Binary: ${filepath}`);
            request.responseType = 'arraybuffer';
        } else if (fileType === 'img') {
            //console.log(`Load Image: ${filepath}`);
        }

        if (request) {
            // Asynchronous reading of an xml file. Synchronous has been deprecated
            request.onreadystatechange = function () {
                if (this.readyState === 4) {
                    if (this.status >= 200 && this.status < 300 || this.status === 304) {
                        if (fileType === 'xml') callback(this.responseXML.childNodes[0]);else if (fileType === 'txt') callback(this.responseText);else if (fileType === 'binary') callback(this.response);

                        __WEBPACK_IMPORTED_MODULE_0__managers_signalmanager__["a" /* signalManager */].broadcast_loadComplete();
                    } else {
                        throw new Error('HTTP Request failed (' + filepath + ').');
                    }
                }
            };

            // Define which file to open and send the request. True = asynchronous
            request.open('GET', filepath + '?please-dont-cache=' + Math.random(), true);
            request.send();
        } else {
            var image = new Image();

            image.onload = function () {
                callback(image);__WEBPACK_IMPORTED_MODULE_0__managers_signalmanager__["a" /* signalManager */].broadcast_loadComplete();
            };
            image.onerror = function (event) {
                throw new Error('Error downloading file (' + filepath + ')!');
            };

            image.src = filepath;
        }
    }

    // 
    //  DESC: Count the number of occurrences of sub string
    //
    function countStrOccurrence(searchStr, subStr) {
        var result = 0;
        var found = -1;

        do {
            found = searchStr.indexOf(subStr, found + 1);

            if (found != -1) ++result;
        } while (found != -1);

        return result;
    }

    // 
    //  DESC: Perform a modulus operation on the passed in floats
    //
    function modulus(v1, v2) {
        return v1 - v2 * Math.floor(v1 / v2);
    }

    // 
    //  DESC: Generate a random number
    //
    function randomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function randomArbitrary(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    // 
    //  DESC: Shuffle array
    //
    function shuffle(array) {
        if (array.length > 2) {
            var currentIndex = array.length,
                temp = void 0,
                randomIndex = void 0;

            // Get the last sound that was just played
            var oldLastElement = array[array.length - 1];

            // While there remain elements to shuffle...
            while (0 !== currentIndex) {
                // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;

                // And swap it with the current element.
                temp = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temp;
            }

            // Make sure the new first element is not the old last one.
            if (oldLastElement === array[0]) {
                randomIndex = Math.trunc(array.length / 2);
                array[0] = array[randomIndex];
                array[randomIndex] = oldLastElement;
            }
        }
    }

    /***/
},
/* 4 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (immutable) */
    __webpack_exports__["l"] = loadVertex2d;
    /* harmony export (immutable) */__webpack_exports__["e"] = loadPosition;
    /* harmony export (immutable) */__webpack_exports__["h"] = loadRotation;
    /* harmony export (immutable) */__webpack_exports__["i"] = loadScale;
    /* harmony export (immutable) */__webpack_exports__["a"] = loadCenterPos;
    /* unused harmony export loadXYZ */
    /* harmony export (immutable) */__webpack_exports__["b"] = loadColor;
    /* harmony export (immutable) */__webpack_exports__["j"] = loadSize;
    /* harmony export (immutable) */__webpack_exports__["f"] = loadRect;
    /* harmony export (immutable) */__webpack_exports__["g"] = loadRectFromChild;
    /* harmony export (immutable) */__webpack_exports__["d"] = loadHorzAlignment;
    /* harmony export (immutable) */__webpack_exports__["k"] = loadVertAlignment;
    /* harmony export (immutable) */__webpack_exports__["c"] = loadDynamicOffset;
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__common_color__ = __webpack_require__(16);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__common_rect__ = __webpack_require__(20);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__common_vertex2d__ = __webpack_require__(26);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__common_dynamicoffset__ = __webpack_require__(30);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: xmlparsehelper.js
    //  DESC:      General xml parse helper functions
    //             NOTE: Nonexistant attributes return null
    //


    // 
    //  DESC: Load the 2d vertex
    //
    function loadVertex2d(node) {
        if (node) {
            var vert2d = new __WEBPACK_IMPORTED_MODULE_4__common_vertex2d__["a" /* Vertex2d */]();

            var attr = node.getAttribute('x');
            if (attr) vert2d.x = Number(attr);

            attr = node.getAttribute('y');
            if (attr) vert2d.y = Number(attr);

            attr = node.getAttribute('z');
            if (attr) vert2d.z = Number(attr);

            attr = node.getAttribute('u');
            if (attr) vert2d.u = Number(attr);

            attr = node.getAttribute('v');
            if (attr) vert2d.v = Number(attr);

            return vert2d;
        }

        return null;
    }

    // 
    //  DESC: Load the position
    //
    function loadPosition(node) {
        var positionNode = node.getElementsByTagName('position');

        if (positionNode.length) {
            var point = new __WEBPACK_IMPORTED_MODULE_2__common_point__["a" /* Point */]();

            var attr = positionNode[0].getAttribute('x');
            if (attr) point.x = Number(attr);

            attr = positionNode[0].getAttribute('y');
            if (attr) point.y = Number(attr);

            attr = positionNode[0].getAttribute('z');
            if (attr) point.z = Number(attr);

            return point;
        }

        return null;
    }

    // 
    //  DESC: Load the position
    //
    function loadRotation(node) {
        var rotationNode = node.getElementsByTagName('rotation');

        if (rotationNode.length) {
            var rotation = new __WEBPACK_IMPORTED_MODULE_2__common_point__["a" /* Point */]();

            var attr = rotationNode[0].getAttribute('x');
            if (attr) rotation.x = Number(attr);

            attr = rotationNode[0].getAttribute('y');
            if (attr) rotation.y = Number(attr);

            attr = rotationNode[0].getAttribute('z');
            if (attr) rotation.z = Number(attr);

            return rotation;
        }

        return null;
    }

    // 
    //  DESC: Load the scale
    //
    function loadScale(node) {
        var scaleNode = node.getElementsByTagName('scale');

        if (scaleNode.length) {
            var scale = new __WEBPACK_IMPORTED_MODULE_2__common_point__["a" /* Point */]();

            var attr = scaleNode[0].getAttribute('x');
            if (attr) scale.x = Number(attr);

            attr = scaleNode[0].getAttribute('y');
            if (attr) scale.y = Number(attr);

            attr = scaleNode[0].getAttribute('z');
            if (attr) scale.z = Number(attr);

            return scale;
        }

        return null;
    }

    // 
    //  DESC: Load the center position
    //
    function loadCenterPos(node) {
        var centerPosNode = node.getElementsByTagName('centerPos');

        if (centerPosNode.length) {
            var centerPos = new __WEBPACK_IMPORTED_MODULE_2__common_point__["a" /* Point */]();

            var attr = centerPosNode[0].getAttribute('x');
            if (attr) centerPos.x = Number(attr);

            attr = centerPosNode[0].getAttribute('y');
            if (attr) centerPos.y = Number(attr);

            attr = centerPosNode[0].getAttribute('z');
            if (attr) centerPos.z = Number(attr);

            return centerPos;
        }

        return null;
    }

    // 
    //  DESC: Load the generic x, y, z values
    //
    function loadXYZ(node) {
        var point = new __WEBPACK_IMPORTED_MODULE_2__common_point__["a" /* Point */]();

        var attr = node.getAttribute('x');
        if (attr) point.x = Number(attr);

        attr = node.getAttribute('y');
        if (attr) point.y = Number(attr);

        attr = node.getAttribute('z');
        if (attr) point.z = Number(attr);

        return point;
    } // LoadScale

    // 
    //  DESC: Load the color
    //
    function loadColor(node) {
        var currentColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var color = new __WEBPACK_IMPORTED_MODULE_0__common_color__["a" /* Color */]();

        if (currentColor) color.copy(currentColor);

        var colorNode = node.getElementsByTagName('color');
        if (colorNode.length) {
            var attr = colorNode[0].getAttribute('r');
            if (attr) color.r = Number(attr);

            attr = colorNode[0].getAttribute('g');
            if (attr) color.g = Number(attr);

            attr = colorNode[0].getAttribute('b');
            if (attr) color.b = Number(attr);

            attr = colorNode[0].getAttribute('a');
            if (attr) color.a = Number(attr);

            // Convert if in RGBA format
            color.convert();
        }

        return color;
    }

    // 
    //  DESC: Load the size
    //
    function loadSize(node) {
        var currentSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var size = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */]();

        if (currentSize) size.copy(currentSize);

        var sizeNode = node.getElementsByTagName('size');
        if (sizeNode.length) {
            var attr = sizeNode[0].getAttribute('width');
            if (attr) size.w = Number(attr);

            attr = sizeNode[0].getAttribute('height');
            if (attr) size.h = Number(attr);
        }

        return size;
    }

    // 
    //  DESC: Load the rect
    //
    function loadRect(node) {
        var rectNode = node.getElementsByTagName('rect');

        if (rectNode.length) return loadRectFromChild(rectNode[0]);

        return new __WEBPACK_IMPORTED_MODULE_3__common_rect__["a" /* Rect */]();
    }

    function loadRectFromChild(node) {
        var rect = new __WEBPACK_IMPORTED_MODULE_3__common_rect__["a" /* Rect */]();

        var attr = node.getAttribute('x1');
        if (attr) rect.x1 = Number(attr);

        attr = node.getAttribute('y1');
        if (attr) rect.y1 = Number(attr);

        attr = node.getAttribute('x2');
        if (attr) rect.x2 = Number(attr);

        attr = node.getAttribute('y2');
        if (attr) rect.y2 = Number(attr);

        return rect;
    }

    // 
    //  DESC: Load the horizontal alignment
    //
    function loadHorzAlignment(node, aHorzAlign) {
        var horzAlign = aHorzAlign;

        var horzAlignAttr = node.getAttribute('horzAlign');
        if (horzAlignAttr) {
            if (horzAlignAttr === 'left') horzAlign = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_25" /* EHA_HORZ_LEFT */];else if (horzAlignAttr === 'center') horzAlign = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_24" /* EHA_HORZ_CENTER */];else if (horzAlignAttr === 'right') horzAlign = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_26" /* EHA_HORZ_RIGHT */];
        }

        return horzAlign;
    }

    // 
    //  DESC: Load the vertical alignment
    //
    function loadVertAlignment(node, aVertAlign) {
        var vertAlign = aVertAlign;

        var vertAlignAttr = node.getAttribute('vertAlign');
        if (vertAlignAttr) {
            if (vertAlignAttr === 'top') vertAlign = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_54" /* EVA_VERT_TOP */];else if (vertAlignAttr === 'center') vertAlign = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_53" /* EVA_VERT_CENTER */];else if (vertAlignAttr === 'bottom') vertAlign = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_52" /* EVA_VERT_BOTTOM */];
        }

        return vertAlign;
    }

    // 
    //  DESC: Load the dynamic offset
    //
    function loadDynamicOffset(node) {
        var dynamicOffsetNode = node.getElementsByTagName('dynamicOffset');

        if (dynamicOffsetNode.length) {
            var dynamicOffset = new __WEBPACK_IMPORTED_MODULE_5__common_dynamicoffset__["a" /* DynamicOffset */]();

            var attr = dynamicOffsetNode[0].getAttribute('left');
            if (attr) {
                dynamicOffset.add(__WEBPACK_IMPORTED_MODULE_6__common_defs__["R" /* EDO_LEFT */]);
                dynamicOffset.setX(Number(attr));
            } else {
                attr = dynamicOffsetNode[0].getAttribute('right');
                if (attr) {
                    dynamicOffset.add(__WEBPACK_IMPORTED_MODULE_6__common_defs__["S" /* EDO_RIGHT */]);
                    dynamicOffset.setX(Number(attr));
                } else {
                    attr = dynamicOffsetNode[0].getAttribute('horzCenter');
                    if (attr) {
                        dynamicOffset.add(__WEBPACK_IMPORTED_MODULE_6__common_defs__["Q" /* EDO_HORZ_CENTER */]);
                        dynamicOffset.setX(Number(attr));
                    }
                }
            }

            attr = dynamicOffsetNode[0].getAttribute('top');
            if (attr) {
                dynamicOffset.add(__WEBPACK_IMPORTED_MODULE_6__common_defs__["T" /* EDO_TOP */]);
                dynamicOffset.setY(Number(attr));
            } else {
                attr = dynamicOffsetNode[0].getAttribute('bottom');
                if (attr) {
                    dynamicOffset.add(__WEBPACK_IMPORTED_MODULE_6__common_defs__["P" /* EDO_BOTTOM */]);
                    dynamicOffset.setY(Number(attr));
                } else {
                    attr = dynamicOffsetNode[0].getAttribute('vertCenter');
                    if (attr) {
                        dynamicOffset.add(__WEBPACK_IMPORTED_MODULE_6__common_defs__["U" /* EDO_VERT_CENTER */]);
                        dynamicOffset.setX(Number(attr));
                    }
                }
            }

            return dynamicOffset;
        }

        return null;
    }

    /***/
},
/* 5 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME:  point.js
    //  DESC:       Point class
    //


    var Point = function () {
        function Point() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            _classCallCheck(this, Point);

            this.data = new Float32Array([x, y, z]);
        }

        _createClass(Point, [{
            key: 'copy',
            value: function copy(obj) {
                this.data[0] = obj.data[0];
                this.data[1] = obj.data[1];
                this.data[2] = obj.data[2];
            }
        }, {
            key: 'convertToRads',
            value: function convertToRads() {
                this.x *= __WEBPACK_IMPORTED_MODULE_0__common_defs__["g" /* DEG_TO_RAD */];
                this.y *= __WEBPACK_IMPORTED_MODULE_0__common_defs__["g" /* DEG_TO_RAD */];
                this.z *= __WEBPACK_IMPORTED_MODULE_0__common_defs__["g" /* DEG_TO_RAD */];
            }
        }, {
            key: 'setXYZ',
            value: function setXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                this.data[0] = x;
                this.data[1] = y;
                this.data[2] = z;
            }
        }, {
            key: 'set',
            value: function set(point) {
                this.data[0] = point.data[0];
                this.data[1] = point.data[1];
                this.data[2] = point.data[2];
            }
        }, {
            key: 'incXYZ',
            value: function incXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                this.data[0] += x;
                this.data[1] += y;
                this.data[2] += z;
            }
        }, {
            key: 'inc',
            value: function inc(point) {
                this.data[0] += point.data[0];
                this.data[1] += point.data[1];
                this.data[2] += point.data[2];
            }
        }, {
            key: 'cap',
            value: function cap(value) {
                if (value > 0) {
                    if (this.x > value) {
                        this.x -= value;
                    } else if (this.x < 0) {
                        this.x += value;
                    }

                    if (this.y > value) {
                        this.y -= value;
                    } else if (this.y < 0) {
                        this.y += value;
                    }

                    if (this.z > value) {
                        this.z -= value;
                    } else if (this.z < 0) {
                        this.z += value;
                    }
                } else {
                    if (this.x > value) {
                        this.x += value;
                    } else if (this.x < 0) {
                        this.x -= value;
                    }

                    if (this.y > value) {
                        this.y += value;
                    } else if (this.y < 0) {
                        this.y -= value;
                    }

                    if (this.z > value) {
                        this.z += value;
                    } else if (this.z < 0) {
                        this.z -= value;
                    }
                }
            }
        }, {
            key: 'getInvert',
            value: function getInvert() {
                var tmp = new Point();
                tmp.invert();

                return tmp;
            }
        }, {
            key: 'invert',
            value: function invert() {
                this.data[0] = -this.data[0];
                this.data[1] = -this.data[1];
                this.data[2] = -this.data[2];
            }
        }, {
            key: 'isEmpty',
            value: function isEmpty() {
                if (this.x == 0 && this.y == 0 && this.z == 0) return true;

                return false;
            }
        }, {
            key: 'isXEmpty',
            value: function isXEmpty() {
                return 0 === this.x;
            }
        }, {
            key: 'isYEmpty',
            value: function isYEmpty() {
                return 0 === this.y;
            }
        }, {
            key: 'isZEmpty',
            value: function isZEmpty() {
                return 0 === this.z;
            }
        }, {
            key: 'x',
            set: function set(value) {
                this.data[0] = value;
            },
            get: function get() {
                return this.data[0];
            }
        }, {
            key: 'y',
            set: function set(value) {
                this.data[1] = value;
            },
            get: function get() {
                return this.data[1];
            }
        }, {
            key: 'z',
            set: function set(value) {
                this.data[2] = value;
            },
            get: function get() {
                return this.data[2];
            }
        }]);

        return Point;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Point;

    /***/
},
/* 6 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return textureManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__common_texture__ = __webpack_require__(37);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__system_device__ = __webpack_require__(2);

    //
    //  FILE NAME: texturemanager.js
    //  DESC:      texture class singleton
    //


    var TextureManager = function () {
        function TextureManager() {
            _classCallCheck(this, TextureManager);

            // Map containing a group of texture handles
            this.textureForMapMap = new Map();

            // Current texture
            this.currentTexture = null;
        }

        //
        //  DESC: Load the image file as a texture
        //


        _createClass(TextureManager, [{
            key: 'load',
            value: function load(group, filePath, image) {
                if (!image.complete) throw new Error('Image file not completely loaded! (' + group + ', ' + filePath + ').');

                // Create the group map if it doesn't already exist
                var groupMap = this.textureForMapMap.get(group);
                if (groupMap === undefined) {
                    groupMap = new Map();
                    this.textureForMapMap.set(group, groupMap);
                }

                var texture = groupMap.get(filePath);
                if (texture === undefined) {
                    var _texture = new __WEBPACK_IMPORTED_MODULE_0__common_texture__["a" /* Texture */]();
                    _texture.id = __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].createTexture();
                    _texture.size.w = image.width;
                    _texture.size.h = image.height;

                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].bindTexture(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_2D, _texture.id);
                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].texParameteri(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_2D, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_WRAP_S, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].CLAMP_TO_EDGE);
                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].texParameteri(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_2D, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_WRAP_T, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].CLAMP_TO_EDGE);
                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].texParameteri(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_2D, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_MIN_FILTER, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].LINEAR);
                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].texParameteri(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_2D, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_MAG_FILTER, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].LINEAR);
                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].texImage2D(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_2D, 0, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].RGBA, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].RGBA, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].UNSIGNED_BYTE, image);
                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].bindTexture(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_2D, null);

                    groupMap.set(filePath, _texture);
                }

                return texture;
            }

            //
            //  DESC: Delete the group of textures
            //

        }, {
            key: 'deleteGroup',
            value: function deleteGroup(group) {
                var groupMap = this.textureForMapMap.get(group);
                if (groupMap !== undefined) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = groupMap.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var _step$value = _slicedToArray(_step.value, 2),
                                key = _step$value[0],
                                texture = _step$value[1];

                            __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].deleteTexture(texture.id);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    this.textureForMapMap.delete(group);
                }
            }

            //
            //  DESC: Get the 2D texture class
            //

        }, {
            key: 'getTexture',
            value: function getTexture(group, filePath) {
                var groupMap = this.textureForMapMap.get(group);
                if (groupMap !== undefined) {
                    var texture = groupMap.get(filePath);
                    if (texture !== undefined) return texture;

                    throw new Error('Texture does not exists! (' + group + ', ' + filePath + ').');
                }
                // Santy check.
                else {
                        throw new Error('Texture group does not exists! (' + group + ', ' + filePath + ').');
                    }

                return null;
            }

            //
            //  DESC: Create OpenGL objects from data
            //

        }, {
            key: 'bind',
            value: function bind(textureId) {
                if (this.currentTexture != textureId) {
                    // save the current binding
                    this.currentTexture = textureId;

                    // Have OpenGL bind this texture now
                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].bindTexture(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_2D, textureId);
                }
            }

            //
            //  DESC: Unbind the texture and reset the flag
            //

        }, {
            key: 'unbind',
            value: function unbind() {
                this.currentTexture = null;
                __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].bindTexture(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].TEXTURE_2D, null);
            }
        }]);

        return TextureManager;
    }();

    var textureManager = new TextureManager();

    /***/
},
/* 7 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return eventManager;
    });

    //
    //  FILE NAME: eventmanager.js
    //  DESC:      event manager class singleton
    //


    var EventManager = function () {
        function EventManager() {
            _classCallCheck(this, EventManager);

            this.canvas = document.getElementById('game-surface');
            this.queue = [];

            // Init with the most common events

            // Event handlers
            this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
            this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
            this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));

            // Using document for key listener because canvas needs the focus before
            // it will trap key events. There's no good solution for force the focus
            // onto the canvas
            document.addEventListener('keydown', this.onKeyDown.bind(this));
            document.addEventListener('keyup', this.onKeyUp.bind(this));

            document.addEventListener('scroll', this.onScroll.bind(this));

            //this.canvas.addEventListener('keydown', this.onKeyDown.bind(this) );
            //this.canvas.addEventListener('keyup', this.onKeyUp.bind(this) );

            // Mouse move relative offset data types
            this.lastMouseMoveX = 0;
            this.lastMouseMoveY = 0;

            this.mouseMoveRelX = 0;
            this.mouseMoveRelY = 0;

            this.mouseMoveOffsetX = document.documentElement.scrollLeft - this.canvas.offsetLeft;
            this.mouseMoveOffsetY = document.documentElement.scrollTop - this.canvas.offsetTop;
        }

        _createClass(EventManager, [{
            key: 'pollEvent',
            value: function pollEvent() {
                if (this.queue.length) return this.queue.shift();

                return null;
            }
        }, {
            key: 'dispatchEvent',
            value: function dispatchEvent(_type) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }

                var event = new CustomEvent('customEvent', {
                    detail: {
                        type: _type,
                        arg: args
                    }
                });

                this.queue.push(event);
            }
        }, {
            key: 'onScroll',
            value: function onScroll(event) {
                this.mouseMoveOffsetX = document.documentElement.scrollLeft - this.canvas.offsetLeft;
                this.mouseMoveOffsetY = document.documentElement.scrollTop - this.canvas.offsetTop;
            }
        }, {
            key: 'onMouseDown',
            value: function onMouseDown(event) {
                this.queue.push(event);

                //console.log( event.type + ', ' + event.button );
            }
        }, {
            key: 'onMouseUp',
            value: function onMouseUp(event) {
                this.queue.push(event);
            }
        }, {
            key: 'onMouseMove',
            value: function onMouseMove(event) {
                this.queue.push(event);

                this.mouseMoveRelX = event.movementX;
                this.mouseMoveRelY = event.movementY;

                this.lastMouseMoveX = event.clientX + this.mouseMoveOffsetX;
                this.lastMouseMoveY = event.clientY + this.mouseMoveOffsetY;

                //console.log( `Mouse move - ClientX: ${event.clientX}, ClientY: ${event.clientY}, OffsetX: ${event.offsetX}, OffsetY: ${event.offsetY}, RelX: ${event.movementX}, RelY: ${event.movementY}` );
                //console.log(`Canvas Offset: ${this.canvas.offsetLeft} x ${this.canvas.offsetTop}`);
                //console.log(`Document Offset: ${document.documentElement.scrollLeft} x ${document.documentElement.scrollTop}`);
            }
        }, {
            key: 'onKeyDown',
            value: function onKeyDown(event) {
                if (event.repeat === false) {
                    this.queue.push(event);

                    //console.log( event.type + ', ' + event.key + ', ' + event.keyCode );
                }
            }
        }, {
            key: 'onKeyUp',
            value: function onKeyUp(event) {
                this.queue.push(event);
            }
        }, {
            key: 'onCustomEvent',
            value: function onCustomEvent(event) {
                this.queue.push(event);

                //console.log( `Custom Event was sent. ${event.detail.type}, ${event.detail.arg[0]}, ${event.detail.arg[1]}` );
            }
        }, {
            key: 'mouseX',
            get: function get() {
                return this.lastMouseMoveX;
            }
        }, {
            key: 'mouseY',
            get: function get() {
                return this.lastMouseMoveY;
            }
        }, {
            key: 'mouseRelX',
            get: function get() {
                return this.mouseMoveRelX;
            }
        }, {
            key: 'mouseRelY',
            get: function get() {
                return this.mouseMoveRelY;
            }
        }, {
            key: 'mouseOffsetX',
            get: function get() {
                return this.mouseMoveOffsetX;
            }
        }, {
            key: 'mouseOffsetY',
            get: function get() {
                return this.mouseMoveOffsetY;
            }
        }]);

        return EventManager;
    }();

    var eventManager = new EventManager();

    /***/
},
/* 8 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return highResTimer;
    });

    // 
    //  FILE NAME: highresolutiontimer.js
    //  DESC:      high resolution timer class
    //


    var HighResTimer = function () {
        function HighResTimer() {
            _classCallCheck(this, HighResTimer);

            // Last recorded time
            this.lastTime = performance.now();

            // Timer time
            this.timer;

            // The amount of time that has elapsed between frames
            this.elapsedTime;

            // The frames per second
            this.fps;
        }

        //
        //  DESC: Simple timer start
        //


        _createClass(HighResTimer, [{
            key: 'timerStart',
            value: function timerStart() {
                // Get the current performance time
                this.timer = performance.now();
            }

            //
            //  DESC: Simple timer duration
            //

        }, {
            key: 'timerStop',
            value: function timerStop() {
                // Get the elapsed time
                return performance.now() - this.timer;
            }

            //
            //  DESC: Calc the elapsed time
            //

        }, {
            key: 'calcElapsedTime',
            value: function calcElapsedTime() {
                // Get the current performance time
                var time = performance.now();

                // Set the elapsed time
                this.elapsedTime = time - this.lastTime;

                // Set the fps
                this.fps = 1000.0 / this.elapsedTime;

                // Catch any hickups - cap to about 10 fps
                // Elapsed time is not expected to get this 
                // high in  a game which is why it's capped
                if (this.elapsedTime > 100.0) this.elapsedTime = 100.0;

                // Reset the last time
                this.lastTime = time;
            }
        }]);

        return HighResTimer;
    }();

    var highResTimer = new HighResTimer();

    /***/
},
/* 9 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return settings;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: settings.js
    //  DESC:      game settings singleton class
    //


    var Settings = function () {
        function Settings() {
            _classCallCheck(this, Settings);

            this.size = new __WEBPACK_IMPORTED_MODULE_0__common_size__["a" /* Size */]();
            this.size_half = new __WEBPACK_IMPORTED_MODULE_0__common_size__["a" /* Size */]();
            this.nativeSize = new __WEBPACK_IMPORTED_MODULE_0__common_size__["a" /* Size */]();
            this.screenAspectRatio = new __WEBPACK_IMPORTED_MODULE_0__common_size__["a" /* Size */]();
            this.orthoAspectRatio = new __WEBPACK_IMPORTED_MODULE_0__common_size__["a" /* Size */]();
            this.defaultSize = new __WEBPACK_IMPORTED_MODULE_0__common_size__["a" /* Size */]();
            this.defaultSize_half = new __WEBPACK_IMPORTED_MODULE_0__common_size__["a" /* Size */]();

            this.enableDepthBuffer = false;
            this.createStencilBuffer = false;
            this.clearStencilBuffer = false;
            this.stencilBufferBitSize = 1;
            this.clearTargetBuffer = true;
            this.projectionType = __WEBPACK_IMPORTED_MODULE_1__common_defs__["_45" /* EPT_PERSPECTIVE */];
            this.viewAngle = 45.0 * __WEBPACK_IMPORTED_MODULE_1__common_defs__["g" /* DEG_TO_RAD */];
            this.minZdist = 5.0;
            this.maxZdist = 1000.5;

            // the sector size
            this.sectorSize = 0;
            this.sectorSizeHalf = 0;
        }

        // 
        //  DESC: Load data from XML node
        //


        _createClass(Settings, [{
            key: 'load',
            value: function load(node) {
                if (node) {
                    var display = node.getElementsByTagName('display');
                    if (display.length) {
                        var resolution = display[0].getElementsByTagName('resolution');
                        if (resolution.length) {
                            this.size.w = Number(resolution[0].getAttribute('width'));
                            this.size.h = Number(resolution[0].getAttribute('height'));
                        }

                        var defaultRes = display[0].getElementsByTagName('default');
                        if (defaultRes.length) {
                            this.nativeSize.w = Number(defaultRes[0].getAttribute('width'));
                            this.nativeSize.h = Number(defaultRes[0].getAttribute('height'));
                            this.defaultSize.h = this.nativeSize.h;
                        }
                    }

                    var device = node.getElementsByTagName('device');
                    if (device.length) {
                        var projection = device[0].getElementsByTagName('projection');
                        if (projection.length) {
                            var attr = projection[0].getAttribute('projectType');
                            if (attr && attr === 'orthographic') this.projectionType = __WEBPACK_IMPORTED_MODULE_1__common_defs__["_44" /* EPT_ORTHOGRAPHIC */];

                            attr = projection[0].getAttribute('minZDist');
                            if (attr) this.minZdist = Number(attr);

                            attr = projection[0].getAttribute('maxZDist');
                            if (attr) this.maxZdist = Number(attr);

                            attr = projection[0].getAttribute('view_angle');
                            if (attr) this.viewAngle = Number(attr) * __WEBPACK_IMPORTED_MODULE_1__common_defs__["g" /* DEG_TO_RAD */];
                        }

                        var depthStencilBuffer = device[0].getElementsByTagName('depthStencilBuffer');
                        if (depthStencilBuffer.length) {
                            this.enableDepthBuffer = depthStencilBuffer[0].getAttribute('enableDepthBuffer') === 'true';
                            this.createStencilBuffer = depthStencilBuffer[0].getAttribute('createStencilBuffer') === 'true';
                            this.clearStencilBuffer = depthStencilBuffer[0].getAttribute('clearStencilBuffer') === 'true';
                            this.stencilBufferBitSize = Number(depthStencilBuffer[0].getAttribute('stencilBufferBitSize'));
                        }

                        var targetBuffer = device[0].getElementsByTagName('targetBuffer');
                        if (targetBuffer.length) this.clearTargetBuffer = targetBuffer[0].getAttribute('clear') === 'true';
                    }

                    var worldNode = node.getElementsByTagName('world');
                    if (worldNode.length) {
                        this.sectorSize = Number(worldNode[0].getAttribute('sectorSize'));
                        this.sectorSizeHalf = Math.trunc(this.sectorSize / 2);
                    }
                }

                this.calcRatio();
            }

            // 
            //  DESC: Calculate the ratios
            //

        }, {
            key: 'calcRatio',
            value: function calcRatio() {
                // Height and width screen ratio for perspective projection
                this.screenAspectRatio.w = this.size.w / this.size.h;
                this.screenAspectRatio.h = this.size.h / this.size.w;

                // NOTE: The default width is based on the current aspect ratio
                // NOTE: Make sure the width does not have a floating point component
                this.defaultSize.w = Math.floor(this.screenAspectRatio.w * this.defaultSize.h + 0.5);

                // Get half the size for use with screen boundries
                this.defaultSize_half.w = this.defaultSize.w / 2;
                this.defaultSize_half.h = this.defaultSize.h / 2;

                // Screen size devided by two
                this.size_half.w = this.size.w / 2;
                this.size_half.h = this.size.h / 2;

                // Precalculate the aspect ratios for orthographic projection
                this.orthoAspectRatio.h = this.size.h / this.defaultSize.h;
                this.orthoAspectRatio.w = this.size.w / this.defaultSize.w;
            }
        }]);

        return Settings;
    }();

    var settings = new Settings();

    /***/
},
/* 10 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME:  matrix.js
    //  DESC:       4x4 Matrix math class
    //


    var NO_ROT = 0;
    var ROT_Z = 1;
    var ROT_Y = 2;
    var ROT_X = 4;
    var ROT_ALL = ROT_Z | ROT_Y | ROT_X;

    var Matrix = function () {
        function Matrix() {
            var matrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            _classCallCheck(this, Matrix);

            this.matrix = new Float32Array(16);

            if (matrix === null) this.initilizeMatrix();else this.copy(matrix);
        }

        _createClass(Matrix, [{
            key: 'copy',
            value: function copy(obj) {
                for (var i = 0; i < this.matrix.length; ++i) {
                    this.matrix[i] = obj.matrix[i];
                }
            }

            //
            //  DESC: Init the matrix to the identity matrix
            //

        }, {
            key: 'initilizeMatrix',
            value: function initilizeMatrix() {
                this.initIdentityMatrix(this.matrix);
            }
        }, {
            key: 'initIdentityMatrix',
            value: function initIdentityMatrix(mat) {
                // Initializes a specific matrix to the identity matrix:
                mat[0] = 1.0;mat[1] = 0.0;mat[2] = 0.0;mat[3] = 0.0;
                mat[4] = 0.0;mat[5] = 1.0;mat[6] = 0.0;mat[7] = 0.0;
                mat[8] = 0.0;mat[9] = 0.0;mat[10] = 1.0;mat[11] = 0.0;
                mat[12] = 0.0;mat[13] = 0.0;mat[14] = 0.0;mat[15] = 1.0;
            }

            //
            //  DESC: Merge matrix into master matrix
            //  

        }, {
            key: 'mergeMatrix',
            value: function mergeMatrix(matrix) {
                var temp = new Float32Array(16);

                for (var i = 0; i < 4; ++i) {
                    for (var j = 0; j < 4; ++j) {
                        temp[i * 4 + j] = this.matrix[i * 4] * matrix[j] + this.matrix[i * 4 + 1] * matrix[4 + j] + this.matrix[i * 4 + 2] * matrix[8 + j] + this.matrix[i * 4 + 3] * matrix[12 + j];
                    }
                }

                // Let the temp be the new master matrix
                this.matrix = temp;
            }

            //
            //  DESC: Generate 3D rotation matrix
            //

        }, {
            key: 'rotate',
            value: function rotate(point) {
                var flags = NO_ROT;
                var rMatrix = new Float32Array(16);

                // init the rotation matrix
                this.initIdentityMatrix(rMatrix);

                // Apply Z rotation
                if (!point.isZEmpty()) {
                    this.rotateZRad(rMatrix, point.z, flags);
                    flags |= ROT_Z;
                }

                // Apply Y rotation
                if (!point.isYEmpty()) {
                    this.rotateYRad(rMatrix, point.y, flags);
                    flags |= ROT_Y;
                }

                // Apply X rotation
                if (!point.isXEmpty()) {
                    this.rotateXRad(rMatrix, point.x, flags);
                    flags |= ROT_X;
                }

                // Merg the rotation into the master matrix
                this.mergeMatrix(rMatrix);
            }

            //
            //  DESC: Rotate the matrix along the z axis
            //

        }, {
            key: 'rotateZRad',
            value: function rotateZRad(dest, value) {
                var cos = Math.cos(value);
                var sin = Math.sin(value);

                dest[0] = cos;
                dest[1] = sin;
                dest[4] = -sin;
                dest[5] = cos;
            }

            //
            //  DESC: Rotate the matrix along the y axis
            //

        }, {
            key: 'rotateYRad',
            value: function rotateYRad(dest, value, rotFlags) {
                var cos = Math.cos(value);
                var sin = Math.sin(value);

                switch (rotFlags) {
                    case ROT_Z:
                        {
                            var tmp0 = void 0,
                                tmp1 = void 0,
                                tmp8 = void 0,
                                tmp9 = void 0;
                            tmp0 = dest[0] * cos;
                            tmp1 = dest[1] * cos;
                            tmp8 = dest[0] * sin;
                            tmp9 = dest[1] * sin;
                            dest[0] = tmp0;
                            dest[1] = tmp1;
                            dest[2] = -sin;
                            dest[8] = tmp8;
                            dest[9] = tmp9;
                            dest[10] = cos;
                            break;
                        }
                    case NO_ROT:
                        {
                            dest[0] = cos;
                            dest[2] = -sin;
                            dest[8] = sin;
                            dest[10] = cos;
                            break;
                        }
                }
            }

            //
            //  DESC: Rotate the matrix along the x axis
            //

        }, {
            key: 'rotateXRad',
            value: function rotateXRad(dest, value, rotFlags) {
                var cos = Math.cos(value);
                var sin = Math.sin(value);

                switch (rotFlags) {
                    case ROT_Z:
                        {
                            var tmp4 = void 0,
                                tmp5 = void 0,
                                tmp8 = void 0,
                                tmp9 = void 0;
                            tmp4 = dest[4] * cos;
                            tmp5 = dest[5] * cos;
                            tmp8 = dest[4] * -sin;
                            tmp9 = dest[5] * -sin;
                            dest[4] = tmp4;
                            dest[5] = tmp5;
                            dest[6] = sin;
                            dest[8] = tmp8;
                            dest[9] = tmp9;
                            dest[10] = cos;
                            break;
                        }

                    case ROT_Y:
                        {
                            var _tmp = void 0,
                                tmp6 = void 0,
                                _tmp2 = void 0,
                                tmp10 = void 0;
                            _tmp = dest[8] * sin;
                            tmp6 = dest[10] * sin;
                            _tmp2 = dest[8] * cos;
                            tmp10 = dest[10] * cos;
                            dest[4] = _tmp;
                            dest[5] = cos;
                            dest[6] = tmp6;
                            dest[8] = _tmp2;
                            dest[9] = -sin;
                            dest[10] = tmp10;
                            break;
                        }

                    case ROT_Z | ROT_Y:
                        {
                            var _tmp3 = void 0,
                                _tmp4 = void 0,
                                _tmp5 = void 0,
                                _tmp6 = void 0,
                                _tmp7 = void 0,
                                _tmp8 = void 0;
                            _tmp3 = dest[4] * cos + dest[8] * sin;
                            _tmp4 = dest[5] * cos + dest[9] * sin;
                            _tmp5 = dest[10] * sin;
                            _tmp6 = dest[4] * -sin + dest[8] * cos;
                            _tmp7 = dest[5] * -sin + dest[9] * cos;
                            _tmp8 = dest[10] * cos;
                            dest[4] = _tmp3;
                            dest[5] = _tmp4;
                            dest[6] = _tmp5;
                            dest[8] = _tmp6;
                            dest[9] = _tmp7;
                            dest[10] = _tmp8;
                            break;
                        }

                    case NO_ROT:
                        {
                            dest[5] = cos;
                            dest[6] = sin;
                            dest[9] = -sin;
                            dest[10] = cos;
                            break;
                        }
                }
            }

            //
            //  DESC: Translate the point
            //

        }, {
            key: 'translate',
            value: function translate(point) {
                this.matrix[12] += point.x;
                this.matrix[13] += point.y;
                this.matrix[14] += point.z;
            }
        }, {
            key: 'translateSize',
            value: function translateSize(size) {
                this.matrix[12] += size.w;
                this.matrix[13] += size.h;
            }

            //
            //  DESC: Transform the type
            //

        }, {
            key: 'transformPoint',
            value: function transformPoint(dest, source) {
                dest.x = source.x * this.matrix[0] + source.y * this.matrix[4] + source.z * this.matrix[8] + this.matrix[12];

                dest.y = source.x * this.matrix[1] + source.y * this.matrix[5] + source.z * this.matrix[9] + this.matrix[13];

                dest.z = source.x * this.matrix[2] + source.y * this.matrix[6] + source.z * this.matrix[10] + this.matrix[14];
            }
        }, {
            key: 'transformRect',
            value: function transformRect(dest, source) {
                // Transform vertex by master matrix:
                dest.x1 = source.x1 * this.matrix[0] + source.y1 * this.matrix[4] + this.matrix[12];

                dest.y1 = source.x1 * this.matrix[1] + source.y1 * this.matrix[5] + this.matrix[13];

                dest.x2 = source.x2 * this.matrix[0] + source.y2 * this.matrix[4] + this.matrix[12];

                dest.y2 = source.x2 * this.matrix[1] + source.y2 * this.matrix[5] + this.matrix[13];
            }
        }, {
            key: 'transformQuad',
            value: function transformQuad(dest, source) {
                for (var i = 0; i < 4; ++i) {
                    this.transformPoint(dest.point[i], source.point[i]);
                }
            }

            //
            //  DESC: Set the scale to the master matrix
            //

        }, {
            key: 'setScaleFromPoint',
            value: function setScaleFromPoint(point) {
                // Initialize scaling matrix:
                this.matrix[0] *= point.x;
                this.matrix[5] *= point.y;
                this.matrix[10] *= point.z;
            }
        }, {
            key: 'setScaleFromSize',
            value: function setScaleFromSize(size) {
                // Initialize scaling matrix:
                this.matrix[0] *= size.w;
                this.matrix[5] *= size.h;
                this.matrix[10] *= 1.0;
            }
        }, {
            key: 'setScaleFromValue',
            value: function setScaleFromValue(scale) {
                // Initialize scaling matrix:
                this.matrix[0] *= scale;
                this.matrix[5] *= scale;
                this.matrix[10] *= 1.0;
            }

            //
            //  DESC: Set the scale to the master matrix
            //

        }, {
            key: 'scaleFromPoint',
            value: function scaleFromPoint(point) {
                this.mergeScale(point.x, point.y, point.z);
            }
        }, {
            key: 'scaleFromSize',
            value: function scaleFromSize(size) {
                this.mergeScale(size.w, size.h, 1.0);
            }
        }, {
            key: 'scaleFromValue',
            value: function scaleFromValue(scale) {
                this.mergeScale(scale, scale, scale);
            }

            //
            //  DESC: scale and merge 
            //

        }, {
            key: 'mergeScale',
            value: function mergeScale(x, y, z) {
                var temp = new Float32Array(16);

                // init the matrix
                this.initIdentityMatrix(temp);

                // Initialize scaling matrix:
                temp[0] = x;
                temp[5] = y;
                temp[10] = z;

                // Merge the scale into the master matrix
                this.mergeMatrix(temp);
            }

            //
            //  DESC: Calulate an orthographic matrix 
            //

        }, {
            key: 'orthographicRH',
            value: function orthographicRH(w, h, zn, zf) {
                // Formula for a right handed orthographic matrix
                //  2/w  0    0           0
                //  0    2/h  0           0
                //  0    0    1/(zn-zf)   0
                //  0    0    zn/(zn-zf)  1

                this.matrix[0] = 2 / w;
                this.matrix[5] = 2 / h;
                this.matrix[10] = 1 / (zn - zf);
                this.matrix[14] = zn / (zn - zf);
            }

            //
            //  DESC: Calulate an perspective matrix 
            //

        }, {
            key: 'perspectiveFovRH',
            value: function perspectiveFovRH(fovy, aspect, zn, zf) {
                // Formula for a right handed perspective matrix
                //  yScale = cot(fovY/2)
                //  xScale = yScale / aspect ratio
                //  xScale     0          0              0
                //  0        yScale       0              0
                //  0        0        zf/(zn-zf)        -1
                //  0        0        zn*zf/(zn-zf)      0

                var yScale = 1 / Math.tan(fovy / 2);
                var xScale = yScale / aspect;

                this.matrix[0] = xScale;
                this.matrix[5] = yScale;
                this.matrix[10] = zf / (zn - zf);
                this.matrix[11] = -1;
                this.matrix[14] = zn * zf / (zn - zf);
            }

            //
            //  DESC: Inverse the X 
            //

        }, {
            key: 'invertX',
            value: function invertX() {
                this.matrix[12] = -this.matrix[12];
            }

            //
            //  DESC: Inverse the Y 
            //

        }, {
            key: 'invertY',
            value: function invertY() {
                this.matrix[13] = -this.matrix[13];
            }

            //
            //  DESC: Inverse the Z 
            //

        }, {
            key: 'invertZ',
            value: function invertZ() {
                this.matrix[14] = -this.matrix[14];
            }
        }]);

        return Matrix;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Matrix;

    /***/
},
/* 11 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return objectDataManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__managers_managerbase__ = __webpack_require__(23);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__ = __webpack_require__(6);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__managers_meshmanager__ = __webpack_require__(29);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__managers_vertexbuffermanager__ = __webpack_require__(19);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__managers_spritesheetmanager__ = __webpack_require__(39);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__ = __webpack_require__(12);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__objectdata2d__ = __webpack_require__(65);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__objectdata3d__ = __webpack_require__(69);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__utilities_genfunc__ = __webpack_require__(3);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__common_defs__ = __webpack_require__(0);

    //
    //  FILE NAME: objactdatamanager.js
    //  DESC:      Singlton that holds a map of all 2D/3D object data used for later loading
    //


    var LOAD_2D = 0;
    var LOAD_3D = 1;

    var ObjectDataManager = function (_WEBPACK_IMPORTED_MO) {
        _inherits(ObjectDataManager, _WEBPACK_IMPORTED_MO);

        function ObjectDataManager() {
            _classCallCheck(this, ObjectDataManager);

            var _this = _possibleConstructorReturn(this, (ObjectDataManager.__proto__ || Object.getPrototypeOf(ObjectDataManager)).call(this));

            _this.loadType;
            _this.objectDataMapMap = new Map();
            return _this;
        }

        //
        //  DESC: Load all XML's associated with this group
        //


        _createClass(ObjectDataManager, [{
            key: 'loadXMLGroup2D',
            value: function loadXMLGroup2D(groupAry, finishCallback) {
                this.loadType = LOAD_2D;
                _get(ObjectDataManager.prototype.__proto__ || Object.getPrototypeOf(ObjectDataManager.prototype), 'loadGroup', this).call(this, 'Object data list', this.objectDataMapMap, groupAry, finishCallback);
            }
        }, {
            key: 'loadXMLGroup3D',
            value: function loadXMLGroup3D(groupAry, finishCallback) {
                this.loadType = LOAD_3D;
                _get(ObjectDataManager.prototype.__proto__ || Object.getPrototypeOf(ObjectDataManager.prototype), 'loadGroup', this).call(this, 'Object data list', this.objectDataMapMap, groupAry, finishCallback);
            }

            //
            //  DESC: Load all object information from an xml node
            //

        }, {
            key: 'loadFromNode',
            value: function loadFromNode(group, node, filePath, finishCallback) {
                // Get the group map
                var groupMap = this.objectDataMapMap.get(group);

                var defaultData = void 0;
                if (this.loadType === LOAD_2D) defaultData = new __WEBPACK_IMPORTED_MODULE_6__objectdata2d__["a" /* ObjectData2D */]();else defaultData = new __WEBPACK_IMPORTED_MODULE_7__objectdata3d__["a" /* ObjectData3D */]();

                // Load the default data
                defaultData.loadObjData(node.getElementsByTagName('default')[0], '', '');

                // Get the node to the list of objects
                var objNode = node.getElementsByTagName('object');

                for (var i = 0; i < objNode.length; ++i) {
                    // Get the object's name
                    var _name = objNode[i].getAttribute('name');

                    // Check that this object doesn't already exist
                    if (groupMap.get(_name) === undefined) {
                        // Make a copy of the default object
                        var objData = void 0;
                        if (this.loadType === LOAD_2D) objData = new __WEBPACK_IMPORTED_MODULE_6__objectdata2d__["a" /* ObjectData2D */]();else objData = new __WEBPACK_IMPORTED_MODULE_7__objectdata3d__["a" /* ObjectData3D */]();

                        objData.copy(defaultData);

                        // Load in the object data
                        objData.loadObjData(objNode[i], group, _name);

                        // Debug output
                        //console.log(JSON.stringify(objData));

                        // Save it to the map map
                        groupMap.set(_name, objData);
                    } else {
                        throw new Error('Group object already exists (' + group + ', ' + _name + ')!');
                    }
                }

                // Debug output
                //console.log(JSON.stringify(defaultData));
            }

            //
            //  DESC: Load all the textures associated with this group
            //

        }, {
            key: 'loadTextureGroup2D',
            value: function loadTextureGroup2D(groupAry, finishCallback) {
                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Get the group map
                    var groupMap = this.objectDataMapMap.get(group);
                    if (groupMap !== undefined) {
                        var dupPathCheck = [];

                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = groupMap.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var _step2$value = _slicedToArray(_step2.value, 2),
                                    key = _step2$value[0],
                                    objData = _step2$value[1];

                                var filePath = objData.visualData.textureFilePath;

                                if (filePath && dupPathCheck.indexOf(filePath) === -1) {
                                    // Add to the array to check for duplication
                                    dupPathCheck.push(filePath);

                                    // Check if this file has already been loaded
                                    if (!__WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].has(group, filePath)) {
                                        // Load the texture file
                                        this.downloadFile('img', group, filePath, finishCallback, function (group, image, filePath, finishCallback) {
                                            __WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].set(group, filePath, image);

                                            __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__["a" /* textureManager */].load(group, filePath, image);
                                        });
                                    } else {
                                        __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__["a" /* textureManager */].load(group, filePath, __WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].get(group, filePath));
                                    }
                                }
                            }

                            // If there's nothing to load or it was loaded via assetHolder, call the complete callback
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        if (this.loadCounter === 0) finishCallback();
                    } else {
                        throw new Error('Can\'t create from data because object group does not exist (' + group + ')!');
                    }
                }
            }

            //
            //  DESC: Load all the meshes associated with this group
            //

        }, {
            key: 'loadMeshGroup2D',
            value: function loadMeshGroup2D(groupAry, finishCallback) {
                var _this2 = this;

                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Get the group map
                    var groupMap = this.objectDataMapMap.get(group);
                    if (groupMap !== undefined) {
                        var dupPathCheck = [];

                        var _iteratorNormalCompletion3 = true;
                        var _didIteratorError3 = false;
                        var _iteratorError3 = undefined;

                        try {
                            var _loop = function _loop() {
                                var _step3$value = _slicedToArray(_step3.value, 2),
                                    key = _step3$value[0],
                                    objData = _step3$value[1];

                                var filePathAry = [objData.visualData.meshFilePath, objData.visualData.spriteSheetFilePath];

                                for (var i = 0; i < filePathAry.length; ++i) {
                                    if (filePathAry[i] && dupPathCheck.indexOf(filePathAry[i]) === -1) {
                                        // Add to the array to check for duplication
                                        dupPathCheck.push(filePathAry[i]);

                                        // Check if this file has already been loaded
                                        if (!__WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].has(group, filePathAry[i])) {
                                            // Load the mesh file
                                            _this2.downloadFile('xml', group, filePathAry[i], finishCallback, function (group, xmlNode, filePath, finishCallback) {
                                                __WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].set(group, filePath, xmlNode);

                                                if (filePath === objData.visualData.spriteSheetFilePath) __WEBPACK_IMPORTED_MODULE_4__managers_spritesheetmanager__["a" /* spriteSheetManager */].loadFromNode(filePath, xmlNode);
                                            });
                                        } else {
                                            if (filePathAry[i] === objData.visualData.spriteSheetFilePath) __WEBPACK_IMPORTED_MODULE_4__managers_spritesheetmanager__["a" /* spriteSheetManager */].loadFromNode(filePathAry[i], __WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].get(group, filePathAry[i]));
                                        }
                                    }
                                }
                            };

                            for (var _iterator3 = groupMap.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                _loop();
                            }

                            // If there's nothing to load or it was loaded via assetHolder, call the complete callback
                        } catch (err) {
                            _didIteratorError3 = true;
                            _iteratorError3 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                    _iterator3.return();
                                }
                            } finally {
                                if (_didIteratorError3) {
                                    throw _iteratorError3;
                                }
                            }
                        }

                        if (this.loadCounter === 0) finishCallback();
                    } else {
                        throw new Error('Can\'t create load mesh data because object group does not exist (' + group + ')!');
                    }
                }
            }

            //
            //  DESC: Load all the meshes associated with this group
            //

        }, {
            key: 'loadMeshGroup3D',
            value: function loadMeshGroup3D(groupAry, finishCallback) {
                var _this3 = this;

                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Get the group map
                    var groupMap = this.objectDataMapMap.get(group);
                    if (groupMap !== undefined) {
                        var dupPathCheck = [];

                        var _iteratorNormalCompletion4 = true;
                        var _didIteratorError4 = false;
                        var _iteratorError4 = undefined;

                        try {
                            var _loop2 = function _loop2() {
                                var _step4$value = _slicedToArray(_step4.value, 2),
                                    key = _step4$value[0],
                                    objData = _step4$value[1];

                                var filePath = objData.visualData.meshFilePath;

                                if (filePath && dupPathCheck.indexOf(filePath) === -1) {
                                    // Add to the array to check for duplication
                                    dupPathCheck.push(filePath);

                                    // Check if this file has already been loaded
                                    if (!__WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].has(group, filePath)) {
                                        // Load the mesh file
                                        _this3.downloadFile('binary', group, filePath, finishCallback, function (group, binaryFile, filePath, finishCallback) {
                                            __WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].set(group, filePath, binaryFile);

                                            objData.visualData.meshGrp = __WEBPACK_IMPORTED_MODULE_2__managers_meshmanager__["a" /* meshManager */].load(group, filePath, binaryFile);
                                        });
                                    } else {
                                        objData.visualData.meshGrp = __WEBPACK_IMPORTED_MODULE_2__managers_meshmanager__["a" /* meshManager */].load(group, filePath, __WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].get(group, filePath));
                                    }
                                }
                            };

                            for (var _iterator4 = groupMap.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                _loop2();
                            }

                            // If there's nothing to load or it was loaded via assetHolder, call the complete callback
                        } catch (err) {
                            _didIteratorError4 = true;
                            _iteratorError4 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                    _iterator4.return();
                                }
                            } finally {
                                if (_didIteratorError4) {
                                    throw _iteratorError4;
                                }
                            }
                        }

                        if (this.loadCounter === 0) finishCallback();
                    } else {
                        throw new Error('Can\'t load mesh data because object group does not exist (' + group + ')!');
                    }
                }
            }

            //
            //  DESC: Load all the textures associated with this group
            //

        }, {
            key: 'loadTextureGroup3D',
            value: function loadTextureGroup3D(groupAry, finishCallback) {
                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Get the group map
                    var groupMap = this.objectDataMapMap.get(group);
                    if (groupMap !== undefined) {
                        var dupPathCheck = [];

                        var _iteratorNormalCompletion5 = true;
                        var _didIteratorError5 = false;
                        var _iteratorError5 = undefined;

                        try {
                            for (var _iterator5 = groupMap.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                var _step5$value = _slicedToArray(_step5.value, 2),
                                    key = _step5$value[0],
                                    _objData = _step5$value[1];

                                var _filePath = _objData.visualData.meshFilePath;

                                if (_filePath && dupPathCheck.indexOf(_filePath) === -1) {
                                    // Add to the array to check for duplication
                                    dupPathCheck.push(_filePath);

                                    for (var i = 0; i < _objData.visualData.meshGrp.uniqueTexturePathAry.length; ++i) {
                                        _filePath = _objData.visualData.meshGrp.uniqueTexturePathAry[i].path;

                                        // Check if this file has already been loaded
                                        if (!__WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].has(group, _filePath)) {
                                            // Load the texture file
                                            this.downloadFile('img', group, _filePath, finishCallback, function (group, image, filePath, finishCallback) {
                                                __WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].set(group, filePath, image);

                                                __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__["a" /* textureManager */].load(group, filePath, image);
                                            });
                                        } else {
                                            __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__["a" /* textureManager */].load(group, _filePath, __WEBPACK_IMPORTED_MODULE_5__utilities_assetholder__["a" /* assetHolder */].get(group, _filePath));
                                        }
                                    }
                                }
                            }

                            // If there's nothing to load or it was loaded via assetHolder, call the complete callback
                        } catch (err) {
                            _didIteratorError5 = true;
                            _iteratorError5 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                    _iterator5.return();
                                }
                            } finally {
                                if (_didIteratorError5) {
                                    throw _iteratorError5;
                                }
                            }
                        }

                        if (this.loadCounter === 0) finishCallback();
                    } else {
                        throw new Error('Can\'t create from data because object group does not exist (' + group + ')!');
                    }
                }
            }

            //
            //  DESC: Create OpenGL objects from data
            //

        }, {
            key: 'createFromData',
            value: function createFromData(groupAry, callback) {
                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Get the group map
                    var groupMap = this.objectDataMapMap.get(group);
                    if (groupMap !== undefined) {
                        // Create OpenGL objects from data
                        var _iteratorNormalCompletion6 = true;
                        var _didIteratorError6 = false;
                        var _iteratorError6 = undefined;

                        try {
                            for (var _iterator6 = groupMap.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                                var _step6$value = _slicedToArray(_step6.value, 2),
                                    key = _step6$value[0],
                                    _objData2 = _step6$value[1];

                                _objData2.createFromData(group);
                            }
                        } catch (err) {
                            _didIteratorError6 = true;
                            _iteratorError6 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                    _iterator6.return();
                                }
                            } finally {
                                if (_didIteratorError6) {
                                    throw _iteratorError6;
                                }
                            }
                        }
                    }
                }

                callback();
            }

            //
            //  DESC: Free all of the meshes materials and data of a specific group
            //

        }, {
            key: 'freeGroup',
            value: function freeGroup(groupAry) {
                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Make sure the group we are looking for exists
                    if (this.listTableMap.get(group) === undefined) throw new Error('Object data list group name can\'t be found (' + group + ')!');

                    // Get the group map
                    if (this.objectDataMapMap.has(group)) {
                        __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__["a" /* textureManager */].deleteGroup(group);
                        __WEBPACK_IMPORTED_MODULE_3__managers_vertexbuffermanager__["a" /* vertexBufferManager */].deleteGroup(group);
                        __WEBPACK_IMPORTED_MODULE_2__managers_meshmanager__["a" /* meshManager */].deleteGroup(group);

                        this.objectDataMapMap.delete(group);
                    }
                }
            }

            //
            //  DESC: Get a specific object data
            //

        }, {
            key: 'getData',
            value: function getData(group, name) {
                // Get the group map
                var groupMap = this.objectDataMapMap.get(group);
                if (groupMap !== undefined) {
                    var _objData3 = groupMap.get(name);
                    if (_objData3) return _objData3;else throw new Error('Object data not found (' + group + ', ' + name + ')!');
                } else throw new Error('Object group not found (' + group + ', ' + name + ')!');

                return null;
            }
        }]);

        return ObjectDataManager;
    }(__WEBPACK_IMPORTED_MODULE_0__managers_managerbase__["a" /* ManagerBase */]);

    var objectDataManager = new ObjectDataManager();

    /***/
},
/* 12 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return assetHolder;
    });

    // 
    //  FILE NAME: assetholder.js
    //  DESC:      Class for holding loaded file data
    //


    var AssetHolder = function () {
        function AssetHolder() {
            _classCallCheck(this, AssetHolder);

            this.loadMapMap = new Map();
        }

        // 
        //  DESC: Check for the data
        //


        _createClass(AssetHolder, [{
            key: 'has',
            value: function has(group, name) {
                // Get the group map
                var groupMap = this.loadMapMap.get(group);
                if (groupMap === undefined) return false;

                return groupMap.has(name);
            }

            // 
            //  DESC: Set the data
            //

        }, {
            key: 'set',
            value: function set(group, name) {
                var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

                var groupMap = this.loadMapMap.get(group);
                if (groupMap === undefined) {
                    groupMap = new Map();
                    this.loadMapMap.set(group, groupMap);
                }

                groupMap.set(name, data);
            }

            // 
            //  DESC: Get the data
            //

        }, {
            key: 'get',
            value: function get(group, name) {
                var groupMap = this.loadMapMap.get(group);
                if (groupMap === undefined) throw new Error('Group does not exist! (' + group + ').');

                var data = groupMap.get(name);
                if (data === undefined) throw new Error('Data does not exist! (' + name + ').');

                return data;
            }

            // 
            //  DESC: Delete the group
            //

        }, {
            key: 'deleteGroup',
            value: function deleteGroup(groupAry) {
                for (var i = 0; i < groupAry.length; ++i) {
                    this.loadMapMap.delete(groupAry[i]);
                }
            }

            // 
            //  DESC: Clear the group data
            //

        }, {
            key: 'clear',
            value: function clear() {
                this.loadMapMap = new Map();
            }
        }]);

        return AssetHolder;
    }();

    var assetHolder = new AssetHolder();

    /***/
},
/* 13 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__visualcomponent2d__ = __webpack_require__(73);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__physics_physicscomponent2d__ = __webpack_require__(76);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__script_scriptcomponent__ = __webpack_require__(21);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__script_scriptmanager__ = __webpack_require__(14);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__object2d__ = __webpack_require__(25);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__utilities_matrix__ = __webpack_require__(10);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME:  sprite2d.js
    //  DESC:       2D sprite class
    //


    var Sprite2D = function (_WEBPACK_IMPORTED_MO2) {
        _inherits(Sprite2D, _WEBPACK_IMPORTED_MO2);

        function Sprite2D(objData) {
            var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            _classCallCheck(this, Sprite2D);

            // The object data
            var _this4 = _possibleConstructorReturn(this, (Sprite2D.__proto__ || Object.getPrototypeOf(Sprite2D)).call(this));

            _this4.objData = objData;

            // The visual part of the 2d sprite
            _this4.visualComponent = new __WEBPACK_IMPORTED_MODULE_0__visualcomponent2d__["a" /* VisualComponent2D */](objData.visualData);

            // The visual part of the 2d sprite
            if (objData.physicsData.isActive()) _this4.physicsComponent = new __WEBPACK_IMPORTED_MODULE_1__physics_physicscomponent2d__["a" /* PhysicsComponent2D */](objData.physicsData);

            // The script part of the 2d sprite
            _this4.scriptComponent = new __WEBPACK_IMPORTED_MODULE_2__script_scriptcomponent__["a" /* ScriptComponent */]();

            // Unique Id number
            _this4.id = id;

            // AI
            _this4.ai = null;

            // Script object map. Prepare scripts by name
            _this4.scriptFactoryMap = new Map();

            // If there's no visual data, set the hide flag
            _this4.setVisible(objData.visualData.isActive());

            if (objData.visualData.genType === __WEBPACK_IMPORTED_MODULE_6__common_defs__["_23" /* EGT_SPRITE_SHEET */]) _this4.setCropOffset(objData.visualData.spriteSheet.getGlyph().cropOffset);
            return _this4;
        }

        // 
        //  DESC: Init the script factory functions and add them to the map
        //        This function loads the attribute info reguardless of what it is
        //


        _createClass(Sprite2D, [{
            key: 'initScriptFactoryFunctions',
            value: function initScriptFactoryFunctions(node) {
                // Check for scripting
                var scriptNode = node.getElementsByTagName('script');

                for (var i = 0; i < scriptNode.length; ++i) {
                    var attr = scriptNode[i].attributes[0];
                    if (attr) this.scriptFactoryMap.set(attr.name, __WEBPACK_IMPORTED_MODULE_3__script_scriptmanager__["a" /* scriptManager */].get(attr.value));
                }
            }

            // 
            //  DESC: Prepare the script factory function to run
            //

        }, {
            key: 'prepareScriptFactoryFunction',
            value: function prepareScriptFactoryFunction(scriptFactoryId) {
                var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                var scriptFactory = this.scriptFactoryMap.get(scriptFactoryId);
                if (scriptFactory) {
                    this.scriptComponent.set(scriptFactory(this));

                    if (forceUpdate) this.scriptComponent.update();
                }
            }
        }, {
            key: 'prepareScriptFactory',
            value: function prepareScriptFactory(scriptFactory) {
                var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                this.scriptComponent.set(scriptFactory(this));

                if (forceUpdate) this.scriptComponent.update();
            }

            // 
            //  DESC: Init the physics
            //

        }, {
            key: 'initPhysics',
            value: function initPhysics() {
                this.physicsComponent.init(this);
            }

            // 
            //  DESC: React to what the player is doing
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                if (this.ai) this.ai.handleEvent(event);
            }

            // 
            //  DESC: React to what the player is doing
            //

        }, {
            key: 'update',
            value: function update() {
                this.scriptComponent.update();

                if (this.ai) this.ai.update();
            }

            // 
            //  DESC: Update the physics
            //

        }, {
            key: 'physicsUpdate',
            value: function physicsUpdate() {
                this.physicsComponent.update(this);
            }

            // 
            //  DESC: do the render
            //

        }, {
            key: 'render',
            value: function render(projMatrix) {
                if (this.isVisible()) {
                    this.visualComponent.render(this.matrix, projMatrix);
                }
            }

            // 
            //  DESC: Set the AI.
            //

        }, {
            key: 'setAI',
            value: function setAI(ai) {
                this.ai = ai;

                // Handle any initialization in a seperate function
                this.ai.init();
            }

            // 
            //  DESC: Set the AI.
            //

        }, {
            key: 'setColor',
            value: function setColor(color) {
                this.visualComponent.color.copy(color);
            }
        }, {
            key: 'setRGBA',
            value: function setRGBA(r, g, b, a) {
                // This function assumes values between 0.0 to 1.0.
                this.visualComponent.color.set(r, g, b, a);
            }

            // 
            //  DESC: Set the Alpha
            //

        }, {
            key: 'setAlpha',
            value: function setAlpha(alpha) {
                var allowToExceed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                if (allowToExceed || alpha < this.objData.visualData.color.a) this.visualComponent.color.a = alpha;else this.visualComponent.color.a = this.objData.visualData.color.a;
            }

            // 
            //  DESC: Get the Alpha
            //

        }, {
            key: 'getAlpha',
            value: function getAlpha() {
                return this.visualComponent.color.a;
            }

            // 
            //  DESC: Get the default Alpha
            //

        }, {
            key: 'getDefaultAlpha',
            value: function getDefaultAlpha() {
                return this.objData.visualData.color.a;
            }

            // 
            //  DESC: Set the default color
            //

        }, {
            key: 'setDefaultColor',
            value: function setDefaultColor() {
                this.visualComponent.color.copy(this.objData.visualData.color);
            }

            // 
            //  DESC: Get the color
            //

        }, {
            key: 'getColor',
            value: function getColor() {
                return this.visualComponent.color;
            }

            // 
            //  DESC: Get the color
            //

        }, {
            key: 'getDefaultColor',
            value: function getDefaultColor() {
                return this.objData.visualData.color;
            }

            // 
            //  DESC: Set the texture ID from index
            //

        }, {
            key: 'setFrame',
            value: function setFrame(index) {
                if (this.visualComponent.frameIndex != index) {
                    this.visualComponent.setFrame(index);

                    if (this.objData.visualData.genType === __WEBPACK_IMPORTED_MODULE_6__common_defs__["_23" /* EGT_SPRITE_SHEET */]) this.setCropOffset(this.objData.visualData.spriteSheet.getGlyph(index).cropOffset);
                }
            }

            // 
            //  DESC: Set the texture ID from index
            //

        }, {
            key: 'getFrameCount',
            value: function getFrameCount() {
                if (this.objData.visualData.spriteSheet) return this.objData.visualData.spriteSheet.getCount();

                return 1;
            }
        }]);

        return Sprite2D;
    }(__WEBPACK_IMPORTED_MODULE_4__object2d__["a" /* Object2D */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Sprite2D;

    /***/
},
/* 14 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return scriptManager;
    });

    //
    //  FILE NAME: scriptmanager.js
    //  DESC:      Class for managing game scripts
    //


    var ScriptManager = function () {
        function ScriptManager() {
            _classCallCheck(this, ScriptManager);

            this.scriptMap = new Map();
        }

        //
        //  DESC: Set the script by name
        //


        _createClass(ScriptManager, [{
            key: 'set',
            value: function set(name, factory) {
                // Sanity check to make sure the script has not already been added in
                if (this.scriptMap.has(name)) {
                    throw new Error('Script name has already been added (' + name + ').');
                    return;
                }

                this.scriptMap.set(name, factory);
            }

            //
            //  DESC: Get the script by name
            //

        }, {
            key: 'get',
            value: function get(name) {
                var scriptFactory = this.scriptMap.get(name);

                if (scriptFactory === undefined) {
                    throw new Error('Script name could not be found! (' + name + ')');
                    return null;
                }

                return scriptFactory;
            }
        }]);

        return ScriptManager;
    }();

    var scriptManager = new ScriptManager();

    /***/
},
/* 15 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return shaderManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__common_shaderdata__ = __webpack_require__(61);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__utilities_genfunc__ = __webpack_require__(3);

    // 
    //  FILE NAME: shadermanager.js
    //  DESC:      shader class singleton
    //


    var ShaderManager = function () {
        function ShaderManager() {
            _classCallCheck(this, ShaderManager);

            this.shaderMap = new Map();
            this.currentShaderData = null;
            this.currentAttributeCount = 0;
            this.loadCompleteCallback = null;
            this.loadCounter = 0;
            this.initShaderCallback = null;
        }

        // 
        //  DESC: Load the shader from xml node
        //


        _createClass(ShaderManager, [{
            key: 'load',
            value: function load(xmlNode, callback) {
                if (xmlNode) {
                    var shader = xmlNode.getElementsByTagName('shader');
                    if (shader) {
                        this.loadCompleteCallback = callback;

                        for (var i = 0; i < shader.length; ++i) {
                            // Use a counter to determine when the load is done because there's
                            // no garentee they will finish in the order executed
                            // Always do this before the load
                            ++this.loadCounter;

                            this.createShader(shader[i]);
                        }
                    }
                }
            }

            // 
            //  DESC: Setup the load request to load the shader files from the server
            //

        }, {
            key: 'createShader',
            value: function createShader(node) {
                var _this5 = this;

                var shaderTxtId = node.getAttribute('Id');

                var vertexNode = node.getElementsByTagName('vertDataLst');
                var fragmentNode = node.getElementsByTagName('fragDataLst');

                // Check for duplicate
                if (this.shaderMap.has(shaderTxtId)) throw new Error('Shader of this name already exists (' + shaderTxtId + ').');

                // Add an entry to the map
                var shaderData = new __WEBPACK_IMPORTED_MODULE_0__common_shaderdata__["a" /* ShaderData */]();
                this.shaderMap.set(shaderTxtId, shaderData);

                // Create the vertex shader
                __WEBPACK_IMPORTED_MODULE_2__utilities_genfunc__["b" /* downloadFile */]('txt', vertexNode[0].getAttribute('file'), function (vertText) {
                    _this5.create(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].VERTEX_SHADER, shaderData, shaderTxtId, vertText);

                    __WEBPACK_IMPORTED_MODULE_2__utilities_genfunc__["b" /* downloadFile */]('txt', fragmentNode[0].getAttribute('file'), function (fragText) {
                        // Create the shaders from the shader files
                        _this5.create(__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].FRAGMENT_SHADER, shaderData, shaderTxtId, fragText);

                        // Combine the shaders into a program
                        _this5.createProgram(shaderData);

                        // Find the location of the custom shader variables
                        _this5.locateShaderVariables(shaderData, vertexNode[0].getElementsByTagName('dataType'), fragmentNode[0].getElementsByTagName('dataType'));

                        // Send out a signal to init this shader
                        _this5.initShaderCallback(shaderTxtId);

                        // Always do this after the load
                        --_this5.loadCounter;

                        if (_this5.loadCounter === 0) _this5.loadCompleteCallback();
                    });
                });
            }

            // 
            //  DESC: Create the shaders from the shader files
            //

        }, {
            key: 'create',
            value: function create(shaderType, shaderData, shaderTxtId, shaderTxt) {
                var id = __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].createShader(shaderType);
                if (id === 0) throw new Error('Error creating shader (' + shaderTxtId + ').');

                // Load the shader text
                __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].shaderSource(id, shaderTxt);

                // Compile the shader and check for error
                __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].compileShader(id);
                if (!__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].getShaderParameter(id, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].COMPILE_STATUS)) throw new Error('ERROR compiling shader! (' + __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].getShaderInfoLog(id) + ').');

                if (shaderType === __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].VERTEX_SHADER) shaderData.vertexId = id;else shaderData.fragmentId = id;
            }

            // 
            //  DESC: Create the programs
            //

        }, {
            key: 'createProgram',
            value: function createProgram(shaderData) {
                // Combine the shaders into a program
                shaderData.programId = __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].createProgram();
                __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].attachShader(shaderData.programId, shaderData.vertexId);
                __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].attachShader(shaderData.programId, shaderData.fragmentId);

                // Link the shader program
                __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].linkProgram(shaderData.programId);

                if (!__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].getProgramParameter(shaderData.programId, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].LINK_STATUS)) throw new Error('ERROR linking program! (' + __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].getProgramInfoLog(shaderData.programId) + ').');

                __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].validateProgram(shaderData.programId);

                if (!__WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].getProgramParameter(shaderData.programId, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].VALIDATE_STATUS)) throw new Error('ERROR validating program! (' + __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].getProgramInfoLog(shaderData.programId) + ').');
            }

            // 
            //  DESC: Locate the indexes of the shader variables
            //

        }, {
            key: 'locateShaderVariables',
            value: function locateShaderVariables(shaderData, vertNode, fragNode) {
                for (var i = 0; i < vertNode.length; ++i) {
                    var _name2 = vertNode[i].getAttribute('name');

                    if (vertNode[i].getAttribute('location')) {
                        shaderData.locationMap.set(_name2, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].getAttribLocation(shaderData.programId, _name2));
                        ++shaderData.attributeCount;
                    } else {
                        shaderData.locationMap.set(_name2, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].getUniformLocation(shaderData.programId, _name2));
                    }
                }

                for (var _i = 0; _i < fragNode.length; ++_i) {
                    var _name3 = fragNode[_i].getAttribute('name');
                    shaderData.locationMap.set(_name3, __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].getUniformLocation(shaderData.programId, _name3));
                }
            }

            // 
            //  DESC: Bind the shader program attribute variables
            //

        }, {
            key: 'bind',
            value: function bind(shaderData) {
                if (this.currentShaderData != shaderData) {
                    var gl = __WEBPACK_IMPORTED_MODULE_1__system_device__["a" /* device */].glContext;

                    if (this.currentShaderData === null) {
                        this.currentAttributeCount = shaderData.attributeCount;

                        for (var i = 0; i < this.currentAttributeCount; ++i) {
                            gl.enableVertexAttribArray(i);
                        }
                    } else if (this.currentAttributeCount != shaderData.attributeCount) {
                        if (this.currentAttributeCount < shaderData.attributeCount) {
                            for (var _i2 = this.currentAttributeCount; _i2 < shaderData.attributeCount; ++_i2) {
                                gl.enableVertexAttribArray(_i2);
                            }
                        } else {
                            for (var _i3 = shaderData.attributeCount; _i3 < this.currentAttributeCount; ++_i3) {
                                gl.disableVertexAttribArray(_i3);
                            }
                        }

                        this.currentAttributeCount = shaderData.attributeCount;
                    }

                    // save the current binding
                    this.currentShaderData = shaderData;

                    // Have OpenGL bind this shader now
                    gl.useProgram(shaderData.programId);
                }
            }

            // 
            //  DESC: Unbind the shader program attribute variables
            //

        }, {
            key: 'unbind',
            value: function unbind() {
                for (var i = 0; i < this.currentAttributeCount; ++i) {
                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].disableVertexAttribArray(i);
                }this.currentShaderData = null;
                this.currentAttributeCount = 0;
                __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].useProgram(null);
            }

            // 
            //  DESC: Get the shader data
            //

        }, {
            key: 'getShaderData',
            value: function getShaderData(shaderId) {
                var shader = this.shaderMap.get(shaderId);
                if (shader !== undefined) return shader;else throw new Error('ERROR Shader has not been created! (' + shaderId + ').');

                return null;
            }

            // 
            //  DESC: Set the shader member varaible
            //

        }, {
            key: 'setShaderValue4fv',
            value: function setShaderValue4fv(shaderId, locationId, data) {
                var shaderData = this.getShaderData(shaderId);

                if (shaderData.hasLocation(locationId)) {
                    // Get the location of the variable
                    var location = shaderData.getLocation(locationId);

                    // Bind the shader so that we can change the value of the member
                    this.bind(shaderData);

                    __WEBPACK_IMPORTED_MODULE_1__system_device__["b" /* gl */].uniform4fv(location, data);

                    // Unbind now that we are done
                    this.unbind();
                }
            }

            // 
            //  DESC: Set the shader member varaible
            //

        }, {
            key: 'setAllShaderValue4fv',
            value: function setAllShaderValue4fv(locationId, data) {
                var _iteratorNormalCompletion7 = true;
                var _didIteratorError7 = false;
                var _iteratorError7 = undefined;

                try {
                    for (var _iterator7 = this.shaderMap.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                        var _step7$value = _slicedToArray(_step7.value, 2),
                            key = _step7$value[0],
                            shaderData = _step7$value[1];

                        this.setShaderValue4fv(key, locationId, data);
                    }
                } catch (err) {
                    _didIteratorError7 = true;
                    _iteratorError7 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion7 && _iterator7.return) {
                            _iterator7.return();
                        }
                    } finally {
                        if (_didIteratorError7) {
                            throw _iteratorError7;
                        }
                    }
                }
            }
        }]);

        return ShaderManager;
    }();

    var shaderManager = new ShaderManager();

    /***/
},
/* 16 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__defs__ = __webpack_require__(0);

    // 
    //  FILE NAME:  color.js
    //  DESC:       color class
    //


    var Color = function () {
        function Color() {
            var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

            _classCallCheck(this, Color);

            this.data = new Float32Array([r, g, b, a]);
        }

        _createClass(Color, [{
            key: 'set',
            value: function set() {
                var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
                var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

                this.data[0] = r;
                this.data[1] = g;
                this.data[2] = b;
                this.data[3] = a;
            }
        }, {
            key: 'copy',
            value: function copy(obj) {
                this.data[0] = obj.data[0];
                this.data[1] = obj.data[1];
                this.data[2] = obj.data[2];
                this.data[3] = obj.data[3];
            }
        }, {
            key: 'convert',


            // 
            //  DESC: Convert from integer to decimal
            //
            value: function convert() {
                // 0.00390625f = 1 / 256;
                if (this.r > 1.5) this.r *= __WEBPACK_IMPORTED_MODULE_0__defs__["_59" /* RGB_TO_DEC */];

                if (this.g > 1.5) this.g *= __WEBPACK_IMPORTED_MODULE_0__defs__["_59" /* RGB_TO_DEC */];;

                if (this.b > 1.5) this.b *= __WEBPACK_IMPORTED_MODULE_0__defs__["_59" /* RGB_TO_DEC */];

                if (this.a > 1.5) this.a *= __WEBPACK_IMPORTED_MODULE_0__defs__["_59" /* RGB_TO_DEC */];
            }

            // 
            //  DESC: HSV transformation
            //  
            //  param: type hue - hue shift (in degrees)
            //  param: type sat - saturation multiplier (scalar)
            //  param: type val - value multiplier (scalar)
            //

        }, {
            key: 'transformHSV',
            value: function transformHSV(hue, sat, val) {
                var VSU = val * sat * Math.cos(hue * __WEBPACK_IMPORTED_MODULE_0__defs__["g" /* DEG_TO_RAD */]);
                var VSW = val * sat * Math.sin(hue * __WEBPACK_IMPORTED_MODULE_0__defs__["g" /* DEG_TO_RAD */]);

                var _r = this.data[0],
                    _g = this.data[1],
                    _b = this.data[2];

                this.data[0] = (.299 * val + .701 * VSU + .168 * VSW) * _r + (.587 * val - .587 * VSU + .330 * VSW) * _g + (.114 * val - .114 * VSU - .497 * VSW) * _b;
                this.data[1] = (.299 * val - .299 * VSU - .328 * VSW) * _r + (.587 * val + .413 * VSU + .035 * VSW) * _g + (.114 * val - .114 * VSU + .292 * VSW) * _b;
                this.data[2] = (.299 * val - .3 * VSU + 1.25 * VSW) * _r + (.587 * val - .588 * VSU - 1.05 * VSW) * _g + (.114 * val + .886 * VSU - .203 * VSW) * _b;
            }
        }, {
            key: 'r',
            set: function set(value) {
                if (value > 1.5) value *= __WEBPACK_IMPORTED_MODULE_0__defs__["_59" /* RGB_TO_DEC */];

                this.data[0] = value;
            },
            get: function get() {
                return this.data[0];
            }
        }, {
            key: 'g',
            set: function set(value) {
                if (value > 1.5) value *= __WEBPACK_IMPORTED_MODULE_0__defs__["_59" /* RGB_TO_DEC */];

                this.data[1] = value;
            },
            get: function get() {
                return this.data[1];
            }
        }, {
            key: 'b',
            set: function set(value) {
                if (value > 1.5) value *= __WEBPACK_IMPORTED_MODULE_0__defs__["_59" /* RGB_TO_DEC */];

                this.data[2] = value;
            },
            get: function get() {
                return this.data[2];
            }
        }, {
            key: 'a',
            set: function set(value) {
                if (value > 1.5) value *= __WEBPACK_IMPORTED_MODULE_0__defs__["_59" /* RGB_TO_DEC */];

                this.data[3] = value;
            },
            get: function get() {
                return this.data[3];
            }
        }]);

        return Color;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Color;

    /***/
},
/* 17 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__controlbase__ = __webpack_require__(79);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__scrollparam__ = __webpack_require__(42);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__2d_sprite2d__ = __webpack_require__(13);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__common_point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__common_quad__ = __webpack_require__(80);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__common_rect__ = __webpack_require__(20);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__utilities_matrix__ = __webpack_require__(10);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__utilities_settings__ = __webpack_require__(9);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__objectdatamanager_objectdatamanager__ = __webpack_require__(11);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_11__managers_actionmanager__ = __webpack_require__(33);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_12__script_scriptcomponent__ = __webpack_require__(21);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_13__script_scriptmanager__ = __webpack_require__(14);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_14__utilities_xmlparsehelper__ = __webpack_require__(4);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_15__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uicontrol.js
    //  DESC:      class for user interface controls
    //


    var UIControl = function (_WEBPACK_IMPORTED_MO3) {
        _inherits(UIControl, _WEBPACK_IMPORTED_MO3);

        function UIControl(group) {
            _classCallCheck(this, UIControl);

            // sprite array
            var _this6 = _possibleConstructorReturn(this, (UIControl.__proto__ || Object.getPrototypeOf(UIControl)).call(this, group));

            _this6.spriteAry = [];

            // Script component object
            _this6.scriptComponent = new __WEBPACK_IMPORTED_MODULE_12__script_scriptcomponent__["a" /* ScriptComponent */]();

            // control's default state
            _this6.defaultState;

            // control's current state
            _this6.state = __WEBPACK_IMPORTED_MODULE_15__common_defs__["E" /* ECS_NULL */];
            _this6.lastState = __WEBPACK_IMPORTED_MODULE_15__common_defs__["E" /* ECS_NULL */];

            // Name of the action to perform under the correct circumstances
            _this6.executionAction;

            // How the control should respond when selected
            _this6.actionType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["w" /* ECAT_NULL */];

            // This control's size
            _this6.size = new __WEBPACK_IMPORTED_MODULE_3__common_size__["a" /* Size */]();

            // This is the size modifier
            // when calculating the collision rect
            _this6.sizeModifier = new __WEBPACK_IMPORTED_MODULE_6__common_rect__["a" /* Rect */]();

            // Collision rect
            _this6.collisionQuad = new __WEBPACK_IMPORTED_MODULE_5__common_quad__["a" /* Quad */]();

            // Collision center
            _this6.collisionCenter = new __WEBPACK_IMPORTED_MODULE_4__common_point__["a" /* Point */]();

            // Smart Gui object
            _this6.smartGui = null;

            // Mouse selection type
            _this6.mouseSelectType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["m" /* EAP_UP */];

            // On state script factory map
            _this6.scriptFactoryMap = new Map();

            // Scrolling parameters
            _this6.scrollParam = null;

            // Execution callbacks
            _this6.executionActionCallback = null;
            return _this6;
        }

        // 
        //  DESC: Load the control info from XML node
        //


        _createClass(UIControl, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                _get(UIControl.prototype.__proto__ || Object.getPrototypeOf(UIControl.prototype), 'loadFromNode', this).call(this, node);

                // Set the default state of the control
                var attr = node.getAttribute('defaultState');
                if (attr) this.setDefaultState(attr);

                // Set if mouse selection is the down message
                attr = node.getAttribute('mouseSelectDown');
                if (attr && attr === 'true') this.mouseSelectType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["k" /* EAP_DOWN */];

                // Setup the action
                var actionNode = node.getElementsByTagName('action');
                if (actionNode.length) {
                    // Set the action type
                    attr = actionNode[0].getAttribute('actionType');
                    if (attr) this.setActionType(attr);

                    // Set the execution action
                    attr = actionNode[0].getAttribute('executionAction');
                    if (attr) this.executionAction = attr;
                }

                // Setup the action
                var stateScriptNode = node.getElementsByTagName('stateScript');
                if (stateScriptNode.length) {
                    var _attr = stateScriptNode[0].getAttribute("onDisabled");
                    if (_attr) this.scriptFactoryMap.set(__WEBPACK_IMPORTED_MODULE_15__common_defs__["B" /* ECS_DISABLED */], __WEBPACK_IMPORTED_MODULE_13__script_scriptmanager__["a" /* scriptManager */].get(_attr));

                    _attr = stateScriptNode[0].getAttribute("onInactive");
                    if (_attr) this.scriptFactoryMap.set(__WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */], __WEBPACK_IMPORTED_MODULE_13__script_scriptmanager__["a" /* scriptManager */].get(_attr));

                    _attr = stateScriptNode[0].getAttribute("onActive");
                    if (_attr) this.scriptFactoryMap.set(__WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */], __WEBPACK_IMPORTED_MODULE_13__script_scriptmanager__["a" /* scriptManager */].get(_attr));

                    _attr = stateScriptNode[0].getAttribute("onSelect");
                    if (_attr) this.scriptFactoryMap.set(__WEBPACK_IMPORTED_MODULE_15__common_defs__["F" /* ECS_SELECTED */], __WEBPACK_IMPORTED_MODULE_13__script_scriptmanager__["a" /* scriptManager */].get(_attr));
                }

                // Load the scroll data from node
                var scrollParamNode = node.getElementsByTagName('scroll');
                if (scrollParamNode.length) {
                    this.scrollParam = new __WEBPACK_IMPORTED_MODULE_1__scrollparam__["a" /* ScrollParam */]();
                    this.scrollParam.loadFromNode(scrollParamNode);
                }

                // Get the size modifier info
                this.sizeModifier = __WEBPACK_IMPORTED_MODULE_14__utilities_xmlparsehelper__["f" /* loadRect */](node);

                // Init to the default state
                this.revertToDefaultState();
            }

            // 
            //  DESC: Load the control specific info from XML node
            //

        }, {
            key: 'loadControlFromNode',
            value: function loadControlFromNode(node) {
                // Get the list of object data associated with this button
                var spriteNode = node.getElementsByTagName('sprite');
                if (spriteNode.length) {
                    // This is to get around the fact that objects are passed by "copy of reference".
                    // This simulates passing an int by reference.
                    var fontSpriteCount = [0];

                    // Load the sprite from node
                    for (var i = 0; i < spriteNode.length; ++i) {
                        this.loadSpriteFromNode(spriteNode[i], fontSpriteCount);
                    }
                }
            }

            // 
            //  DESC: Load a sprite from an XML node
            //

        }, {
            key: 'loadSpriteFromNode',
            value: function loadSpriteFromNode(node, fontSpriteCount) {
                // Get the type of object
                var objectName = node.getAttribute('objectName');

                // allocate the sprite in the array
                var sprite = new __WEBPACK_IMPORTED_MODULE_2__2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_9__objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData(this.group, objectName));
                this.spriteAry.push(sprite);

                // Load the transform data
                sprite.loadTransFromNode(node);

                // Init the script factory functions
                sprite.initScriptFactoryFunctions(node);

                // See if this sprite is used for rendering a font string
                var fontNode = node.getElementsByTagName('font');
                if (fontNode.length) {
                    // Load the font properties from XML node
                    sprite.visualComponent.loadFontPropFromNode(fontNode[0]);

                    // Set the font string to be created later
                    if (this.stringAry.length && fontSpriteCount[0] < this.stringAry.length) sprite.visualComponent.setFontString(this.stringAry[fontSpriteCount[0]]);

                    // set the color if it is different
                    sprite.visualComponent.color = __WEBPACK_IMPORTED_MODULE_14__utilities_xmlparsehelper__["b" /* loadColor */](fontNode[0], sprite.visualComponent.color);

                    ++fontSpriteCount[0];
                } else {
                    // Find the largest size width and height of the different sprites for the controls size
                    var width = sprite.objData.size.w + Math.abs(sprite.position.x);
                    var height = sprite.objData.size.h + Math.abs(sprite.position.y);

                    if (width > this.size.w) this.size.w = width;

                    if (height > this.size.h) this.size.h = height;
                }
            }

            // 
            //  DESC: Load a sprite from an array
            //  NOTE: Used to init the progress bar manually
            //

        }, {
            key: 'loadSpriteFromArray',
            value: function loadSpriteFromArray(objectNameAry) {
                for (var i = 0; i < objectNameAry.length; ++i) {
                    // allocate the sprite in the array
                    this.spriteAry.push(new __WEBPACK_IMPORTED_MODULE_2__2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_9__objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData(this.group, objectNameAry[i])));
                }
            }

            // 
            //  DESC: Update the control
            //

        }, {
            key: 'update',
            value: function update() {
                this.scriptComponent.update();

                for (var i = 0; i < this.spriteAry.length; ++i) {
                    this.spriteAry[i].update();
                }
            }

            // 
            //  DESC: Transform the control
            //

        }, {
            key: 'doTransform',
            value: function doTransform(object) {
                this.transform(object.matrix, object.wasWorldPosTranformed());

                for (var i = 0; i < this.spriteAry.length; ++i) {
                    this.spriteAry[i].transform(this.matrix, this.wasWorldPosTranformed());
                }this.transformCollision();
            }

            // 
            //  DESC: Simple transform that does not include a parent or collision
            //

        }, {
            key: 'simpleTransform',
            value: function simpleTransform() {
                this.transform();

                for (var i = 0; i < this.spriteAry.length; ++i) {
                    this.spriteAry[i].transform(this.matrix, this.wasWorldPosTranformed());
                }
            }

            // 
            //  DESC: Transform the collision
            //

        }, {
            key: 'transformCollision',
            value: function transformCollision() {
                if (this.wasWorldPosTranformed() && !this.size.isEmpty()) {
                    var finalMatrix = new __WEBPACK_IMPORTED_MODULE_7__utilities_matrix__["a" /* Matrix */](this.matrix);
                    finalMatrix.scaleFromValue(__WEBPACK_IMPORTED_MODULE_8__utilities_settings__["a" /* settings */].orthoAspectRatio.h);
                    finalMatrix.invertY();

                    // Get half the screen size to convert to screen coordinates
                    var screenHalf = __WEBPACK_IMPORTED_MODULE_8__utilities_settings__["a" /* settings */].size_half;

                    // Create the rect of the control based on half it's size
                    var halfwidth = this.size.w * 0.5;
                    var halfHeight = this.size.h * 0.5;

                    var quad = new __WEBPACK_IMPORTED_MODULE_5__common_quad__["a" /* Quad */]();
                    quad.point[0].x = -halfwidth + -this.sizeModifier.x1;
                    quad.point[0].y = -halfHeight + -this.sizeModifier.y1;
                    quad.point[1].x = halfwidth + this.sizeModifier.x2;
                    quad.point[1].y = -halfHeight + -this.sizeModifier.y1;
                    quad.point[2].x = halfwidth + this.sizeModifier.x2;
                    quad.point[2].y = halfHeight + this.sizeModifier.y2;
                    quad.point[3].x = -halfwidth + -this.sizeModifier.x1;
                    quad.point[3].y = halfHeight + this.sizeModifier.y2;

                    finalMatrix.transformQuad(this.collisionQuad, quad);

                    // Convert the translated rect to screen coordinates
                    this.collisionQuad.point[0].x += screenHalf.w;
                    this.collisionQuad.point[0].y += screenHalf.h;
                    this.collisionQuad.point[1].x += screenHalf.w;
                    this.collisionQuad.point[1].y += screenHalf.h;
                    this.collisionQuad.point[2].x += screenHalf.w;
                    this.collisionQuad.point[2].y += screenHalf.h;
                    this.collisionQuad.point[3].x += screenHalf.w;
                    this.collisionQuad.point[3].y += screenHalf.h;

                    finalMatrix.transformPoint(this.collisionCenter, new __WEBPACK_IMPORTED_MODULE_4__common_point__["a" /* Point */]());

                    // Convert to screen coordinates
                    this.collisionCenter.x += screenHalf.w;
                    this.collisionCenter.y += screenHalf.h;
                }
            }

            // 
            //  DESC: do the render
            //

        }, {
            key: 'render',
            value: function render(matrix) {
                for (var i = 0; i < this.spriteAry.length; ++i) {
                    this.spriteAry[i].render(matrix);
                }
            }

            // 
            //  DESC: Handle events
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                if (event.detail.type === __WEBPACK_IMPORTED_MODULE_15__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */]) {
                    this.onStateChange(event);
                } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_15__common_defs__["_8" /* EGE_MENU_SELECT_EXECUTE */]) {
                    this.onSelectExecute(event);
                } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_15__common_defs__["_9" /* EGE_MENU_SET_ACTIVE_CONTROL */]) {
                    this.onSetActiveControl(event);
                } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_15__common_defs__["_1" /* EGE_MENU_REACTIVATE */]) {
                    this.onReactivate(event);
                } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_15__common_defs__["_15" /* EGE_MENU_TRANS_IN */]) {
                    this.onTransIn(event);
                } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_15__common_defs__["_16" /* EGE_MENU_TRANS_OUT */]) {
                    this.onTransOut(event);
                }

                // Do any smart event handling
                this.smartHandleEvent(event);
            }

            // 
            //  DESC: Handle OnTransIn message
            //

        }, {
            key: 'onTransIn',
            value: function onTransIn(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_15__common_defs__["_50" /* ETC_BEGIN */]) {
                    // Set the script functions for the current displayed state
                    if (this.lastState != this.state) this.setDisplayState();
                }
            }

            // 
            //  DESC: Handle OnTransOut message
            //

        }, {
            key: 'onTransOut',
            value: function onTransOut(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_15__common_defs__["_50" /* ETC_BEGIN */]) {
                    // Reset the control
                    this.reset();

                    // Reset the sprite scripts
                    this.resetSpriteScript();

                    // Set the script functions for the current displayed state
                    if (this.lastState != this.state) this.setDisplayState();
                }
            }

            // 
            //  DESC: Handle OnStateChange message
            //

        }, {
            key: 'onStateChange',
            value: function onStateChange(event) {
                // This control is the focus of the state change
                // The control's "this" pointer is used as a means of identification
                if (event.detail.arg[1] === this) this.changeState(event.detail.arg[0]);else this.deactivateControl();
            }

            // 
            //  DESC: Handle OnSelectExecute message
            //

        }, {
            key: 'onSelectExecute',
            value: function onSelectExecute(event) {
                if (this.state === __WEBPACK_IMPORTED_MODULE_15__common_defs__["F" /* ECS_SELECTED */]) {
                    if (this.actionType === __WEBPACK_IMPORTED_MODULE_15__common_defs__["z" /* ECAT_TO_TREE */]) __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_15__common_defs__["_14" /* EGE_MENU_TO_TREE */], this.executionAction);else if (this.actionType === __WEBPACK_IMPORTED_MODULE_15__common_defs__["y" /* ECAT_TO_MENU */]) __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_15__common_defs__["_13" /* EGE_MENU_TO_MENU */], this.executionAction, this);else if (this.actionType === __WEBPACK_IMPORTED_MODULE_15__common_defs__["s" /* ECAT_BACK */]) __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_15__common_defs__["V" /* EGE_MENU_BACK_ACTION */]);else if (this.actionType === __WEBPACK_IMPORTED_MODULE_15__common_defs__["u" /* ECAT_CLOSE */]) __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_15__common_defs__["_12" /* EGE_MENU_TOGGLE_ACTION */]);else if (this.actionType === __WEBPACK_IMPORTED_MODULE_15__common_defs__["v" /* ECAT_GAME_STATE_CHANGE */]) __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_15__common_defs__["Z" /* EGE_MENU_GAME_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_15__common_defs__["_50" /* ETC_BEGIN */], this.executionAction);

                    //else if( this.actionType === defs.ECAT_QUIT_GAME )
                    //eventManager.dispatchEvent( SDL_QUIT );

                    // Smart gui execution
                    this.smartExecuteAction();

                    // Boost signal execute action
                    if (this.executionActionCallback !== null) for (var i = 0; i < this.executionActionCallback.length; ++i) {
                        this.executionActionCallback[i](this);
                    }
                }
            }

            // 
            //  DESC: Handle OnSetActiveControl message
            //

        }, {
            key: 'onSetActiveControl',
            value: function onSetActiveControl(event) {
                // Set the last active control to be active again
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_15__common_defs__["j" /* EAC_LAST_ACTIVE_CONTROL */] && this.lastState > __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */]) {
                    this.lastState = this.state = __WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */];

                    // Don't animate the control if the mouse was used
                    if (!__WEBPACK_IMPORTED_MODULE_11__managers_actionmanager__["a" /* actionManager */].wasLastDeviceMouse()) {
                        this.resetSpriteScript();
                        this.setDisplayState();
                    }
                }
            }

            // 
            //  DESC: Handle OnReactivate message
            //

        }, {
            key: 'onReactivate',
            value: function onReactivate(event) {
                // Set the last active control to be active again
                if (this.state > __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */]) {
                    this.lastState = this.state = __WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */];

                    // Don't animate the control if the mouse was used
                    if (!__WEBPACK_IMPORTED_MODULE_11__managers_actionmanager__["a" /* actionManager */].wasLastDeviceMouse() || this.isPointInControl(__WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].mouseX, __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].mouseY)) {
                        this.resetSpriteScript();
                        this.setDisplayState();
                    }
                }
            }

            // 
            //  DESC: Handle the mouse move
            //

        }, {
            key: 'onMouseMove',
            value: function onMouseMove(event) {
                var result = false;

                if (!this.isDisabled() && this.isPointInControl(event.clientX + __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].mouseOffsetX, event.clientY + __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].mouseOffsetY)) {
                    result = true;

                    // Only send the message if it's not already active
                    if (!this.isActive()) {
                        __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_15__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */], this);
                    }
                }

                return result;
            }

            // 
            //  DESC: Change the control state
            //

        }, {
            key: 'changeState',
            value: function changeState(state) {
                if (this.state !== state) {
                    this.state = state;

                    // Prepare any script functions associated with the state change
                    this.prepareControlScriptFactory(this.state);

                    this.resetSpriteScript();
                    this.setDisplayState();

                    this.lastState = this.state;
                }
            }

            // 
            //  DESC: Activate the control
            //

        }, {
            key: 'activateControl',
            value: function activateControl() {
                // The focus has switched to this control
                if (!this.isDisabled()) {
                    this.lastState = this.state = __WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */];

                    this.resetSpriteScript();
                    this.setDisplayState();

                    return true;
                }

                return false;
            }

            // 
            //  DESC: Deactivate the control
            //

        }, {
            key: 'deactivateControl',
            value: function deactivateControl() {
                // The focus has switched away from this control
                if (this.lastState === __WEBPACK_IMPORTED_MODULE_15__common_defs__["E" /* ECS_NULL */] || this.lastState > __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */]) {
                    // Reset the control
                    this.reset();

                    this.resetSpriteScript();
                    this.setDisplayState();

                    this.lastState = this.state;
                }
            }

            // 
            //  DESC: Disable the control
            //

        }, {
            key: 'disableControl',
            value: function disableControl() {
                if (this.lastState === __WEBPACK_IMPORTED_MODULE_15__common_defs__["E" /* ECS_NULL */] || this.lastState > __WEBPACK_IMPORTED_MODULE_15__common_defs__["B" /* ECS_DISABLED */]) {
                    this.lastState = this.state = __WEBPACK_IMPORTED_MODULE_15__common_defs__["B" /* ECS_DISABLED */];

                    this.resetSpriteScript();
                    this.setDisplayState();
                }
            }

            // 
            //  DESC: Enable the control to the inactive state
            //

        }, {
            key: 'enableControl',
            value: function enableControl() {
                if (this.lastState <= __WEBPACK_IMPORTED_MODULE_15__common_defs__["B" /* ECS_DISABLED */]) {
                    this.lastState = this.state = __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */];

                    this.resetSpriteScript();
                    this.setDisplayState();
                }
            }

            // 
            //  DESC: Set the sprite's display based on it's current state
            //

        }, {
            key: 'setDisplayState',
            value: function setDisplayState() {
                // Set the script function
                this.prepareSpriteScriptFactoryFunction(this.state);
            }

            // 
            //  DESC: Set the sprite's display based on it's current state
            //

        }, {
            key: 'init',
            value: function init() {
                // Create any font strings
                // This allows for delayed VBO create so that the fonts can be allocated during a load screen
                for (var i = 0; i < this.spriteAry.length; ++i) {
                    if (this.spriteAry[i].visualComponent.isFontSprite()) this.spriteAry[i].visualComponent.createFontStringFromData();
                }

                // Call any init scripts
                this.prepareSpriteScriptFactoryFunction(__WEBPACK_IMPORTED_MODULE_15__common_defs__["D" /* ECS_INIT */]);
            }

            // 
            //  DESC: Do some cleanup
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                // Free the font VBO
                // This allows for early VBO delete so that the menu manager can be freed from a thread
                for (var i = 0; i < this.spriteAry.length; ++i) {
                    if (this.spriteAry[i].visualComponent.isFontSprite()) this.spriteAry[i].visualComponent.deleteFontVBO();
                }
            }

            // 
            //  DESC: Prepare the sprite script factory function
            //

        }, {
            key: 'prepareSpriteScriptFactoryFunction',
            value: function prepareSpriteScriptFactoryFunction(controlState) {
                var scriptFactoryMapKey = void 0;
                var forceUpdate = false;

                switch (controlState) {
                    case __WEBPACK_IMPORTED_MODULE_15__common_defs__["D" /* ECS_INIT */]:
                        scriptFactoryMapKey = "init";
                        forceUpdate = true;
                        break;

                    case __WEBPACK_IMPORTED_MODULE_15__common_defs__["B" /* ECS_DISABLED */]:
                        scriptFactoryMapKey = "disabled";
                        forceUpdate = true;
                        break;

                    case __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */]:
                        scriptFactoryMapKey = "inactive";
                        forceUpdate = true;
                        break;

                    case __WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */]:
                        scriptFactoryMapKey = "active";
                        break;

                    case __WEBPACK_IMPORTED_MODULE_15__common_defs__["F" /* ECS_SELECTED */]:
                        scriptFactoryMapKey = "selected";
                        break;
                };

                this.prepareSpriteScriptFactory(scriptFactoryMapKey, forceUpdate);
            }

            // 
            //  DESC: Call a script function map key for sprite
            //

        }, {
            key: 'prepareSpriteScriptFactory',
            value: function prepareSpriteScriptFactory(scriptFactoryMapKey, forceUpdate) {
                for (var i = 0; i < this.spriteAry.length; ++i) {
                    this.spriteAry[i].prepareScriptFactoryFunction(scriptFactoryMapKey, forceUpdate);
                }
            }

            // 
            //  DESC: Prepare the script function to run
            //

        }, {
            key: 'prepareControlScriptFactory',
            value: function prepareControlScriptFactory(controlState) {
                var scriptFactory = this.scriptFactoryMap.get(controlState);
                if (scriptFactory) this.scriptComponent.set(scriptFactory(this));
            }

            // 
            //  DESC: Reset and recycle the contexts
            //

        }, {
            key: 'reset',
            value: function reset() {
                var complete = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                if (this.state > __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */]) this.state = __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */];

                if (complete) this.lastState = this.state;
            }

            // 
            //  DESC: Reset the sprite script
            //

        }, {
            key: 'resetSpriteScript',
            value: function resetSpriteScript() {
                for (var i = 0; i < this.spriteAry.length; ++i) {
                    this.spriteAry[i].scriptComponent.reset();
                }
            }

            // 
            //  DESC: Set the default state of this control
            //

        }, {
            key: 'setDefaultState',
            value: function setDefaultState(value) {
                if (value === 'inactive') this.defaultState = __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */];else if (value === 'active') this.defaultState = __WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */];else if (value === 'disabled') this.defaultState = __WEBPACK_IMPORTED_MODULE_15__common_defs__["B" /* ECS_DISABLED */];else if (value === 'selected') this.defaultState = __WEBPACK_IMPORTED_MODULE_15__common_defs__["F" /* ECS_SELECTED */];
            }

            // 
            //  DESC: Do any smart create
            //

        }, {
            key: 'smartCreate',
            value: function smartCreate() {
                if (this.smartGui) this.smartGui.create();
            }

            // 
            //  DESC: Do any smart event handling
            //

        }, {
            key: 'smartHandleEvent',
            value: function smartHandleEvent(event) {
                if (this.smartGui) this.smartGui.handleEvent(event);
            }

            // 
            //  DESC: Smart execute the action
            //

        }, {
            key: 'smartExecuteAction',
            value: function smartExecuteAction() {
                if (this.smartGui) this.smartGui.execute();
            }

            // 
            //  DESC: Set the control to their default behavior
            //

        }, {
            key: 'revertToDefaultState',
            value: function revertToDefaultState() {
                this.state = this.defaultState;
            }

            // 
            //  DESC: Set the state of this control
            //

        }, {
            key: 'setState',
            value: function setState(state, setLastState) {
                this.state = state;

                if (setLastState) this.lastState = state;
            }

            // 
            //  DESC: Set the control's action type
            //

        }, {
            key: 'setActionType',
            value: function setActionType(value) {
                if (value === 'action') this.actionType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["r" /* ECAT_ACTION */];else if (value === 'to_tree') this.actionType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["z" /* ECAT_TO_TREE */];else if (value === 'to_menu') this.actionType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["y" /* ECAT_TO_MENU */];else if (value === 'back') this.actionType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["s" /* ECAT_BACK */];else if (value === 'close') this.actionType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["u" /* ECAT_CLOSE */];else if (value === 'change_focus') this.actionType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["t" /* ECAT_CHANGE_FOCUS */];else if (value === 'game_state_change') this.actionType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["v" /* ECAT_GAME_STATE_CHANGE */];else if (value === 'quit_game') this.actionType = __WEBPACK_IMPORTED_MODULE_15__common_defs__["x" /* ECAT_QUIT_GAME */];
            }

            // 
            //  DESC: Create the font string
            //

        }, {
            key: 'createFontStr',
            value: function createFontStr(fontString) {
                var spriteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                var fontSpriteCounter = 0;

                for (var i = 0; i < this.spriteAry.length; ++i) {
                    if (this.spriteAry[i].visualComponent.isFontSprite()) {
                        if (fontSpriteCounter === spriteIndex) {
                            this.spriteAry[i].visualComponent.createFontString(fontString);
                            break;
                        }

                        ++fontSpriteCounter;
                    }
                }
            }
        }, {
            key: 'createFontString',
            value: function createFontString() {
                var stringIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var spriteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                if (this.stringAry.length) this.createFontStr(this.stringAry[stringIndex], spriteIndex);
            }

            // 
            //  DESC: Set the font string
            //

        }, {
            key: 'setFontString',
            value: function setFontString(fontString) {
                var spriteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                var fontSpriteCounter = 0;

                for (var i = 0; i < this.spriteAry.length; ++i) {
                    if (this.spriteAry[i].visualComponent.isFontSprite()) {
                        if (fontSpriteCounter === spriteIndex) {
                            this.spriteAry[i].visualComponent.setFontString(fontString);
                            break;
                        }

                        ++fontSpriteCounter;
                    }
                }
            }

            // 
            //  DESC: Handle the select action
            //  NOTE: Only process this message if it's keyboard/gamepad down or mouse up
            //

        }, {
            key: 'handleSelectAction',
            value: function handleSelectAction(event) {
                if (this.isSelectable() && event.detail.arg[__WEBPACK_IMPORTED_MODULE_15__common_defs__["_46" /* ESMA_DEVICE_TYPE */]] === __WEBPACK_IMPORTED_MODULE_15__common_defs__["_57" /* MOUSE */] && event.detail.arg[__WEBPACK_IMPORTED_MODULE_15__common_defs__["_49" /* ESMA_PRESS_TYPE */]] === this.mouseSelectType && this.isPointInControl(event.detail.arg[__WEBPACK_IMPORTED_MODULE_15__common_defs__["_47" /* ESMA_MOUSE_X */]], event.detail.arg[__WEBPACK_IMPORTED_MODULE_15__common_defs__["_48" /* ESMA_MOUSE_Y */]]) || this.isActive() && event.detail.arg[__WEBPACK_IMPORTED_MODULE_15__common_defs__["_46" /* ESMA_DEVICE_TYPE */]] !== __WEBPACK_IMPORTED_MODULE_15__common_defs__["_57" /* MOUSE */] && event.detail.arg[__WEBPACK_IMPORTED_MODULE_15__common_defs__["_49" /* ESMA_PRESS_TYPE */]] === __WEBPACK_IMPORTED_MODULE_15__common_defs__["k" /* EAP_DOWN */]) {
                    __WEBPACK_IMPORTED_MODULE_10__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_15__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_15__common_defs__["F" /* ECS_SELECTED */], this);

                    return true;
                }

                return false;
            }

            // 
            //  DESC: Set the first inactive control to be active
            //  NOTE: This is mainly here to be virtual for sub controls
            //

        }, {
            key: 'activateFirstInactiveControl',
            value: function activateFirstInactiveControl() {
                // If a mouse was used, set the control as active but don't animate it.
                // This allows us to use the keys to scroll when pressed
                if (__WEBPACK_IMPORTED_MODULE_11__managers_actionmanager__["a" /* actionManager */].wasLastDeviceMouse()) {
                    if (!this.isDisabled()) {
                        this.lastState = this.state = __WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */];

                        return true;
                    }

                    return false;
                }

                return this.activateControl();
            }

            // 
            //  DESC: Is the point in the control
            //

        }, {
            key: 'isPointInControl',
            value: function isPointInControl(x, y) {
                return this.collisionQuad.isPointInQuad(x, y);
            }

            // 
            //  DESC: Get the pointer to the control if found
            //  NOTE: These function is mainly for sub controls
            //

        }, {
            key: 'findControlByName',
            value: function findControlByName(name) {
                if (this.name === name) return this;

                return null;
            }
        }, {
            key: 'findControlByRef',
            value: function findControlByRef(ctrl) {
                if (ctrl === this) return this;

                return null;
            }

            // 
            //  DESC: Set the string to vector
            //

        }, {
            key: 'setStringToList',
            value: function setStringToList(str) {
                this.stringAry.push(str);
            }

            // 
            //  DESC: Is this control disabled/active/selected
            //

        }, {
            key: 'isDisabled',
            value: function isDisabled() {
                return this.state === __WEBPACK_IMPORTED_MODULE_15__common_defs__["B" /* ECS_DISABLED */];
            }
        }, {
            key: 'isInactive',
            value: function isInactive() {
                return this.state === __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */];
            }
        }, {
            key: 'isActive',
            value: function isActive() {
                return this.state === __WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */];
            }
        }, {
            key: 'isSelected',
            value: function isSelected() {
                return this.state === __WEBPACK_IMPORTED_MODULE_15__common_defs__["F" /* ECS_SELECTED */];
            }
        }, {
            key: 'isSelectable',
            value: function isSelectable() {
                return this.state === __WEBPACK_IMPORTED_MODULE_15__common_defs__["C" /* ECS_INACTIVE */] || this.state === __WEBPACK_IMPORTED_MODULE_15__common_defs__["A" /* ECS_ACTIVE */];
            }

            // 
            //  DESC: Check if control is a sub control
            //

        }, {
            key: 'isSubControl',
            value: function isSubControl() {
                return false;
            }

            // 
            //  DESC: Connect to the execution action signal
            //

        }, {
            key: 'connect_ExecutionAction',
            value: function connect_ExecutionAction(callback) {
                if (this.executionActionCallback === null) this.executionActionCallback = [];

                this.executionActionCallback.push(callback);
            }

            // 
            //  DESC: Get the pointer to the active control
            //  NOTE: This is mostly needed for sub controls
            //

        }, {
            key: 'getActiveControl',
            value: function getActiveControl() {
                return this;
            }

            // 
            //  DESC: Set the alpha value of this control
            //

        }, {
            key: 'setAlpha',
            value: function setAlpha(alpha) {
                for (var i = 0; i < this.spriteAry.length; ++i) {
                    this.spriteAry[i].setAlpha(alpha);
                }
            }

            // 
            //  DESC: Check if this control can scroll
            //

        }, {
            key: 'canScroll',
            value: function canScroll(msg) {
                if (this.isActive() && this.scrollParam && this.scrollParam.canScroll(msg)) return true;

                return false;
            }
        }]);

        return UIControl;
    }(__WEBPACK_IMPORTED_MODULE_0__controlbase__["a" /* ControlBase */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UIControl;

    /***/
},
/* 18 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return signalManager;
    });

    // 
    //  FILE NAME: signalmanager.js
    //  DESC:      Class for handling messaging
    //


    var SignalManager = function () {
        function SignalManager() {
            _classCallCheck(this, SignalManager);

            this.smartGuiControlSignal = [];
            this.smartMenuSignal = [];
            this.aiCreateSignal = [];
            this.loadCompleteSignal = [];
            this.resolutionChangeSignal = [];
        }

        // 
        //  DESC: Connect to the smart gui control signal
        //


        _createClass(SignalManager, [{
            key: 'connect_smartGui',
            value: function connect_smartGui(slot) {
                this.smartGuiControlSignal.push(slot);
            }

            // 
            //  DESC: Connect to the smart gui menu signal
            //

        }, {
            key: 'connect_smartMenu',
            value: function connect_smartMenu(slot) {
                this.smartMenuSignal.push(slot);
            }

            // 
            //  DESC: Connect to the Ai Sprite create signal
            //

        }, {
            key: 'connect_aiCreate',
            value: function connect_aiCreate(slot) {
                this.aiCreateSignal.push(slot);
            }

            // 
            //  DESC: Connect to the load signal
            //

        }, {
            key: 'connect_loadComplete',
            value: function connect_loadComplete(slot) {
                this.loadCompleteSignal.push(slot);
            }

            // 
            //  DESC: Connect to the resolution change signal
            //

        }, {
            key: 'connect_resolutionChange',
            value: function connect_resolutionChange(slot) {
                this.resolutionChangeSignal.push(slot);
            }

            // 
            //  DESC: disconnect to the load signal
            //

        }, {
            key: 'clear_loadComplete',
            value: function clear_loadComplete(slot) {
                this.loadCompleteSignal = [];
            }

            // 
            //  DESC: Broadcast smart gui control signal
            //

        }, {
            key: 'broadcast_smartGui',
            value: function broadcast_smartGui(control) {
                for (var i = 0; i < this.smartGuiControlSignal.length; ++i) {
                    this.smartGuiControlSignal[i](control);
                }
            }

            // 
            //  DESC: Broadcast smart gui control signal
            //

        }, {
            key: 'broadcast_smartMenu',
            value: function broadcast_smartMenu(menu) {
                for (var i = 0; i < this.smartMenuSignal.length; ++i) {
                    this.smartMenuSignal[i](menu);
                }
            }

            // 
            //  DESC: Broadcast AI Actor create signal
            //

        }, {
            key: 'broadcast_aiCreate',
            value: function broadcast_aiCreate(aiName, actorSprite) {
                for (var i = 0; i < this.aiCreateSignal.length; ++i) {
                    this.aiCreateSignal[i](aiName, actorSprite);
                }
            }

            // 
            //  DESC: Broadcast the load signal
            //

        }, {
            key: 'broadcast_loadComplete',
            value: function broadcast_loadComplete() {
                for (var i = 0; i < this.loadCompleteSignal.length; ++i) {
                    this.loadCompleteSignal[i]();
                }
            }

            // 
            //  DESC: Broadcast the resolution change
            //

        }, {
            key: 'broadcast_resolutionChange',
            value: function broadcast_resolutionChange() {
                for (var i = 0; i < this.resolutionChangeSignal.length; ++i) {
                    this.resolutionChangeSignal[i]();
                }
            }
        }]);

        return SignalManager;
    }();

    var signalManager = new SignalManager();

    /***/
},
/* 19 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return vertexBufferManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__common_quad2d__ = __webpack_require__(60);

    //
    //  FILE NAME: vertexbuffermanager.js
    //  DESC:      vertex buffer manager class singleton
    //


    var VertexBufferManager = function () {
        function VertexBufferManager() {
            _classCallCheck(this, VertexBufferManager);

            // Map containing a group of VBO handles
            this.vertexBufMapMap = new Map();

            // Map containing a group of IBO handles
            this.indexBufMapMap = new Map();

            // Current vbo
            this.currentVBO = null;

            // Current ibo
            this.currentIBO = null;

            // Current dynamic font IBO indices size
            this.currentMaxFontIndices = 0;
        }

        //
        //  DESC: Load all the textures associated with this group
        //


        _createClass(VertexBufferManager, [{
            key: 'createVBO',
            value: function createVBO(group, name, vertAry) {
                // Create the group map if it doesn't already exist
                var groupMap = this.vertexBufMapMap.get(group);
                if (groupMap === undefined) {
                    groupMap = new Map();
                    this.vertexBufMapMap.set(group, groupMap);
                }

                // See if this vertex buffer ID has already been created
                var vboID = groupMap.get(name);
                if (vboID === undefined) {
                    vboID = __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].createBuffer();
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, vboID);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bufferData(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, new Float32Array(vertAry), __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].STATIC_DRAW);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, null);

                    groupMap.set(name, vboID);
                }

                return vboID;
            }

            //
            //  DESC: Load all the textures associated with this group
            //

        }, {
            key: 'createIBO',
            value: function createIBO(group, name, indexAry, intAs8bit) {
                // Create the group map if it doesn't already exist
                var groupMap = this.indexBufMapMap.get(group);
                if (groupMap === undefined) {
                    groupMap = new Map();
                    this.indexBufMapMap.set(group, groupMap);
                }

                // See if this vertex buffer ID has already been created
                var iboID = groupMap.get(name);
                if (iboID === undefined) {
                    iboID = __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].createBuffer();
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, iboID);

                    if (intAs8bit) __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bufferData(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, new Uint8Array(indexAry), __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].STATIC_DRAW);else __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bufferData(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, new Uint16Array(indexAry), __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].STATIC_DRAW);

                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, null);

                    groupMap.set(name, iboID);
                }

                return iboID;
            }

            //
            //  DESC: Create a dynamic font IBO buffer
            //

        }, {
            key: 'createDynamicFontIBO',
            value: function createDynamicFontIBO(group, name, indexAry, maxIndicies) {
                // Create the group map if it doesn't already exist
                var groupMap = this.indexBufMapMap.get(group);
                if (groupMap === undefined) {
                    groupMap = new Map();
                    this.indexBufMapMap.set(group, groupMap);
                }

                // If it's not found, create the intex buffer and add it to the list
                var iboID = groupMap.get(name);
                if (iboID === undefined) {
                    iboID = __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].createBuffer();

                    groupMap.set(name, iboID);
                }

                // If the new indices are greater then the current, init the IBO with the newest
                if (maxIndicies > this.currentMaxFontIndices) {
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, iboID);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bufferData(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, new Uint16Array(indexAry), __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].STATIC_DRAW);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, null);

                    // Save the number of indices for later to compare and expand this size of this IBO
                    this.currentMaxFontIndices = maxIndicies;
                }

                return iboID;
            }

            //
            //  DESC: Create a scaled frame
            //

        }, {
            key: 'createScaledFrame',
            value: function createScaledFrame(group, name, scaledFrame, textureSize, glyphSize, frameSize, spriteSheetOffset) {
                var meshFileVertAry = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

                // Create the group map if it doesn't already exist
                var groupMap = this.vertexBufMapMap.get(group);
                if (groupMap === undefined) {
                    groupMap = new Map();
                    this.vertexBufMapMap.set(group, groupMap);
                }

                // See if this vertex buffer ID has already been created
                var vboID = groupMap.get(name);
                if (vboID === undefined) {
                    var vertAry = [];

                    // Generate the scaled frame
                    this.generateScaledFrame(vertAry, scaledFrame, textureSize, glyphSize, frameSize, spriteSheetOffset);

                    if (meshFileVertAry !== null) Array.prototype.push.apply(vertAry, meshFileVertAry);

                    vboID = __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].createBuffer();
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, vboID);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bufferData(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, new Float32Array(vertAry), __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].STATIC_DRAW);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, null);

                    groupMap.set(name, vboID);
                }

                return vboID;
            }

            //
            //  DESC: Create a scaled frame
            //

        }, {
            key: 'generateScaledFrame',
            value: function generateScaledFrame(vertAry, scaledFrame, textureSize, glyphSize, frameSize, spriteSheetOffset) {
                // Offsets to center the mesh
                var center = new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */](frameSize.w / 2, frameSize.h / 2);
                var frameLgth = new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](frameSize.w - scaledFrame.frame.w * 2.0, frameSize.h - scaledFrame.frame.h * 2.0);
                var uvLgth = new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](glyphSize.w - scaledFrame.frame.w * 2.0, glyphSize.h - scaledFrame.frame.h * 2.0);

                var quadBuf = [new __WEBPACK_IMPORTED_MODULE_3__common_quad2d__["a" /* Quad2d */](), new __WEBPACK_IMPORTED_MODULE_3__common_quad2d__["a" /* Quad2d */](), new __WEBPACK_IMPORTED_MODULE_3__common_quad2d__["a" /* Quad2d */](), new __WEBPACK_IMPORTED_MODULE_3__common_quad2d__["a" /* Quad2d */](), new __WEBPACK_IMPORTED_MODULE_3__common_quad2d__["a" /* Quad2d */](), new __WEBPACK_IMPORTED_MODULE_3__common_quad2d__["a" /* Quad2d */](), new __WEBPACK_IMPORTED_MODULE_3__common_quad2d__["a" /* Quad2d */](), new __WEBPACK_IMPORTED_MODULE_3__common_quad2d__["a" /* Quad2d */]()];

                // Left frame
                this.createQuad(new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */](-center.x, center.y - scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, -frameLgth.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](0, scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, uvLgth.h), textureSize, frameSize, spriteSheetOffset, quadBuf[0]);

                // top left
                this.createQuad(new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */](-center.x, center.y), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, -scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](0, 0), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, scaledFrame.frame.h), textureSize, frameSize, spriteSheetOffset, quadBuf[1]);

                // top
                this.createQuad(new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */](-(center.x - scaledFrame.frame.w), center.y), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](frameLgth.w, -scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, 0), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](uvLgth.w, scaledFrame.frame.h), textureSize, frameSize, spriteSheetOffset, quadBuf[2]);

                // top right
                this.createQuad(new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */](center.x - scaledFrame.frame.w, center.y), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, -scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w + uvLgth.w, 0), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, scaledFrame.frame.h), textureSize, frameSize, spriteSheetOffset, quadBuf[3]);

                // right frame
                this.createQuad(new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */](center.x - scaledFrame.frame.w, center.y - scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, -frameLgth.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w + uvLgth.w, scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, uvLgth.h), textureSize, frameSize, spriteSheetOffset, quadBuf[4]);

                // bottom right
                this.createQuad(new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */](center.x - scaledFrame.frame.w, -(center.y - scaledFrame.frame.h)), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, -scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w + uvLgth.w, scaledFrame.frame.h + uvLgth.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, scaledFrame.frame.h), textureSize, frameSize, spriteSheetOffset, quadBuf[5]);

                // bottom frame
                this.createQuad(new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */](-(center.x - scaledFrame.frame.w), -(center.y - scaledFrame.frame.h)), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](frameLgth.w, -scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, scaledFrame.frame.h + uvLgth.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](uvLgth.w, scaledFrame.frame.h), textureSize, frameSize, spriteSheetOffset, quadBuf[6]);

                // bottom left
                this.createQuad(new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */](-center.x, -(center.y - scaledFrame.frame.h)), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, -scaledFrame.frame.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](0, scaledFrame.frame.h + uvLgth.h), new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](scaledFrame.frame.w, scaledFrame.frame.h), textureSize, frameSize, spriteSheetOffset, quadBuf[7]);

                // Piece together the needed unique verts
                Array.prototype.push.apply(vertAry, quadBuf[0].vert[0].data);
                Array.prototype.push.apply(vertAry, quadBuf[0].vert[1].data);
                Array.prototype.push.apply(vertAry, quadBuf[0].vert[2].data);
                Array.prototype.push.apply(vertAry, quadBuf[0].vert[3].data);
                Array.prototype.push.apply(vertAry, quadBuf[1].vert[1].data);
                Array.prototype.push.apply(vertAry, quadBuf[1].vert[2].data);
                Array.prototype.push.apply(vertAry, quadBuf[2].vert[1].data);
                Array.prototype.push.apply(vertAry, quadBuf[2].vert[3].data);
                Array.prototype.push.apply(vertAry, quadBuf[3].vert[1].data);
                Array.prototype.push.apply(vertAry, quadBuf[3].vert[3].data);
                Array.prototype.push.apply(vertAry, quadBuf[4].vert[0].data);
                Array.prototype.push.apply(vertAry, quadBuf[4].vert[3].data);
                Array.prototype.push.apply(vertAry, quadBuf[5].vert[0].data);
                Array.prototype.push.apply(vertAry, quadBuf[5].vert[3].data);
                Array.prototype.push.apply(vertAry, quadBuf[6].vert[0].data);
                Array.prototype.push.apply(vertAry, quadBuf[7].vert[0].data);
            }

            //
            //  DESC: Create a quad
            //

        }, {
            key: 'createQuad',
            value: function createQuad(vert, vSize, uv, uvSize, textureSize, frameSize, spriteSheetOffset, quadBuf) {
                // For OpenGL pixel perfect rendering is an even size graphic,
                // for DirectX, it's an odd size graphic.

                // Check if the width or height is odd. If so, we offset 
                // by 0.5 for proper orthographic rendering
                var additionalOffsetX = 0;
                if (Math.trunc(frameSize.w) % 2 != 0) additionalOffsetX = 0.5;

                var additionalOffsetY = 0;
                if (Math.trunc(frameSize.h) % 2 != 0) additionalOffsetY = 0.5;

                // Calculate the third vertex of the first face
                quadBuf.vert[0].x = vert.x + additionalOffsetX;
                quadBuf.vert[0].y = vert.y + additionalOffsetY + vSize.h;
                quadBuf.vert[0].u = spriteSheetOffset.x1 + uv.u / textureSize.w;
                quadBuf.vert[0].v = spriteSheetOffset.y1 + (uv.v + uvSize.h) / textureSize.h;

                // Calculate the second vertex of the first face
                quadBuf.vert[1].x = vert.x + additionalOffsetX + vSize.w;
                quadBuf.vert[1].y = vert.y + additionalOffsetY;
                quadBuf.vert[1].u = spriteSheetOffset.x1 + (uv.u + uvSize.w) / textureSize.w;
                quadBuf.vert[1].v = spriteSheetOffset.y1 + uv.v / textureSize.h;

                // Calculate the first vertex of the first face
                quadBuf.vert[2].x = quadBuf.vert[0].x;
                quadBuf.vert[2].y = quadBuf.vert[1].y;
                quadBuf.vert[2].u = quadBuf.vert[0].u;
                quadBuf.vert[2].v = quadBuf.vert[1].v;

                // Calculate the second vertex of the second face
                quadBuf.vert[3].x = quadBuf.vert[1].x;
                quadBuf.vert[3].y = quadBuf.vert[0].y;
                quadBuf.vert[3].u = quadBuf.vert[1].u;
                quadBuf.vert[3].v = quadBuf.vert[0].v;
            }

            //
            //  DESC: Delete the group of buffers
            //

        }, {
            key: 'deleteGroup',
            value: function deleteGroup(group) {
                var groupMap = this.vertexBufMapMap.get(group);
                if (groupMap !== undefined) {
                    var _iteratorNormalCompletion8 = true;
                    var _didIteratorError8 = false;
                    var _iteratorError8 = undefined;

                    try {
                        for (var _iterator8 = groupMap.entries()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                            var _step8$value = _slicedToArray(_step8.value, 2),
                                key = _step8$value[0],
                                vboID = _step8$value[1];

                            __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].deleteBuffer(vboID);
                        }
                    } catch (err) {
                        _didIteratorError8 = true;
                        _iteratorError8 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion8 && _iterator8.return) {
                                _iterator8.return();
                            }
                        } finally {
                            if (_didIteratorError8) {
                                throw _iteratorError8;
                            }
                        }
                    }

                    this.vertexBufMapMap.delete(group);
                }

                groupMap = this.indexBufMapMap.get(group);
                if (groupMap !== undefined) {
                    var _iteratorNormalCompletion9 = true;
                    var _didIteratorError9 = false;
                    var _iteratorError9 = undefined;

                    try {
                        for (var _iterator9 = groupMap.entries()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                            var _step9$value = _slicedToArray(_step9.value, 2),
                                key = _step9$value[0],
                                iboID = _step9$value[1];

                            __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].deleteBuffer(iboID);
                        }
                    } catch (err) {
                        _didIteratorError9 = true;
                        _iteratorError9 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion9 && _iterator9.return) {
                                _iterator9.return();
                            }
                        } finally {
                            if (_didIteratorError9) {
                                throw _iteratorError9;
                            }
                        }
                    }

                    this.indexBufMapMap.delete(group);
                }
            }

            //
            //  DESC: See if a VBO already exists
            //

        }, {
            key: 'isVBO',
            value: function isVBO(group, name) {
                // See if the group exists
                var groupMap = this.vertexBufMapMap.get(group);
                if (groupMap === undefined) return null;

                // See if this vertex buffer ID has already been created
                var vboId = groupMap.get(name);
                if (vboId === undefined) return null;

                return vboId;
            }

            //
            //  DESC: Bind the buffers
            //

        }, {
            key: 'bind',
            value: function bind(vbo, ibo) {
                if (this.currentVBO != vbo) {
                    // save the current binding
                    this.currentVBO = vbo;

                    // Have OpenGL bind this buffer now
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, vbo);
                }

                if (this.currentIBO != ibo) {
                    // save the current binding
                    this.currentIBO = ibo;

                    // Have OpenGL bind this buffer now
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, ibo);
                }
            }

            //
            //  DESC: Bind the buffers
            //

        }, {
            key: 'unbind',
            value: function unbind() {
                this.currentVBO = null;
                this.currentIBO = null;
                __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, null);
                __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, null);
            }
        }]);

        return VertexBufferManager;
    }();

    var vertexBufferManager = new VertexBufferManager();

    /***/
},
/* 20 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME:  rect.js
    //  DESC:       rect class
    //


    var Rect = function () {
        function Rect() {
            var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

            _classCallCheck(this, Rect);

            this.data = new Float32Array([x1, y1, x2, y2]);
        }

        _createClass(Rect, [{
            key: 'set',
            value: function set() {
                var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

                this.data[0] = x1;
                this.data[1] = y1;
                this.data[2] = x2;
                this.data[3] = y2;
            }
        }, {
            key: 'x1',
            set: function set(value) {
                this.data[0] = value;
            },
            get: function get() {
                return this.data[0];
            }
        }, {
            key: 'y1',
            set: function set(value) {
                this.data[1] = value;
            },
            get: function get() {
                return this.data[1];
            }
        }, {
            key: 'x2',
            set: function set(value) {
                this.data[2] = value;
            },
            get: function get() {
                return this.data[2];
            }
        }, {
            key: 'y2',
            set: function set(value) {
                this.data[3] = value;
            },
            get: function get() {
                return this.data[3];
            }
        }]);

        return Rect;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Rect;

    /***/
},
/* 21 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    //
    //  FILE NAME: scriptcomponent.js
    //  DESC:      Class for handling game scripting
    //


    var ScriptComponent = function () {
        function ScriptComponent() {
            _classCallCheck(this, ScriptComponent);

            this.scriptAry = [];
        }

        // 
        //  DESC: Update the script
        //


        _createClass(ScriptComponent, [{
            key: 'set',
            value: function set(script) {
                this.scriptAry.push(script);
            }

            // 
            //  DESC: Update the script
            //

        }, {
            key: 'update',
            value: function update() {
                // Call the active scripts
                for (var i = this.scriptAry.length - 1; i > -1; --i) {
                    this.scriptAry[i].execute();

                    // If the script is finished, remove it
                    if (this.scriptAry[i].isFinished) this.scriptAry.splice(i, 1);
                }
            }

            // 
            //  DESC: Is this component active?
            //

        }, {
            key: 'isActive',
            value: function isActive() {
                return this.scriptAry.length > 0;
            }

            // 
            //  DESC: clear out the scripts
            //

        }, {
            key: 'reset',
            value: function reset() {
                this.scriptAry = [];
            }
        }]);

        return ScriptComponent;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ScriptComponent;

    /***/
},
/* 22 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__statemessage__ = __webpack_require__(92);

    // 
    //  FILE NAME: gamestate.js
    //  DESC:      game state base class
    //


    var GAME_STATE_NULL = 0;
    /* unused harmony export GAME_STATE_NULL */

    var GAME_STATE_STARTUP = 1;
    /* harmony export (immutable) */__webpack_exports__["c"] = GAME_STATE_STARTUP;

    var GAME_STATE_TITLESCREEN = 2;
    /* harmony export (immutable) */__webpack_exports__["d"] = GAME_STATE_TITLESCREEN;

    var GAME_STATE_LOAD = 3;
    /* harmony export (immutable) */__webpack_exports__["a"] = GAME_STATE_LOAD;

    var GAME_STATE_RUN = 4;
    /* harmony export (immutable) */__webpack_exports__["b"] = GAME_STATE_RUN;

    var GameState = function () {
        function GameState(gameState, nextState, callback) {
            _classCallCheck(this, GameState);

            this.stateChange = false;
            this.gameState = gameState;
            this.nextState = nextState;
            this.callback = callback;

            // Message to send to next state
            this.stateMessage = new __WEBPACK_IMPORTED_MODULE_0__statemessage__["a" /* StateMessage */]();
        }

        _createClass(GameState, [{
            key: 'init',
            value: function init() {
                // Empty function to be overwritten
            }
        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                // Empty function to be overwritten
            }
        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                // Empty function to be overwritten
            }
        }, {
            key: 'doStateChange',
            value: function doStateChange() {
                // Empty function to be overwritten
                return this.stateChange;
            }
        }, {
            key: 'physics',
            value: function physics() {
                // Empty function to be overwritten
            }
        }, {
            key: 'update',
            value: function update() {
                // Empty function to be overwritten
            }
        }, {
            key: 'transform',
            value: function transform() {
                // Empty function to be overwritten
            }
        }, {
            key: 'preRender',
            value: function preRender() {
                // Empty function to be overwritten
            }
        }, {
            key: 'postRender',
            value: function postRender() {
                // Empty function to be overwritten
            }
        }]);

        return GameState;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["e"] = GameState;

    /***/
},
/* 23 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__utilities_assetholder__ = __webpack_require__(12);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_genfunc__ = __webpack_require__(3);

    //
    //  FILE NAME: managerbase.js
    //  DESC:      Base class for common manager behaviors
    //


    var ManagerBase = function () {
        function ManagerBase() {
            _classCallCheck(this, ManagerBase);

            this.listTableMap = new Map();

            // load counter
            this.loadCounter = 0;
        }

        // 
        //  DESC: Load the data list tables
        //


        _createClass(ManagerBase, [{
            key: 'loadListTable',
            value: function loadListTable(xmlNode) {
                if (xmlNode) {
                    var groupLst = xmlNode.getElementsByTagName('groupList');

                    for (var i = 0; i < groupLst.length; ++i) {
                        var groupName = groupLst[i].getAttribute('groupName');

                        var fileLst = groupLst[i].getElementsByTagName('file');
                        if (fileLst.length) {
                            var pathAry = [];
                            for (var j = 0; j < fileLst.length; ++j) {
                                pathAry.push(fileLst[j].getAttribute('path'));
                            }

                            this.listTableMap.set(groupName, pathAry);
                        }
                    }
                }
            }

            //
            //  DESC: Load the XML file
            //

        }, {
            key: 'downloadFile',
            value: function downloadFile(fileType, group, filePath, finishCallback, loadCallback) {
                var _this7 = this;

                // Use a counter to determine when the load is done because there's
                // no garentee they will finish in the order executed
                // Always do this before the load
                ++this.loadCounter;

                __WEBPACK_IMPORTED_MODULE_1__utilities_genfunc__["b" /* downloadFile */](fileType, filePath, function (fileData) {
                    // Load all object information from an xml node
                    loadCallback(group, fileData, filePath, finishCallback);

                    // Always do this after the load
                    --_this7.loadCounter;

                    if (_this7.loadCounter === 0) finishCallback();
                });
            }

            //
            //  DESC: Load all XML's associated with this group
            //

        }, {
            key: 'loadGroup',
            value: function loadGroup(groupNameStr, groupMapMap, groupAry, finishCallback) {
                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Make sure the group we are looking for has been defined in the list table file
                    var pathAry = this.listTableMap.get(group);
                    if (pathAry !== undefined) {
                        // Load the group data if it doesn't already exist
                        if (groupMapMap.get(group) === undefined) {
                            // Create a new group map inside of our map
                            groupMapMap.set(group, new Map());

                            this.load(group, finishCallback);
                        } else {
                            throw new Error(groupNameStr + ' group has alread been loaded (' + group + ')!');
                        }
                    } else {
                        throw new Error(groupNameStr + ' group name can\'t be found (' + group + ')!');
                    }
                }
            }

            //
            //  DESC: Load all XML's associated with this group
            //

        }, {
            key: 'load',
            value: function load(group, finishCallback) {
                var _this8 = this;

                // Make sure the group we are looking for has been defined in the list table file
                var pathAry = this.listTableMap.get(group);
                if (pathAry !== undefined) {
                    for (var i = 0; i < pathAry.length; ++i) {
                        // Check if this file has already been loaded
                        if (!__WEBPACK_IMPORTED_MODULE_0__utilities_assetholder__["a" /* assetHolder */].has(group, pathAry[i])) {
                            this.downloadFile('xml', group, pathAry[i], finishCallback, function (group, xmlNode, filePath, finishCallback) {
                                // Store the preloaded XML file
                                __WEBPACK_IMPORTED_MODULE_0__utilities_assetholder__["a" /* assetHolder */].set(group, filePath, xmlNode);

                                // Call the class function to load the data
                                _this8.loadFromNode(group, xmlNode, filePath, finishCallback);
                            });
                        } else {
                            this.loadFromNode(group, __WEBPACK_IMPORTED_MODULE_0__utilities_assetholder__["a" /* assetHolder */].get(group, pathAry[i]), pathAry[i]);
                        }
                    }

                    // If there's nothing to load, call the complete callback
                    if (this.loadCounter === 0) finishCallback();
                }
            }
        }]);

        return ManagerBase;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ManagerBase;

    /***/
},
/* 24 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return menuManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__managers_managerbase__ = __webpack_require__(23);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__ = __webpack_require__(33);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__managers_signalmanager__ = __webpack_require__(18);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__utilities_assetholder__ = __webpack_require__(12);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__gui_menu__ = __webpack_require__(72);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__gui_menutree__ = __webpack_require__(89);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__utilities_genfunc__ = __webpack_require__(3);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: menumanager.js
    //  DESC:      menu manager class singleton
    //


    var MenuManager = function (_WEBPACK_IMPORTED_MO4) {
        _inherits(MenuManager, _WEBPACK_IMPORTED_MO4);

        function MenuManager() {
            _classCallCheck(this, MenuManager);

            // Map map of menu trees
            var _this9 = _possibleConstructorReturn(this, (MenuManager.__proto__ || Object.getPrototypeOf(MenuManager)).call(this));

            _this9.menuTreeMapMap = new Map();

            // Map of the menus
            _this9.menuMapMap = new Map();

            // Array of active menu trees
            _this9.activeMenuTreeAry = [];

            // Array of active interface trees
            _this9.activeInterTreeAry = [];

            // menu manager state
            _this9.active = false;

            // Actions
            _this9.backAction;
            _this9.toggleAction;
            _this9.escapeAction;
            _this9.selectAction;
            _this9.upAction;
            _this9.downAction;
            _this9.leftAction;
            _this9.rightAction;
            _this9.tabLeft;
            _this9.tabRight;
            _this9.defaultTree;

            // scroll timer Id
            _this9.scrollTimerId = 0;

            // Allow message processing
            _this9.allow = false;
            return _this9;
        }

        // 
        //  DESC: Load the menu group
        //


        _createClass(MenuManager, [{
            key: 'preloadGroup',
            value: function preloadGroup(groupAry, finishCallback) {
                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Make sure the group we are looking for has been defined in the list table file
                    var pathAry = this.listTableMap.get(group);
                    if (pathAry !== undefined) {
                        // Load the group data if it doesn't already exist
                        if (this.menuMapMap.get(group) === undefined) {
                            // Create a new group map inside of our maps
                            this.menuMapMap.set(group, new Map());
                            this.menuTreeMapMap.set(group, new Map());

                            for (var i = 0; i < pathAry.length; ++i) {
                                this.downloadFile('xml', group, pathAry[i], finishCallback, this.preload.bind(this));
                            }
                        } else {
                            throw new Error('Menu group has alread been loaded (' + group + ')!');
                        }
                    } else {
                        throw new Error('Menu Manager list group name can\'t be found (' + group + ')!');
                    }
                }
            }

            //
            //  DESC: Load all object information from an xml node
            //

        }, {
            key: 'preload',
            value: function preload(group, node, filePath, finishCallback) {
                // Load the menus from node
                this.preloadMenuXML(group, node, finishCallback);

                // Load the trees from node
                this.loadTreesFromNode(group, node);
            }

            //
            //  DESC: preload all object information from an xml node
            //

        }, {
            key: 'preloadMenuXML',
            value: function preloadMenuXML(group, node, finishCallback) {
                var _this10 = this;

                // Get the menu group map
                var groupMap = this.menuMapMap.get(group);

                var menuNode = node.getElementsByTagName('menu');

                for (var i = 0; i < menuNode.length; ++i) {
                    // Get the name of the menu
                    var _name4 = menuNode[i].getAttribute('name');

                    // Get the menu file path
                    var _filePath2 = menuNode[i].getAttribute('file');

                    // Check for duplicates
                    if (groupMap.get(_name4) !== undefined) throw new Error('Duplicate menu name! (' + _name4 + ').');

                    // Allocate a new menu
                    var menu = new __WEBPACK_IMPORTED_MODULE_5__gui_menu__["a" /* Menu */](_name4, group, _filePath2);

                    // Insert the menu into the group map
                    groupMap.set(_name4, menu);

                    // Load the transform from node
                    menu.loadTransFromNode(menuNode[i]);

                    // Load the dynamic offset from node
                    menu.loadDynamicOffsetFromNode(menuNode[i]);

                    // Check if this file has already been loaded
                    if (!__WEBPACK_IMPORTED_MODULE_4__utilities_assetholder__["a" /* assetHolder */].has(group, _filePath2)) {
                        // Set a place holder for the data to be loaded
                        __WEBPACK_IMPORTED_MODULE_4__utilities_assetholder__["a" /* assetHolder */].set(group, _filePath2);

                        // Load the menu XML file
                        this.downloadFile('xml', group, _filePath2, finishCallback, function (group, xmlNode, filePath, finishCallback) {
                            // Store the preloaded XML file
                            __WEBPACK_IMPORTED_MODULE_4__utilities_assetholder__["a" /* assetHolder */].set(group, filePath, xmlNode);

                            // Recurse back until all XML files are loaded
                            _this10.preloadControlXML(group, xmlNode, finishCallback);
                        });
                    }
                }
            }

            //
            //  DESC: Load the trees from node
            //

        }, {
            key: 'loadTreesFromNode',
            value: function loadTreesFromNode(group, node) {
                // Get the menu group map
                var menuGroupMap = this.menuMapMap.get(group);

                // Get the tree group map
                var treeGroupMap = this.menuTreeMapMap.get(group);

                // Get the node to the list of trees
                var treeNode = node.getElementsByTagName('tree');

                for (var i = 0; i < treeNode.length; ++i) {
                    // Get the name
                    var _name5 = treeNode[i].getAttribute('name');

                    // Get the root menu
                    var rootMenu = treeNode[i].getAttribute('root');

                    // Get the default menu
                    var defaultMenu = treeNode[i].getAttribute('default');

                    // Is this menu an interface menu?
                    var interfaceMenu = treeNode[i].getAttribute('interfaceMenu') === 'true';

                    // Check for duplicate names
                    if (treeGroupMap.get(_name5) !== undefined) throw new Error('Duplicate tree name! (' + _name5 + ').');

                    // Add the tree data to the map
                    treeGroupMap.set(_name5, new __WEBPACK_IMPORTED_MODULE_6__gui_menutree__["a" /* MenuTree */](_name5, menuGroupMap, rootMenu, defaultMenu, interfaceMenu));

                    // Check that the root menu exists
                    if (rootMenu !== '') {
                        if (menuGroupMap.get(rootMenu) === undefined) throw new Error('Root menu doesn\'t exist! (' + _name5 + ').');
                    } else if (defaultMenu !== '') {
                        if (menuGroupMap.get(defaultMenu) === undefined) throw new Error('Default menu doesn\'t exist! (' + _name5 + ').');
                    }
                }
            }

            //
            //  DESC: preload the menu controls from menu node
            //

        }, {
            key: 'preloadControlXML',
            value: function preloadControlXML(group, node, finishCallback) {
                var _this11 = this;

                var controlLst = ['staticMenuControls', 'mouseOnlyControls', 'menuControls', 'subControlList', 'scrollBoxControlList'];

                // Load the control XML files
                for (var i = 0; i < controlLst.length; ++i) {
                    var nodeLst = node.getElementsByTagName(controlLst[i]);
                    if (nodeLst.length) {
                        var controlNode = nodeLst[0].getElementsByTagName('control');

                        for (var j = 0; j < controlNode.length; ++j) {
                            var filePathNode = controlNode[j].getElementsByTagName('filePath');
                            if (filePathNode.length) {
                                var _filePath3 = filePathNode[0].getAttribute('file');
                                if (_filePath3) {
                                    // Check if this file has already been loaded
                                    if (!__WEBPACK_IMPORTED_MODULE_4__utilities_assetholder__["a" /* assetHolder */].has(group, _filePath3)) {
                                        // Set a place holder for the data to be loaded
                                        __WEBPACK_IMPORTED_MODULE_4__utilities_assetholder__["a" /* assetHolder */].set(group, _filePath3);

                                        this.downloadFile('xml', group, _filePath3, finishCallback, function (group, xmlNode, filePath, finishCallback) {
                                            // Store the preloaded XML file
                                            __WEBPACK_IMPORTED_MODULE_4__utilities_assetholder__["a" /* assetHolder */].set(group, filePath, xmlNode);

                                            // Recurse back until all XML files are loaded for this control
                                            _this11.preloadControlXML(group, xmlNode, finishCallback);
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            //
            //  DESC: Load all object information from an xml node
            //

        }, {
            key: 'createGroup',
            value: function createGroup(groupAry) {
                var doInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Get the menu group map
                    var groupMap = this.menuMapMap.get(group);
                    if (groupMap === undefined) throw new Error('Group map can\'t be found! (' + group + ').');

                    var _iteratorNormalCompletion10 = true;
                    var _didIteratorError10 = false;
                    var _iteratorError10 = undefined;

                    try {
                        for (var _iterator10 = groupMap.entries()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                            var _step10$value = _slicedToArray(_step10.value, 2),
                                key = _step10$value[0],
                                menu = _step10$value[1];

                            // Get the menu XML node
                            var node = __WEBPACK_IMPORTED_MODULE_4__utilities_assetholder__["a" /* assetHolder */].get(group, menu.filePath);

                            // Have the menu load it's share
                            menu.loadFromNode(node);

                            // Broadcast signal to let the game handle smart menu inits
                            __WEBPACK_IMPORTED_MODULE_3__managers_signalmanager__["a" /* signalManager */].broadcast_smartMenu(menu);

                            // Handle any smart menu creates
                            menu.smartCreate();
                        }
                    } catch (err) {
                        _didIteratorError10 = true;
                        _iteratorError10 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion10 && _iterator10.return) {
                                _iterator10.return();
                            }
                        } finally {
                            if (_didIteratorError10) {
                                throw _iteratorError10;
                            }
                        }
                    }

                    if (doInit) this.initGroup(group);
                }
            }

            //
            //  DESC: Free the menu group
            //

        }, {
            key: 'freeGroup',
            value: function freeGroup(groupAry) {
                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Make sure the group we are looking for exists
                    if (this.listTableMap.get(group) === undefined) throw new Error('Object data list group name can\'t be found (' + group + ')!');

                    // Get the group map
                    var groupMap = this.menuTreeMapMap.get(group);
                    if (groupMap !== undefined) {
                        // Remove it from the tree vectors if it is there
                        var _iteratorNormalCompletion11 = true;
                        var _didIteratorError11 = false;
                        var _iteratorError11 = undefined;

                        try {
                            for (var _iterator11 = groupMap.entries()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                                var _step11$value = _slicedToArray(_step11.value, 2),
                                    key = _step11$value[0],
                                    menuTree = _step11$value[1];

                                if (menuTree.interfaceMenu) {
                                    var index = this.activeInterTreeAry.indexOf(menuTree);

                                    if (index > -1) this.activeInterTreeAry.splice(index, 1);
                                } else {
                                    var _index = this.activeMenuTreeAry.indexOf(menuTree);

                                    if (_index > -1) this.activeMenuTreeAry.splice(_index, 1);
                                }
                            }

                            // Free the menu group
                        } catch (err) {
                            _didIteratorError11 = true;
                            _iteratorError11 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion11 && _iterator11.return) {
                                    _iterator11.return();
                                }
                            } finally {
                                if (_didIteratorError11) {
                                    throw _iteratorError11;
                                }
                            }
                        }

                        this.menuTreeMapMap.delete(group);
                        this.menuMapMap.delete(group);
                    }
                }
            }

            // 
            //  DESC: Init a menu group
            //  NOTE: This allows certain actions to be done after the group load
            //

        }, {
            key: 'initGroup',
            value: function initGroup(group) {
                var groupMap = this.menuMapMap.get(group);
                if (groupMap !== undefined) {
                    var _iteratorNormalCompletion12 = true;
                    var _didIteratorError12 = false;
                    var _iteratorError12 = undefined;

                    try {
                        for (var _iterator12 = groupMap.entries()[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                            var _step12$value = _slicedToArray(_step12.value, 2),
                                key = _step12$value[0],
                                menu = _step12$value[1];

                            menu.init();
                        }
                    } catch (err) {
                        _didIteratorError12 = true;
                        _iteratorError12 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion12 && _iterator12.return) {
                                _iterator12.return();
                            }
                        } finally {
                            if (_didIteratorError12) {
                                throw _iteratorError12;
                            }
                        }
                    }
                } else {
                    throw new Error('Menu group name can\'t be found to init (' + group + ')!');
                }
            }

            // 
            //  DESC: Clean up a menu group
            //  NOTE: This allows certain actions to be done after the group load
            //

        }, {
            key: 'cleanUpGroup',
            value: function cleanUpGroup(group) {
                var groupMap = this.menuMapMap.get(group);
                if (groupMap !== undefined) {
                    var _iteratorNormalCompletion13 = true;
                    var _didIteratorError13 = false;
                    var _iteratorError13 = undefined;

                    try {
                        for (var _iterator13 = groupMap.entries()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                            var _step13$value = _slicedToArray(_step13.value, 2),
                                key = _step13$value[0],
                                menu = _step13$value[1];

                            menu.cleanUp();
                        }
                    } catch (err) {
                        _didIteratorError13 = true;
                        _iteratorError13 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion13 && _iterator13.return) {
                                _iterator13.return();
                            }
                        } finally {
                            if (_didIteratorError13) {
                                throw _iteratorError13;
                            }
                        }
                    }
                } else {
                    throw new Error('Menu group name can\'t be found to clean up (' + group + ')!');
                }
            }

            // 
            //  DESC: Load the menu action list from XML
            //

        }, {
            key: 'loadMenuAction',
            value: function loadMenuAction(node) {
                this.backAction = node.getElementsByTagName('backAction')[0].childNodes[0].nodeValue;
                this.toggleAction = node.getElementsByTagName('toggleAction')[0].childNodes[0].nodeValue;
                this.escapeAction = node.getElementsByTagName('escapeAction')[0].childNodes[0].nodeValue;
                this.selectAction = node.getElementsByTagName('selectAction')[0].childNodes[0].nodeValue;
                this.upAction = node.getElementsByTagName('upAction')[0].childNodes[0].nodeValue;
                this.downAction = node.getElementsByTagName('downAction')[0].childNodes[0].nodeValue;
                this.leftAction = node.getElementsByTagName('leftAction')[0].childNodes[0].nodeValue;
                this.rightAction = node.getElementsByTagName('rightAction')[0].childNodes[0].nodeValue;
                this.tabLeft = node.getElementsByTagName('tabLeft')[0].childNodes[0].nodeValue;
                this.tabRight = node.getElementsByTagName('tabRight')[0].childNodes[0].nodeValue;
                this.defaultTree = node.getElementsByTagName('defaultTree')[0].childNodes[0].nodeValue;
            }

            // 
            //  DESC: Activate a tree to be used by tree name only
            //        NOTE: Assumes unique tree names
            //

        }, {
            key: 'activateTree',
            value: function activateTree(treeAry) {
                for (var tree = 0; tree < treeAry.length; ++tree) {
                    var treeStr = treeAry[tree];
                    var found = false;

                    var _iteratorNormalCompletion14 = true;
                    var _didIteratorError14 = false;
                    var _iteratorError14 = undefined;

                    try {
                        for (var _iterator14 = this.menuTreeMapMap.entries()[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                            var _step14$value = _slicedToArray(_step14.value, 2),
                                groupKey = _step14$value[0],
                                groupMap = _step14$value[1];

                            var _iteratorNormalCompletion15 = true;
                            var _didIteratorError15 = false;
                            var _iteratorError15 = undefined;

                            try {
                                for (var _iterator15 = groupMap.entries()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                                    var _step15$value = _slicedToArray(_step15.value, 2),
                                        key = _step15$value[0],
                                        _tree = _step15$value[1];

                                    if (key === treeStr) {
                                        this.activateTreeGroup(groupKey, key);
                                        found = true;
                                        break;
                                    }
                                }
                            } catch (err) {
                                _didIteratorError15 = true;
                                _iteratorError15 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion15 && _iterator15.return) {
                                        _iterator15.return();
                                    }
                                } finally {
                                    if (_didIteratorError15) {
                                        throw _iteratorError15;
                                    }
                                }
                            }

                            if (found) break;
                        }

                        // If you got this far, it's a problem
                    } catch (err) {
                        _didIteratorError14 = true;
                        _iteratorError14 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion14 && _iterator14.return) {
                                _iterator14.return();
                            }
                        } finally {
                            if (_didIteratorError14) {
                                throw _iteratorError14;
                            }
                        }
                    }

                    if (!found) throw new Error('Menu tree doesn\'t exist (' + treeStr + ')!');
                }
            }

            // 
            //  DESC: Activate a tree to be used
            //

        }, {
            key: 'activateTreeGroup',
            value: function activateTreeGroup(group, treeStr) {
                var groupMap = this.menuTreeMapMap.get(group);
                if (groupMap !== undefined) {
                    // Find the tree in the map
                    var tree = groupMap.get(treeStr);
                    if (tree !== undefined) {
                        if (tree.interfaceMenu) {
                            if (this.activeInterTreeAry.indexOf(tree) !== -1) throw new Error('Menu tree already active (' + group + ' - ' + treeStr + ')!');

                            this.activeInterTreeAry.push(tree);
                        } else {
                            if (this.activeMenuTreeAry.indexOf(tree) !== -1) throw new Error('Menu tree already active (' + group + ' - ' + treeStr + ')!');

                            this.activeMenuTreeAry.push(tree);
                        }

                        // Init the tree for use
                        tree.init();
                    } else {
                        throw new Error('Menu tree doesn\'t exist (' + group + ' - ' + treeStr + ')!');
                    }
                } else {
                    throw new Error('Menu tree group doesn\'t exist (' + group + ' - ' + treeStr + ')!');
                }

                // See if we are active
                this.setActiveState();
            }

            // 
            //  DESC: Deactivate a tree to be used by tree name only
            //        NOTE: Assumes unique tree names
            //

        }, {
            key: 'deactivateTree',
            value: function deactivateTree(treeStr) {
                var _iteratorNormalCompletion16 = true;
                var _didIteratorError16 = false;
                var _iteratorError16 = undefined;

                try {
                    for (var _iterator16 = this.menuTreeMapMap.entries()[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                        var _step16$value = _slicedToArray(_step16.value, 2),
                            groupKey = _step16$value[0],
                            groupMap = _step16$value[1];

                        var _iteratorNormalCompletion17 = true;
                        var _didIteratorError17 = false;
                        var _iteratorError17 = undefined;

                        try {
                            for (var _iterator17 = groupMap.entries()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                                var _step17$value = _slicedToArray(_step17.value, 2),
                                    key = _step17$value[0],
                                    tree = _step17$value[1];

                                if (key === treeStr) {
                                    ActivateTree(groupIter.first, treeIter.first);
                                    return;
                                }
                            }
                        } catch (err) {
                            _didIteratorError17 = true;
                            _iteratorError17 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion17 && _iterator17.return) {
                                    _iterator17.return();
                                }
                            } finally {
                                if (_didIteratorError17) {
                                    throw _iteratorError17;
                                }
                            }
                        }
                    }

                    // If you got this far, it's a problem
                } catch (err) {
                    _didIteratorError16 = true;
                    _iteratorError16 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion16 && _iterator16.return) {
                            _iterator16.return();
                        }
                    } finally {
                        if (_didIteratorError16) {
                            throw _iteratorError16;
                        }
                    }
                }

                throw new Error('Menu tree doesn\'t exist (' + treeStr + ')!');
            }

            // 
            //  DESC: Deactivate a tree that's in use
            //

        }, {
            key: 'deactivateTreeGroup',
            value: function deactivateTreeGroup(group, treeStr) {
                var groupMap = this.menuTreeMapMap.get(group);
                if (groupMap !== undefined) {
                    // Find the tree in the map
                    var tree = groupMap.get(treeStr);
                    if (tree !== undefined) {
                        // Remove the tree from the vector
                        if (tree.interfaceMenu) {
                            var index = this.activeInterTreeAry.indexOf(tree);
                            if (index > -1) this.activeInterTreeAry.splice(index, 1);
                        } else {
                            var _index2 = this.activeMenuTreeAry.indexOf(tree);
                            if (_index2 > -1) this.activeMenuTreeAry.splice(_index2, 1);
                        }
                    } else {
                        throw new Error('Menu tree doesn\'t exist (' + group + ' - ' + treeStr + ')!');
                    }
                } else {
                    throw new Error('Menu tree group doesn\'t exist (' + group + ' - ' + treeStr + ')!');
                }

                // See if we are still active
                this.setActiveState();
            }

            // 
            //  DESC: Clear the active trees
            //

        }, {
            key: 'clearActiveTrees',
            value: function clearActiveTrees() {
                this.active = false;

                if (this.scrollTimerId !== 0) clearInterval(this.scrollTimerId);

                this.activeMenuTreeAry = [];
                this.activeInterTreeAry = [];
            }

            // 
            //  DESC: Handle input events and dispatch menu events
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                if (this.allow) {
                    // Convert keyboard, mouse and controller messages in action type messages
                    if (event instanceof CustomEvent) {
                        // Are we doing menu actions? May need to do some scrolling
                        if (event.detail.type >= __WEBPACK_IMPORTED_MODULE_8__common_defs__["_17" /* EGE_MENU_UP_ACTION */] && event.detail.type <= __WEBPACK_IMPORTED_MODULE_8__common_defs__["_2" /* EGE_MENU_RIGHT_ACTION */]) {
                            // Free a timer if one happens to be running
                            if (this.scrollTimerId != 0) clearTimeout(this.scrollTimerId);

                            this.scrollTimerId = 0;

                            if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_8__common_defs__["k" /* EAP_DOWN */]) this.handleEventForScrolling(event);
                        }

                        this.handleEventForTrees(event);

                        // Set the active state
                        this.setActiveState();
                    } else {
                        // Only the default tree can execute an escape or toggle when none are active.
                        if (__WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasActionPress(event, this.escapeAction, __WEBPACK_IMPORTED_MODULE_8__common_defs__["k" /* EAP_DOWN */])) {
                            var tree = this.getActiveTree();

                            if (tree === null) __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["Y" /* EGE_MENU_ESCAPE_ACTION */], this.defaultTree);else __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["Y" /* EGE_MENU_ESCAPE_ACTION */], tree.name);
                        } else if (__WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasActionPress(event, this.toggleAction, __WEBPACK_IMPORTED_MODULE_8__common_defs__["k" /* EAP_DOWN */])) {
                            var _tree2 = this.getActiveTree();

                            if (_tree2 === null) __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["_12" /* EGE_MENU_TOGGLE_ACTION */], this.defaultTree);else __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["_12" /* EGE_MENU_TOGGLE_ACTION */], _tree2.name);
                        } else if (this.active) {
                            var pressType = void 0;

                            // common and can result in many messages which is why it's specifically defined here
                            if (event.type === 'mousemove') {
                                // Allow the mouse move message to get eaten when action handling is disabled.
                                this.handleEventForTrees(event);
                            }
                            // Select action based on input device
                            else if ((pressType = __WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasAction(event, this.selectAction)) > __WEBPACK_IMPORTED_MODULE_8__common_defs__["l" /* EAP_IDLE */]) {
                                    if (event instanceof KeyboardEvent) {
                                        __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["_7" /* EGE_MENU_SELECT_ACTION */], pressType, __WEBPACK_IMPORTED_MODULE_8__common_defs__["_56" /* KEYBOARD */]);
                                    } else if (event instanceof MouseEvent) {
                                        __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["_7" /* EGE_MENU_SELECT_ACTION */], pressType, __WEBPACK_IMPORTED_MODULE_8__common_defs__["_57" /* MOUSE */], event.clientX + __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].mouseOffsetX, event.clientY + __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].mouseOffsetY);
                                    }
                                } else if (__WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasActionPress(event, this.backAction, __WEBPACK_IMPORTED_MODULE_8__common_defs__["k" /* EAP_DOWN */])) __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["V" /* EGE_MENU_BACK_ACTION */]);else if ((pressType = __WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasAction(event, this.upAction)) > __WEBPACK_IMPORTED_MODULE_8__common_defs__["l" /* EAP_IDLE */]) __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["_17" /* EGE_MENU_UP_ACTION */], pressType);else if ((pressType = __WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasAction(event, this.downAction)) > __WEBPACK_IMPORTED_MODULE_8__common_defs__["l" /* EAP_IDLE */]) __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["X" /* EGE_MENU_DOWN_ACTION */], pressType);else if ((pressType = __WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasAction(event, this.leftAction)) > __WEBPACK_IMPORTED_MODULE_8__common_defs__["l" /* EAP_IDLE */]) __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["_0" /* EGE_MENU_LEFT_ACTION */], pressType);else if ((pressType = __WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasAction(event, this.rightAction)) > __WEBPACK_IMPORTED_MODULE_8__common_defs__["l" /* EAP_IDLE */]) __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["_2" /* EGE_MENU_RIGHT_ACTION */], pressType);else if ((pressType = __WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasAction(event, this.tabLeft)) > __WEBPACK_IMPORTED_MODULE_8__common_defs__["l" /* EAP_IDLE */]) __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["_10" /* EGE_MENU_TAB_LEFT */], pressType);else if ((pressType = __WEBPACK_IMPORTED_MODULE_1__managers_actionmanager__["a" /* actionManager */].wasAction(event, this.tabRight)) > __WEBPACK_IMPORTED_MODULE_8__common_defs__["l" /* EAP_IDLE */]) __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_8__common_defs__["_11" /* EGE_MENU_TAB_RIGHT */], pressType);

                                // If none of the predefined actions have been hit, just send the message for processing
                                else {
                                        this.handleEventForTrees(event);
                                    }
                        }
                    }
                }
            }

            // 
            //  DESC: Handle input events depending on if this is a menu or interface tree
            //

        }, {
            key: 'handleEventForTrees',
            value: function handleEventForTrees(event) {
                var menuActive = false;

                for (var i = 0; i < this.activeMenuTreeAry.length; ++i) {
                    // See if there's an active tree
                    menuActive |= this.activeMenuTreeAry[i].isActive();

                    // Even if a menu tree is not active, it needs to receive events to become active
                    this.activeMenuTreeAry[i].handleEvent(event);
                }

                // Only allow event handling for interface menus when regular menus are not active
                if (!menuActive) {
                    for (var _i4 = 0; _i4 < this.activeInterTreeAry.length; ++_i4) {
                        if (this.activeInterTreeAry[_i4].isActive()) this.activeInterTreeAry[_i4].handleEvent(event);
                    }
                }
            }

            // 
            //  DESC: Handle input events depending on if this is a menu or interface tree
            //

        }, {
            key: 'handleEventForScrolling',
            value: function handleEventForScrolling(event) {
                if (this.active) {
                    if (!this.handleMenuScrolling(event, this.activeMenuTreeAry)) {
                        // Only allow event handling for interface menus when regular menus are not active
                        this.handleMenuScrolling(event, this.activeInterTreeAry);
                    }
                }
            }

            // 
            //  DESC: Handle input events for menu scrolling
            //

        }, {
            key: 'handleMenuScrolling',
            value: function handleMenuScrolling(event, activeTreeAry) {
                var _this12 = this;

                var menuActive = false;

                for (var i = 0; i < activeTreeAry.length; ++i) {
                    // See if there's an active menu
                    if (activeTreeAry[i].isActive()) {
                        var _ret3 = function () {
                            menuActive = true;

                            var scrollParam = activeTreeAry[i].getScrollParam(event.detail.type);

                            // If scrolling is allowed, start the timer
                            if (scrollParam.canScroll(event.detail.type)) {
                                _this12.scrollTimerId = setTimeout(function () {
                                    _this12.scrollTimerId = setInterval(function () {
                                        return __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(scrollParam.msg);
                                    }, scrollParam.scrollDelay);

                                    __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(scrollParam.msg);
                                }, scrollParam.startDelay);

                                return 'break';
                            }
                        }();

                        if (_ret3 === 'break') break;
                    }
                }

                return menuActive;
            }

            // 
            //  DESC: Update the menu
            //

        }, {
            key: 'update',
            value: function update() {
                if (this.active) {
                    if (!this.updateMenu(this.activeMenuTreeAry)) {
                        // Only allow Updating for interface menus when regular menus are not active
                        this.updateMenu(this.activeInterTreeAry);
                    }
                }
            }

            // 
            //  DESC: Update the menu
            //

        }, {
            key: 'updateMenu',
            value: function updateMenu(activeTreeAry) {
                var menuActive = false;

                for (var i = 0; i < activeTreeAry.length; ++i) {
                    // See if there's an active menu
                    if (activeTreeAry[i].isActive()) {
                        menuActive = true;
                        activeTreeAry[i].update();
                    }
                }

                return menuActive;
            }

            // 
            //  DESC: Transform the menu
            //

        }, {
            key: 'transform',
            value: function transform() {
                if (this.active) {
                    if (!this.transformMenu(this.activeMenuTreeAry)) {
                        // Only allow Updating for interface menus when regular menus are not active
                        this.transformMenu(this.activeInterTreeAry);
                    }
                }
            }

            // 
            //  DESC: Transform the menu
            //

        }, {
            key: 'transformMenu',
            value: function transformMenu(activeTreeAry) {
                var menuActive = false;

                for (var i = 0; i < activeTreeAry.length; ++i) {
                    // See if there's an active menu
                    if (activeTreeAry[i].isActive()) {
                        menuActive = true;
                        activeTreeAry[i].doTransform();
                    }
                }

                return menuActive;
            }

            // 
            //  DESC: Render menus
            //

        }, {
            key: 'render',
            value: function render(matrix) {
                if (this.active) {
                    for (var i = 0; i < this.activeMenuTreeAry.length; ++i) {
                        if (this.activeMenuTreeAry[i].isActive()) this.activeMenuTreeAry[i].render(matrix);
                    }
                }
            }

            // 
            //  DESC: Render interface menus
            //

        }, {
            key: 'renderInterface',
            value: function renderInterface(matrix) {
                if (this.active) {
                    for (var i = 0; i < this.activeInterTreeAry.length; ++i) {
                        if (this.activeInterTreeAry[i].isActive()) this.activeInterTreeAry[i].render(matrix);
                    }
                }
            }

            // 
            //  DESC: Is this standard menu system active?
            //

        }, {
            key: 'isMenuActive',
            value: function isMenuActive() {
                if (this.active) for (var i = 0; i < this.activeMenuTreeAry.length; ++i) {
                    if (this.activeMenuTreeAry[i].isActive()) return true;
                }return false;
            }

            // 
            //  Is a menu item active
            //

        }, {
            key: 'isMenuItemActive',
            value: function isMenuItemActive() {
                var result = false;

                if (this.active) {
                    for (var i = 0; i < this.activeMenuTreeAry.length; ++i) {
                        if (this.activeMenuTreeAry[i].isActive()) {
                            result = this.activeMenuTreeAry[i].isMenuItemActive();

                            break;
                        }
                    }
                }

                return result;
            }

            // 
            //  Is a interface item active
            //

        }, {
            key: 'isInterfaceItemActive',
            value: function isInterfaceItemActive() {
                var result = false;

                if (this.active) {
                    for (var i = 0; i < this.activeInterTreeAry.length; ++i) {
                        if (this.activeInterTreeAry[i].isActive()) {
                            result = this.activeInterTreeAry[i].isMenuItemActive();

                            break;
                        }
                    }
                }

                return result;
            }

            // 
            //  Set the active state
            //

        }, {
            key: 'setActiveState',
            value: function setActiveState() {
                this.active = false;

                for (var i = 0; i < this.activeMenuTreeAry.length; ++i) {
                    if (this.activeMenuTreeAry[i].isActive()) {
                        this.active = true;
                        break;
                    }
                }

                if (!this.active) {
                    for (var _i5 = 0; _i5 < this.activeInterTreeAry.length; ++_i5) {
                        if (this.activeInterTreeAry[_i5].isActive()) {
                            this.active = true;
                            break;
                        }
                    }
                }
            }

            // 
            //  Get the menu in question
            //

        }, {
            key: 'getMenu',
            value: function getMenu(name) {
                var menu = undefined;

                var _iteratorNormalCompletion18 = true;
                var _didIteratorError18 = false;
                var _iteratorError18 = undefined;

                try {
                    for (var _iterator18 = this.menuMapMap.entries()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                        var _step18$value = _slicedToArray(_step18.value, 2),
                            groupKey = _step18$value[0],
                            groupMap = _step18$value[1];

                        menu = groupMap.get(name);
                        if (menu !== undefined) break;
                    }
                } catch (err) {
                    _didIteratorError18 = true;
                    _iteratorError18 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion18 && _iterator18.return) {
                            _iterator18.return();
                        }
                    } finally {
                        if (_didIteratorError18) {
                            throw _iteratorError18;
                        }
                    }
                }

                if (menu === undefined) throw new Error('Menu being asked for is missing (' + name + ')!');

                return menu;
            }

            // 
            //  Get the reference to the control in question
            //

        }, {
            key: 'getMenuControl',
            value: function getMenuControl(name, controlName) {
                var menu = this.getMenu(name);
                var control = menu.getControl(controlName);

                if (control === null) throw new Error('Menu control being asked for is missing (' + name + ')!');

                return control;
            }

            // 
            //  Get the pointer to the active control - can return null
            //

        }, {
            key: 'getActiveControl',
            value: function getActiveControl(name) {
                var menu = this.getMenu(name);
                return menu.GetActiveControl();
            }

            // 
            //  Get the first active menu
            //  NOTE: Only call this function if you are certain it will not fail
            //

        }, {
            key: 'getActiveMenu',
            value: function getActiveMenu() {
                var menu = null;

                for (var i = 0; i < this.activeMenuTreeAry.length; ++i) {
                    if (this.activeMenuTreeAry[i].isActive()) {
                        menu = this.activeMenuTreeAry[i].getActiveMenu();
                        break;
                    }
                }

                if (menu === null) throw new Error('There is no active menu!');

                return menu;
            }

            // 
            //  Get a pointer to the active tree
            //

        }, {
            key: 'getActiveTree',
            value: function getActiveTree() {
                var tree = null;

                for (var i = 0; i < this.activeMenuTreeAry.length; ++i) {
                    if (this.activeMenuTreeAry[i].isActive()) {
                        tree = this.activeMenuTreeAry[i];
                        break;
                    }
                }

                return tree;
            }

            // 
            //  Reset the transform
            //

        }, {
            key: 'resetTransform',
            value: function resetTransform() {
                var _iteratorNormalCompletion19 = true;
                var _didIteratorError19 = false;
                var _iteratorError19 = undefined;

                try {
                    for (var _iterator19 = this.menuMapMap.entries()[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                        var _step19$value = _slicedToArray(_step19.value, 2),
                            groupKey = _step19$value[0],
                            groupMap = _step19$value[1];

                        var _iteratorNormalCompletion20 = true;
                        var _didIteratorError20 = false;
                        var _iteratorError20 = undefined;

                        try {
                            for (var _iterator20 = groupMap.entries()[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                                var _step20$value = _slicedToArray(_step20.value, 2),
                                    key = _step20$value[0],
                                    menu = _step20$value[1];

                                menu.forceTransform();
                            }
                        } catch (err) {
                            _didIteratorError20 = true;
                            _iteratorError20 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion20 && _iterator20.return) {
                                    _iterator20.return();
                                }
                            } finally {
                                if (_didIteratorError20) {
                                    throw _iteratorError20;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError19 = true;
                    _iteratorError19 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion19 && _iterator19.return) {
                            _iterator19.return();
                        }
                    } finally {
                        if (_didIteratorError19) {
                            throw _iteratorError19;
                        }
                    }
                }
            }

            // 
            //  Reset the dynamic positions of menus
            //

        }, {
            key: 'resetDynamicOffset',
            value: function resetDynamicOffset() {
                var _iteratorNormalCompletion21 = true;
                var _didIteratorError21 = false;
                var _iteratorError21 = undefined;

                try {
                    for (var _iterator21 = this.menuMapMap.entries()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                        var _step21$value = _slicedToArray(_step21.value, 2),
                            groupKey = _step21$value[0],
                            groupMap = _step21$value[1];

                        var _iteratorNormalCompletion22 = true;
                        var _didIteratorError22 = false;
                        var _iteratorError22 = undefined;

                        try {
                            for (var _iterator22 = groupMap.entries()[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                                var _step22$value = _slicedToArray(_step22.value, 2),
                                    key = _step22$value[0],
                                    menu = _step22$value[1];

                                menu.resetDynamicPos();
                            }
                        } catch (err) {
                            _didIteratorError22 = true;
                            _iteratorError22 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion22 && _iterator22.return) {
                                    _iterator22.return();
                                }
                            } finally {
                                if (_didIteratorError22) {
                                    throw _iteratorError22;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError21 = true;
                    _iteratorError21 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion21 && _iterator21.return) {
                            _iterator21.return();
                        }
                    } finally {
                        if (_didIteratorError21) {
                            throw _iteratorError21;
                        }
                    }
                }
            }

            // 
            //  DESC: allow event handling access function
            //

        }, {
            key: 'allowEventHandling',
            get: function get() {
                return this.allow;
            },
            set: function set(value) {
                this.allow = value;
            }
        }]);

        return MenuManager;
    }(__WEBPACK_IMPORTED_MODULE_0__managers_managerbase__["a" /* ManagerBase */]);

    var menuManager = new MenuManager();

    /***/
},
/* 25 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_object__ = __webpack_require__(41);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_matrix__ = __webpack_require__(10);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME:  object2d.js
    //  DESC:       object 2D class
    //


    var Object2D = function (_WEBPACK_IMPORTED_MO5) {
        _inherits(Object2D, _WEBPACK_IMPORTED_MO5);

        function Object2D() {
            _classCallCheck(this, Object2D);

            // local matrix
            var _this13 = _possibleConstructorReturn(this, (Object2D.__proto__ || Object.getPrototypeOf(Object2D)).call(this));

            _this13.matrix = new __WEBPACK_IMPORTED_MODULE_1__utilities_matrix__["a" /* Matrix */]();
            return _this13;
        }

        //
        //  DESC: Transform the object in local space
        //


        _createClass(Object2D, [{
            key: 'transformLocal',
            value: function transformLocal(matrix) {
                // Reset the matrices
                matrix.initilizeMatrix();

                // Apply the crop offset
                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_2__common_defs__["f" /* CROP_OFFSET */])) matrix.translateSize(this.cropOffset);

                // Apply the scale
                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_61" /* SCALE */])) this.applyScale(matrix);

                // Apply the rotation
                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_60" /* ROTATE */])) this.applyRotation(matrix);

                // Apply the translation
                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_64" /* TRANSLATE */])) matrix.translate(this.pos);

                // Clear the check parameter
                this.parameters.remove(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_63" /* TRANSFORM */]);

                // Indicate that translation was done
                this.parameters.add(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_66" /* WAS_TRANSFORMED */]);
            }

            //
            //  DESC: Transform
            //
            /*transformBasic()
            {
                this.parameters.remove( defs.WAS_TRANSFORMED );
                 if( this.parameters.isSet( defs.TRANSFORM ) )
                    this.transformLocal( this.matrix );
            }*/

        }, {
            key: 'transform',
            value: function transform() {
                var matrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                var tranformWorldPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

                this.parameters.remove(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_66" /* WAS_TRANSFORMED */]);

                if (matrix) {
                    if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_63" /* TRANSFORM */]) || tranformWorldPos) {
                        this.transformLocal(this.matrix);

                        this.matrix.mergeMatrix(matrix.matrix);
                    }
                } else {
                    if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_63" /* TRANSFORM */])) this.transformLocal(this.matrix);
                }
            }

            //
            //  DESC: Apply the scale
            //

        }, {
            key: 'applyScale',
            value: function applyScale(matrix) {
                this.matrix.setScaleFromPoint(this.scale);
            }

            //
            //  DESC: Apply the scale
            //

        }, {
            key: 'applyRotation',
            value: function applyRotation(matrix) {
                // Add in the center point prior to rotation
                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_2__common_defs__["c" /* CENTER_POINT */])) this.matrix.translate(this.centerPos);

                this.matrix.rotate(this.rot);

                // Subtract the center point after rotation to put back in original position
                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_2__common_defs__["c" /* CENTER_POINT */])) this.matrix.translate(this.centerPos.getInvert());
            }

            //
            //  DESC: Was the world position transformed?
            //

        }, {
            key: 'wasWorldPosTranformed',
            value: function wasWorldPosTranformed() {
                return this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_66" /* WAS_TRANSFORMED */]);
            }

            //
            //  DESC: Was the world position transformed?
            //

        }, {
            key: 'forceTransform',
            value: function forceTransform() {
                this.parameters.Add(__WEBPACK_IMPORTED_MODULE_2__common_defs__["_63" /* TRANSFORM */]);
            }
        }]);

        return Object2D;
    }(__WEBPACK_IMPORTED_MODULE_0__common_object__["a" /* Object */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Object2D;

    /***/
},
/* 26 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME:  vertex2d.js
    //  DESC:       vertex 2d class
    //


    var Vertex2d = function () {
        function Vertex2d() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var u = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var v = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

            _classCallCheck(this, Vertex2d);

            this.data = [x, y, z, u, v];
        }

        _createClass(Vertex2d, [{
            key: 'x',
            set: function set(value) {
                this.data[0] = value;
            },
            get: function get() {
                return this.data[0];
            }
        }, {
            key: 'y',
            set: function set(value) {
                this.data[1] = value;
            },
            get: function get() {
                return this.data[1];
            }
        }, {
            key: 'z',
            set: function set(value) {
                this.data[2] = value;
            },
            get: function get() {
                return this.data[2];
            }
        }, {
            key: 'u',
            set: function set(value) {
                this.data[3] = value;
            },
            get: function get() {
                return this.data[3];
            }
        }, {
            key: 'v',
            set: function set(value) {
                this.data[4] = value;
            },
            get: function get() {
                return this.data[4];
            }
        }]);

        return Vertex2d;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Vertex2d;

    /***/
},
/* 27 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__uicontrol__ = __webpack_require__(17);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__gui_uicontrolnavnode__ = __webpack_require__(44);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__uicontrolfactory__ = __webpack_require__(34);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uisubcontrol.js
    //  DESC:      Class for user interface controls with sub-controls
    //


    var UISubControl = function (_WEBPACK_IMPORTED_MO6) {
        _inherits(UISubControl, _WEBPACK_IMPORTED_MO6);

        function UISubControl(group) {
            _classCallCheck(this, UISubControl);

            var _this14 = _possibleConstructorReturn(this, (UISubControl.__proto__ || Object.getPrototypeOf(UISubControl)).call(this, group));

            _this14.type = __WEBPACK_IMPORTED_MODULE_3__common_defs__["O" /* ECT_SUB_CONTROL */];

            // Arry of sub-controls
            _this14.subControlAry = [];

            // Array list of navigation nodes
            _this14.controlNodeAry = [];

            // Current active node
            // NOTE: This variable does not own it's pointers.
            _this14.activeNode = null;

            // A sub control is a container for other controls so normally
            // it doesn't respont to select messages. There can be a case
            // where this control needs to respond.
            _this14.respondsToSelectMsg = false;
            return _this14;
        }

        // 
        //  DESC: Load the control specific info from XML node
        //


        _createClass(UISubControl, [{
            key: 'loadControlFromNode',
            value: function loadControlFromNode(node) {
                // Have the parent load it's stuff
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'loadControlFromNode', this).call(this, node);

                // Get the sub-control settings
                var subControlSettingsNode = node.getElementsByTagName('subControlSettings');
                if (subControlSettingsNode.length) {
                    // Does this sub control respond to select? The default is false.
                    var attr = subControlSettingsNode[0].getAttribute('respondsToSelectMsg');
                    if (attr === 'true') this.respondsToSelectMsg = true;
                }

                // Get the menu controls node
                var controlListNode = node.getElementsByTagName('subControlList');
                if (controlListNode.length) {
                    // map to help setup the node pointers
                    var navNodeMap = new Map();

                    var controlNode = controlListNode[0].getElementsByTagName('control');

                    for (var i = 0; i < controlNode.length; ++i) {
                        // The reference is placed within an array for all controls
                        var control = __WEBPACK_IMPORTED_MODULE_2__uicontrolfactory__["a" /* create */](controlNode[i], this.group);

                        this.subControlAry.push(control);

                        // Does this control have a name then create a node and add it to the map
                        if (control.name) {
                            // Add a node to the vector with it's control
                            var navNode = new __WEBPACK_IMPORTED_MODULE_1__gui_uicontrolnavnode__["a" /* UIControlNavNode */](control);
                            this.controlNodeAry.push(navNode);

                            // Map of menu control nodes
                            navNodeMap.set(control.name, navNode);
                        }
                    }

                    // Find the reference nodes
                    if (navNodeMap.size > 0) {
                        for (var _i6 = 0; _i6 < controlNode.length; ++_i6) {
                            this.findNodes(controlNode[_i6], _i6, navNodeMap);
                        }
                    }
                }
            }

            // 
            //  DESC: Init the control
            //

        }, {
            key: 'init',
            value: function init() {
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'init', this).call(this);

                // Init all controls
                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].init();
                }
            }

            // 
            //  DESC: Do some cleanup
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'cleanUp', this).call(this);

                // Init all controls
                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].cleanUp();
                }
            }

            // 
            //  DESC: Find the reference nodes
            //

        }, {
            key: 'findNodes',
            value: function findNodes(node, nodeIndex, navNodeMap) {
                var navNode = node.getElementsByTagName('navigate');
                if (navNode.length) {
                    this.setNodes(navNode, nodeIndex, 'up', __WEBPACK_IMPORTED_MODULE_3__common_defs__["_41" /* ENAV_NODE_UP */], navNodeMap);
                    this.setNodes(navNode, nodeIndex, 'down', __WEBPACK_IMPORTED_MODULE_3__common_defs__["_38" /* ENAV_NODE_DOWN */], navNodeMap);
                    this.setNodes(navNode, nodeIndex, 'left', __WEBPACK_IMPORTED_MODULE_3__common_defs__["_39" /* ENAV_NODE_LEFT */], navNodeMap);
                    this.setNodes(navNode, nodeIndex, 'right', __WEBPACK_IMPORTED_MODULE_3__common_defs__["_40" /* ENAV_NODE_RIGHT */], navNodeMap);
                }
            }

            // 
            //  DESC: Find the reference nodes
            //

        }, {
            key: 'setNodes',
            value: function setNodes(node, nodeIndex, attrStr, navId, navNodeMap) {
                var attr = node[0].getAttribute(attrStr);
                if (attr) {
                    var ctrlNode = navNodeMap.get(attr);
                    if (ctrlNode !== undefined) this.controlNodeAry[nodeIndex].setNode(navId, ctrlNode);else throw new Error('Control node doesn\'t exist! (' + name + ')');
                }
            }

            // 
            //  DESC: Update the control
            //

        }, {
            key: 'update',
            value: function update() {
                // Call the parent
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'update', this).call(this);

                // Update all controls
                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].update();
                }
            }

            // 
            //  DESC: Transform the control
            //

        }, {
            key: 'doTransform',
            value: function doTransform(object) {
                // Call the parent
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'doTransform', this).call(this, object);

                // Update all controls
                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].doTransform(this);
                }
            }

            // 
            //  DESC: Render the sub control
            //

        }, {
            key: 'render',
            value: function render(matrix) {
                // Call the parent
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'render', this).call(this, matrix);

                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].render(matrix);
                }
            }

            // 
            //  DESC: Handle events
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                // Call the parent
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'handleEvent', this).call(this, event);

                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].handleEvent(event);
                }if (this.isActive() && event instanceof CustomEvent) {
                    if (event.detail.type >= __WEBPACK_IMPORTED_MODULE_3__common_defs__["_17" /* EGE_MENU_UP_ACTION */] && event.detail.type <= __WEBPACK_IMPORTED_MODULE_3__common_defs__["_2" /* EGE_MENU_RIGHT_ACTION */]) {
                        if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["_17" /* EGE_MENU_UP_ACTION */]) {
                            this.onUpAction(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["X" /* EGE_MENU_DOWN_ACTION */]) {
                            this.onDownAction(event);
                        }
                        if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["_0" /* EGE_MENU_LEFT_ACTION */]) {
                            this.onLeftAction(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["_2" /* EGE_MENU_RIGHT_ACTION */]) {
                            this.onRightAction(event);
                        }
                    } else if (event.detail.type >= __WEBPACK_IMPORTED_MODULE_3__common_defs__["_6" /* EGE_MENU_SCROLL_UP */] && event.detail.type <= __WEBPACK_IMPORTED_MODULE_3__common_defs__["_5" /* EGE_MENU_SCROLL_RIGHT */]) {
                        if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["_6" /* EGE_MENU_SCROLL_UP */]) {
                            this.onUpScroll(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["_3" /* EGE_MENU_SCROLL_DOWN */]) {
                            this.onDownScroll(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["_4" /* EGE_MENU_SCROLL_LEFT */]) {
                            this.onLeftScroll(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["_5" /* EGE_MENU_SCROLL_RIGHT */]) {
                            this.onRightScroll(event);
                        }
                    } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["_10" /* EGE_MENU_TAB_LEFT */]) {
                        this.onTabLeft(event);
                    } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__common_defs__["_11" /* EGE_MENU_TAB_RIGHT */]) {
                        this.onTabRight(event);
                    }
                }
            }

            // 
            //  DESC: Handle OnUpAction message
            //

        }, {
            key: 'onUpAction',
            value: function onUpAction(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_3__common_defs__["_41" /* ENAV_NODE_UP */]);
            }

            // 
            //  DESC: Handle OnMenuDown message
            //

        }, {
            key: 'onDownAction',
            value: function onDownAction(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_3__common_defs__["_38" /* ENAV_NODE_DOWN */]);
            }

            // 
            //  DESC: Handle OnMenuLeft message
            //

        }, {
            key: 'onLeftAction',
            value: function onLeftAction(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_3__common_defs__["_39" /* ENAV_NODE_LEFT */]);
            }

            // 
            //  DESC: Handle OnRightAction message
            //

        }, {
            key: 'onRightAction',
            value: function onRightAction(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_3__common_defs__["_40" /* ENAV_NODE_RIGHT */]);
            }

            // 
            //  DESC: Handle OnUpScroll message
            //

        }, {
            key: 'onUpScroll',
            value: function onUpScroll(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_3__common_defs__["_41" /* ENAV_NODE_UP */]);
            }

            // 
            //  DESC: Handle OnUpScroll message
            //

        }, {
            key: 'onDownScroll',
            value: function onDownScroll(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_3__common_defs__["_38" /* ENAV_NODE_DOWN */]);
            }

            // 
            //  DESC: Handle OnRightScroll message
            //

        }, {
            key: 'onLeftScroll',
            value: function onLeftScroll(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_3__common_defs__["_39" /* ENAV_NODE_LEFT */]);
            }

            // 
            //  DESC: Handle OnRightScroll message
            //

        }, {
            key: 'onRightScroll',
            value: function onRightScroll(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_3__common_defs__["_40" /* ENAV_NODE_RIGHT */]);
            }

            // 
            //  DESC: Handle OnTabLeft message
            //

        }, {
            key: 'onTabLeft',
            value: function onTabLeft(event) {}
            // Do nothing


            // 
            //  DESC: Handle OnTabRight message
            //

        }, {
            key: 'onTabRight',
            value: function onTabRight(event) {}
            // Do nothing


            // 
            //  DESC: Navigate the menu. Find the next control node that isn't
            //        disabled and make it the active control node
            //

        }, {
            key: 'navigateMenu',
            value: function navigateMenu(navNode) {
                if (this.activeNode !== null) {
                    var _navNode = this.activeNode;

                    do {
                        _navNode = _navNode.getNode(_navNode);

                        if (_navNode === null) {
                            break;
                        } else if (!_navNode.uiControl.isDisabled()) {
                            this.activeNode = _navNode;

                            eventManager.dispatchEvent(__WEBPACK_IMPORTED_MODULE_3__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_3__common_defs__["A" /* ECS_ACTIVE */], _navNode.uiControl);

                            break;
                        }
                    } while (true);
                }
            }

            // 
            //  DESC: Handle OnStateChange message
            //

        }, {
            key: 'onStateChange',
            value: function onStateChange(event) {
                if (this.respondsToSelectMsg) {
                    _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'onStateChange', this).call(this, event);
                } else {
                    var state = event.detail.arg[__WEBPACK_IMPORTED_MODULE_3__common_defs__["_28" /* EMSC_STATE */]];

                    var ctrl = this.findSubControlByRef(event.detail.arg[__WEBPACK_IMPORTED_MODULE_3__common_defs__["_27" /* EMSC_CONTROL */]]);

                    // Restart the active state of the sub control if something
                    // changed in the child controls or their children controls
                    if (state === __WEBPACK_IMPORTED_MODULE_3__common_defs__["A" /* ECS_ACTIVE */] && ctrl !== null) {
                        if (ctrl.state != state) {
                            this.setState(state, true);

                            this.resetSpriteScript();

                            this.setDisplayState();
                        }
                    }
                    // The sub control doesn't respond to selected message
                    else if (state < __WEBPACK_IMPORTED_MODULE_3__common_defs__["F" /* ECS_SELECTED */]) _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'onStateChange', this).call(this, event);
                }
            }

            // 
            //  DESC: Reset and recycle the contexts
            //

        }, {
            key: 'reset',
            value: function reset(complete) {
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'reset', this).call(this, complete);

                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].reset(complete);
                }
            }

            // 
            //  DESC: Handle the mouse move
            //

        }, {
            key: 'onMouseMove',
            value: function onMouseMove(event) {
                var result = _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'onMouseMove', this).call(this, event);

                var found = this.onSubControlMouseMove(event);

                // If the sub control is not found, deactivate them
                if (result && !found) this.deactivateSubControl();

                return result || found;
            }

            // 
            //  DESC: Handle the sub control mouse move
            //

        }, {
            key: 'onSubControlMouseMove',
            value: function onSubControlMouseMove(event) {
                var result = false;

                for (var i = 0; i < this.subControlAry.length && !result; ++i) {
                    result = this.subControlAry[i].onMouseMove(event);
                }return result;
            }

            // 
            //  DESC: Handle the select action
            //

        }, {
            key: 'handleSelectAction',
            value: function handleSelectAction(event) {
                if (this.respondsToSelectMsg) {
                    return _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'handleSelectAction', this).call(this, event);
                } else {
                    for (var i = 0; i < this.subControlAry.length; ++i) {
                        if (this.subControlAry[i].handleSelectAction(event)) return true;
                    }
                }

                return false;
            }

            // 
            //  DESC: Get the reference to the control if found
            //

        }, {
            key: 'findControlByName',
            value: function findControlByName(name) {
                var ctrl = _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'findControlByName', this).call(this, name);

                if (ctrl === null) ctrl = this.findSubControlByName(name);

                return ctrl;
            }
        }, {
            key: 'findControlByRef',
            value: function findControlByRef(control) {
                var ctrl = _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'findControlByRef', this).call(this, control);

                if (ctrl === null) ctrl = this.findSubControlByRef(control);

                return ctrl;
            }

            // 
            //  DESC: Get the pointer to the subcontrol if found
            //

        }, {
            key: 'findSubControlByName',
            value: function findSubControlByName(name) {
                var ctrl = null;

                for (var i = 0; i < this.subControlAry.length && !ctrl; ++i) {
                    ctrl = this.subControlAry[i].findControlByName(name);
                }return ctrl;
            }
        }, {
            key: 'findSubControlByRef',
            value: function findSubControlByRef(control) {
                var ctrl = null;

                for (var i = 0; i < this.subControlAry.length && !ctrl; ++i) {
                    ctrl = this.subControlAry[i].findControlByRef(control);
                }return ctrl;
            }

            // 
            //  DESC: Set the first inactive control to be active
            //  NOTE: This is mainly here to be virtual for sub controls
            //

        }, {
            key: 'activateFirstInactiveControl',
            value: function activateFirstInactiveControl() {
                if (_get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'activateFirstInactiveControl', this).call(this)) {
                    var found = false;

                    for (var i = 0; i < this.controlNodeAry.length; ++i) {
                        if (!found && this.controlNodeAry[i].uiControl.activateFirstInactiveControl()) {
                            this.activeNode = controlNodeAry[i];

                            found = true;
                        } else {
                            this.controlNodeAry[i].uiControl.deactivateControl();
                        }
                    }

                    return true;
                }

                return false;
            }
        }, {
            key: 'baseActivateFirstInactiveControl',
            value: function baseActivateFirstInactiveControl() {
                return _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'activateFirstInactiveControl', this).call(this);
            }

            // 
            //  DESC: Deactivate the control
            //

        }, {
            key: 'deactivateControl',
            value: function deactivateControl() {
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'deactivateControl', this).call(this);

                this.deactivateSubControl();
            }

            // 
            //  DESC: Deactivate the sub control
            //

        }, {
            key: 'deactivateSubControl',
            value: function deactivateSubControl() {
                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].deactivateControl();
                }
            }

            // 
            //  DESC: Check if control is a sub control
            //

        }, {
            key: 'isSubControl',
            value: function isSubControl() {
                return true;
            }

            // 
            //  DESC: Disable the control
            //

        }, {
            key: 'disableControl',
            value: function disableControl() {
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'disableControl', this).call(this);

                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].disableControl();
                }
            }

            // 
            //  DESC: Enable the control to the inactive state
            //

        }, {
            key: 'enableControl',
            value: function enableControl() {
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'enableControl', this).call(this);

                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].enableControl();
                }
            }

            // 
            //  DESC: Set the alpha value of this control
            //

        }, {
            key: 'setAlpha',
            value: function setAlpha(alpha) {
                _get(UISubControl.prototype.__proto__ || Object.getPrototypeOf(UISubControl.prototype), 'setAlpha', this).call(this, alpha);

                for (var i = 0; i < this.subControlAry.length; ++i) {
                    this.subControlAry[i].setAlpha(alpha);
                }
            }

            // 
            //  DESC: Get the pointer to the active control
            //  NOTE: This is mostly needed for sub controls
            //

        }, {
            key: 'getActiveControl',
            value: function getActiveControl() {
                var result = null;

                for (var i = 0; i < this.subControlAry.length; ++i) {
                    if (this.subControlAry[i].getState() > __WEBPACK_IMPORTED_MODULE_3__common_defs__["C" /* ECS_INACTIVE */]) {
                        result = this.subControlAry[i].getActiveControl();
                        break;
                    }
                }

                return result;
            }
        }]);

        return UISubControl;
    }(__WEBPACK_IMPORTED_MODULE_0__uicontrol__["a" /* UIControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UISubControl;

    /***/
},
/* 28 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return loadManager;
    });

    // 
    //  FILE NAME: loadmanager.js
    //  DESC:      LoadManager class
    //


    var LoadManager = function () {
        function LoadManager() {
            _classCallCheck(this, LoadManager);

            this.objects = [];
            this.loadCompleteCallback = null;
        }

        _createClass(LoadManager, [{
            key: 'add',
            value: function add(obj) {
                this.objects.push(obj);
            }
        }, {
            key: 'load',
            value: function load() {
                if (this.objects.length === 0) {
                    if (this.loadCompleteCallback === null) throw new Error('LoadManager: Load complete callback has not been set!');else this.loadCompleteCallback();
                } else {
                    var obj = this.objects.shift();
                    obj(this.load.bind(this));
                }
            }
        }]);

        return LoadManager;
    }();

    var loadManager = new LoadManager();

    /***/
},
/* 29 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return meshManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_uv__ = __webpack_require__(57);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__common_meshbinaryfileheader__ = __webpack_require__(58);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__common_mesh3d__ = __webpack_require__(59);

    //
    //  FILE NAME: meshmanager.js
    //  DESC:      mesh manager class singleton
    //


    var MeshManager = function () {
        function MeshManager() {
            _classCallCheck(this, MeshManager);

            // Map containing a group array of vbo, ibo and texture id's
            this.meshBufMapMap = new Map();

            // Map for collision mesh
            //this.collisionMeshBufMapMap = new Map;

            // Current vbo
            this.currentVBO = null;

            // Current IBO ID
            this.currentIBO = null;

            // counter for indexing into binary data when loading
            this.counter = 0;
        }

        //
        //  DESC: Load the binary mesh data
        //  NOTE: To keep it simple, loading the textures is done seperately
        //


        _createClass(MeshManager, [{
            key: 'load',
            value: function load(group, filePath, binaryData) {
                // Create the group map if it doesn't already exist
                var groupMap = this.meshBufMapMap.get(group);
                if (groupMap === undefined) {
                    groupMap = new Map();
                    this.meshBufMapMap.set(group, groupMap);
                }

                var meshGrp = groupMap.get(filePath);
                if (meshGrp === undefined) {
                    meshGrp = new __WEBPACK_IMPORTED_MODULE_4__common_mesh3d__["b" /* MeshGroup */]();
                    groupMap.set(filePath, meshGrp);

                    this.loadData(group, filePath, binaryData, meshGrp);
                }

                return meshGrp;
            }

            //
            //  DESC: Load the binary mesh data
            //

        }, {
            key: 'loadData',
            value: function loadData(group, filePath, binaryData, meshGrp) {
                this.counter = 0;

                // Load the binary data into the data view for easy access to different data types
                var dataView = new DataView(binaryData);

                // Load the binary mesh file header
                var fileHeader = this.loadFileHeader(dataView, group, filePath);

                // Check to insure we are in the correct spot in the binary file
                this.tagCheck(dataView, fileHeader.text_count > 0, group, filePath);

                // Load the texture file paths
                this.loadTexturePaths(dataView, fileHeader, meshGrp);

                // Check to insure we are in the correct spot in the binary file
                this.tagCheck(dataView, true, group, filePath);

                // Load the verts
                var vertAry = [];
                this.loadVerts(dataView, fileHeader, vertAry);

                // Check to insure we are in the correct spot in the binary file
                this.tagCheck(dataView, true, group, filePath);

                // Load the normals
                var normAry = [];
                this.loadNormals(dataView, fileHeader, normAry);

                // Check to insure we are in the correct spot in the binary file
                this.tagCheck(dataView, fileHeader.uv_count > 0, group, filePath);

                // Load the uv's
                var uvAry = [];
                this.loadUVs(dataView, fileHeader, uvAry);

                // Build the meshes
                this.buildMeshes(dataView, group, filePath, fileHeader, meshGrp, vertAry, normAry, uvAry);
            }

            //
            //  DESC: Load the binary mesh file header
            //

        }, {
            key: 'loadFileHeader',
            value: function loadFileHeader(dataView, group, filePath) {
                var fileHeader = new __WEBPACK_IMPORTED_MODULE_3__common_meshbinaryfileheader__["e" /* MeshBinaryFileHeader */]();

                fileHeader.file_header = dataView.getUint32(this.counter, true);this.counter += 4;
                fileHeader.vert_count = dataView.getUint16(this.counter, true);this.counter += 2;
                fileHeader.uv_count = dataView.getUint16(this.counter, true);this.counter += 2;
                fileHeader.vert_norm_count = dataView.getUint16(this.counter, true);this.counter += 2;
                fileHeader.face_group_count = dataView.getUint16(this.counter, true);this.counter += 2;
                fileHeader.text_count = dataView.getUint16(this.counter, true);this.counter += 2;
                fileHeader.joint_count = dataView.getUint16(this.counter, true);this.counter += 2;

                // Check to make sure we're loading in the right kind of file
                if (fileHeader.file_header !== __WEBPACK_IMPORTED_MODULE_3__common_meshbinaryfileheader__["d" /* MESH_FILE_HEADER */]) throw new Error('File header mismatch! (' + group + ', ' + filePath + ').');

                return fileHeader;
            }

            //
            //  DESC: Load the binary mesh file header
            //

        }, {
            key: 'loadTexturePaths',
            value: function loadTexturePaths(dataView, fileHeader, meshGrp) {
                for (var i = 0; i < fileHeader.text_count; ++i) {
                    var uniqueTextAry = new __WEBPACK_IMPORTED_MODULE_3__common_meshbinaryfileheader__["b" /* BinaryTexture */]();
                    meshGrp.uniqueTexturePathAry.push(uniqueTextAry);

                    uniqueTextAry.type = dataView.getInt8(this.counter, true);this.counter += 1;

                    for (var j = 0; j < __WEBPACK_IMPORTED_MODULE_3__common_meshbinaryfileheader__["g" /* TEXT_PATH_SIZE */]; ++j) {
                        var charCode = dataView.getInt8(this.counter, true);this.counter += 1;

                        if (charCode) {
                            uniqueTextAry.path += String.fromCharCode(charCode);
                        } else {
                            this.counter += __WEBPACK_IMPORTED_MODULE_3__common_meshbinaryfileheader__["g" /* TEXT_PATH_SIZE */] - j - 1;
                            break;
                        }
                    }
                }
            }

            //
            //  DESC: Load the verts
            //

        }, {
            key: 'loadVerts',
            value: function loadVerts(dataView, fileHeader, vertAry) {
                // Load the verts
                for (var i = 0; i < fileHeader.vert_count; ++i) {
                    var data = [0, 0, 0];
                    vertAry.push(data);

                    for (var j = 0; j < 3; ++j) {
                        data[j] = dataView.getFloat32(this.counter, true);this.counter += 4;
                    }
                }
            }

            //
            //  DESC: Load the normals
            //

        }, {
            key: 'loadNormals',
            value: function loadNormals(dataView, fileHeader, normAry) {
                for (var i = 0; i < fileHeader.vert_norm_count; ++i) {
                    var data = [0, 0, 0];
                    normAry.push(data);

                    for (var j = 0; j < 3; ++j) {
                        data[j] = dataView.getFloat32(this.counter, true);this.counter += 4;
                    }
                }
            }

            //
            //  DESC: Load the uv's
            //

        }, {
            key: 'loadUVs',
            value: function loadUVs(dataView, fileHeader, uvAry) {
                // Load the normals
                for (var i = 0; i < fileHeader.uv_count; ++i) {
                    var data = [0, 0];
                    uvAry.push(data);

                    for (var j = 0; j < 2; ++j) {
                        data[j] = dataView.getFloat32(this.counter, true);this.counter += 4;
                    }
                }
            }

            //
            //  DESC: Build the meshes
            //

        }, {
            key: 'buildMeshes',
            value: function buildMeshes(dataView, group, filePath, fileHeader, meshGrp, vertAry, normAry, uvAry) {
                var faceGroup = new __WEBPACK_IMPORTED_MODULE_3__common_meshbinaryfileheader__["a" /* BinaryFaceGroup */]();

                // Read in each face group
                for (var i = 0; i < fileHeader.face_group_count; ++i) {
                    // Check to insure we are in the correct spot in the binary file
                    this.tagCheck(dataView, true, group, filePath);

                    // Allocate the mesh storage
                    var mesh = new __WEBPACK_IMPORTED_MODULE_4__common_mesh3d__["a" /* Mesh */]();
                    meshGrp.meshAry.push(mesh);

                    faceGroup.groupFaceCount = dataView.getUint16(this.counter, true);this.counter += 2;
                    faceGroup.vertexBufCount = dataView.getUint16(this.counter, true);this.counter += 2;
                    faceGroup.indexBufCount = dataView.getUint16(this.counter, true);this.counter += 2;
                    faceGroup.textureCount = dataView.getUint16(this.counter, true);this.counter += 2;

                    // Read in the indexes that are the textures
                    for (var j = 0; j < faceGroup.textureCount; ++j) {
                        mesh.textureIndexAry.push(dataView.getUint16(this.counter, true));
                        this.counter += 2;
                    }

                    // Read in the indexes used to create the VBO
                    var vertBufAry = [];
                    for (var _j = 0; _j < faceGroup.vertexBufCount; ++_j) {
                        var binaryVertex = new __WEBPACK_IMPORTED_MODULE_3__common_meshbinaryfileheader__["c" /* BinaryVertex */]();
                        vertBufAry.push(binaryVertex);

                        binaryVertex.vert = dataView.getUint16(this.counter, true);this.counter += 2;
                        binaryVertex.norm = dataView.getUint16(this.counter, true);this.counter += 2;

                        if (fileHeader.uv_count) {
                            binaryVertex.uv = dataView.getUint16(this.counter, true);this.counter += 2;
                        }
                    }

                    // Read in the indexes that are the IBO
                    var iboAry = [];
                    for (var _j2 = 0; _j2 < faceGroup.indexBufCount; ++_j2) {
                        iboAry.push(dataView.getUint16(this.counter, true));
                        this.counter += 2;
                    }

                    // Create a temporary array for building the VBO
                    var vboAry = [];

                    // Build the VBO
                    for (var _j3 = 0; _j3 < faceGroup.vertexBufCount; ++_j3) {
                        Array.prototype.push.apply(vboAry, vertAry[vertBufAry[_j3].vert]);
                        Array.prototype.push.apply(vboAry, normAry[vertBufAry[_j3].norm]);

                        if (fileHeader.uv_count) Array.prototype.push.apply(vboAry, uvAry[vertBufAry[_j3].uv]);
                    }

                    // Create the vbo
                    mesh.vbo = __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].createBuffer();
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, mesh.vbo);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bufferData(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, new Float32Array(vboAry), __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].STATIC_DRAW);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, null);

                    // Create the ibo
                    mesh.ibo = __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].createBuffer();
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, mesh.ibo);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bufferData(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, new Uint16Array(iboAry), __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].STATIC_DRAW);
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, null);

                    // Save the number of indexes in the IBO buffer - Will need this for the render call
                    mesh.iboCount = faceGroup.indexBufCount;
                }
            }

            //
            //  DESC: Load the binary mesh file header
            //

        }, {
            key: 'tagCheck',
            value: function tagCheck(dataView, allowCheck, group, filePath) {
                if (allowCheck) {
                    var tag = dataView.getUint32(this.counter, true);this.counter += 4;
                    if (tag !== __WEBPACK_IMPORTED_MODULE_3__common_meshbinaryfileheader__["f" /* TAG_CHECK */]) throw new Error('Tag check mismatch! (' + group + ', ' + filePath + ').');
                }
            }

            //
            //  DESC: Delete the group of textures
            //

        }, {
            key: 'deleteGroup',
            value: function deleteGroup(group) {
                var groupMap = this.meshBufMapMap.get(group);
                if (groupMap !== undefined) {
                    var _iteratorNormalCompletion23 = true;
                    var _didIteratorError23 = false;
                    var _iteratorError23 = undefined;

                    try {
                        for (var _iterator23 = groupMap.entries()[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                            var _step23$value = _slicedToArray(_step23.value, 2),
                                key = _step23$value[0],
                                meshGrp = _step23$value[1];

                            for (var i = 0; i < meshGrp.meshAry.length; ++i) {
                                __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].deleteBuffer(meshGrp.meshAry[i].vbo);
                                __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].deleteBuffer(meshGrp.meshAry[i].ibo);
                            }
                        }
                    } catch (err) {
                        _didIteratorError23 = true;
                        _iteratorError23 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion23 && _iterator23.return) {
                                _iterator23.return();
                            }
                        } finally {
                            if (_didIteratorError23) {
                                throw _iteratorError23;
                            }
                        }
                    }

                    this.meshBufMapMap.delete(group);
                }
            }

            //
            //  DESC: Bind the buffers
            //

        }, {
            key: 'bind',
            value: function bind(vbo, ibo) {
                if (this.currentVBO != vbo) {
                    // save the current binding
                    this.currentVBO = vbo;

                    // Have OpenGL bind this buffer now
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, vbo);
                }

                if (this.currentIBO != ibo) {
                    // save the current binding
                    this.currentIBO = ibo;

                    // Have OpenGL bind this buffer now
                    __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, ibo);
                }
            }

            //
            //  DESC: Bind the buffers
            //

        }, {
            key: 'unbind',
            value: function unbind() {
                this.currentVBO = null;
                this.currentIBO = null;
                __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ARRAY_BUFFER, null);
                __WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_0__system_device__["b" /* gl */].ELEMENT_ARRAY_BUFFER, null);
            }
        }]);

        return MeshManager;
    }();

    var meshManager = new MeshManager();

    /***/
},
/* 30 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__utilities_bitmask__ = __webpack_require__(31);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__common_defs__ = __webpack_require__(0);
    // 
    //  FILE NAME: dynamicoffset.js
    //  DESC:      Dynamic Offset class
    //


    var DynamicOffset = function () {
        function DynamicOffset() {
            _classCallCheck(this, DynamicOffset);

            // bit mask parameters
            this.parameters = new __WEBPACK_IMPORTED_MODULE_0__utilities_bitmask__["a" /* BitMask */]();

            // offset
            this.point = new __WEBPACK_IMPORTED_MODULE_1__point__["a" /* Point */]();
        }

        // 
        //  DESC: Add to the bit mask
        //


        _createClass(DynamicOffset, [{
            key: 'add',
            value: function add(value) {
                this.parameters.add(value);
            }

            // 
            //  Set/Get X
            //

        }, {
            key: 'setX',
            value: function setX(value) {
                this.point.x = value;
            }
        }, {
            key: 'setY',
            value: function setY(value) {
                this.point.y = value;
            }

            // 
            //  DESC: Is the dynamic offset being used
            //

        }, {
            key: 'isEmpty',
            value: function isEmpty() {
                return this.parameters.isEmpty();
            }

            // 
            //  DESC: Get the dynamic position
            //

        }, {
            key: 'getPos',
            value: function getPos(defaultHalfSize) {
                var pos = new __WEBPACK_IMPORTED_MODULE_1__point__["a" /* Point */]();

                var halfSize = new __WEBPACK_IMPORTED_MODULE_2__size__["a" /* Size */](defaultHalfSize.w, defaultHalfSize.h);

                // Strip out any fractional component for correct rendering
                halfSize.round();

                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["R" /* EDO_LEFT */])) pos.x = -(halfSize.w - this.point.x);else if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["S" /* EDO_RIGHT */])) pos.x = halfSize.w - this.point.x;else if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["Q" /* EDO_HORZ_CENTER */])) pos.x = this.point.x;

                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["T" /* EDO_TOP */])) pos.y = halfSize.h - this.point.y;else if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["P" /* EDO_BOTTOM */])) pos.y = -(halfSize.h - this.point.y);else if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["U" /* EDO_VERT_CENTER */])) pos.y = this.point.y;

                return pos;
            }
        }]);

        return DynamicOffset;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = DynamicOffset;

    /***/
},
/* 31 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME: bitmask.js
    //  DESC:      Class to handle a bit mask
    //


    var BitMask = function () {
        function BitMask() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            _classCallCheck(this, BitMask);

            this.bitmask = value;
        }

        // 
        //  DESC: Add the parameters to the bitmask
        //


        _createClass(BitMask, [{
            key: 'add',
            value: function add(args) {
                this.bitmask |= args;
            }

            // 
            //  DESC: Remove the parameters from the bitmask
            //

        }, {
            key: 'remove',
            value: function remove(args) {
                this.bitmask &= args ^ -1;
            }

            // 
            //  DESC: Remove all parameters except for the ones passed in
            //

        }, {
            key: 'removeAllExcept',
            value: function removeAllExcept(args) {
                this.bitmask &= args;
            }

            // 
            //  DESC: Set the bitmask to zero
            //

        }, {
            key: 'clear',
            value: function clear() {
                this.bitmask = 0;
            }

            // 
            //  DESC: Check if all of the parameters are set
            //

        }, {
            key: 'isEmpty',
            value: function isEmpty() {
                return this.bitmask === 0;
            }

            // 
            //  DESC: Check if one of the parameters is set
            //

        }, {
            key: 'isSet',
            value: function isSet(args) {
                return (this.bitmask & args) !== 0;
            }

            // 
            //  DESC: Check if all of the parameters are set
            //

        }, {
            key: 'areAllSet',
            value: function areAllSet(args) {
                return (this.bitmask & args) === args;
            }

            // 
            //  DESC: Get a copy of the bitmask including the parameters
            //

        }, {
            key: 'getIncluding',
            value: function getIncluding(args) {
                return this.bitmask | args;
            }

            // 
            //  DESC: Get a copy of the bitmask excluding the parameters
            //

        }, {
            key: 'getExcluding',
            value: function getExcluding(args) {
                return this.bitmask & (args ^ -1);
            }
        }]);

        return BitMask;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = BitMask;

    /***/
},
/* 32 */
/***/function (module, exports, __webpack_require__) {

    var require;var require; /*
                             * Planck.js v0.1.34
                             * 
                             * Copyright (c) 2016-2017 Ali Shakiba http://shakiba.me/planck.js
                             * Copyright (c) 2006-2013 Erin Catto  http://www.gphysics.com
                             * 
                             * This software is provided 'as-is', without any express or implied
                             * warranty.  In no event will the authors be held liable for any damages
                             * arising from the use of this software.
                             * 
                             * Permission is granted to anyone to use this software for any purpose,
                             * including commercial applications, and to alter it and redistribute it
                             * freely, subject to the following restrictions:
                             * 
                             * 1. The origin of this software must not be misrepresented; you must not
                             * claim that you wrote the original software. If you use this software
                             * in a product, an acknowledgment in the product documentation would be
                             * appreciated but is not required.
                             * 2. Altered source versions must be plainly marked as such, and must not be
                             * misrepresented as being the original software.
                             * 3. This notice may not be removed or altered from any source distribution.
                             */
    !function (e) {
        if (true) module.exports = e();else if ("function" == typeof define && define.amd) define([], e);else {
            var f;"undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.planck = e();
        }
    }(function () {
        var define, module, exports;return function e(t, n, r) {
            function s(o, u) {
                if (!n[o]) {
                    if (!t[o]) {
                        var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
                    }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                        var n = t[o][1][e];return s(n ? n : e);
                    }, l, l.exports, e, t, n, r);
                }return n[o].exports;
            }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
                s(r[o]);
            }return s;
        }({ 1: [function (require, module, exports) {
                exports.internal = {};

                exports.Math = require("./common/Math");

                exports.Vec2 = require("./common/Vec2");

                exports.Transform = require("./common/Transform");

                exports.Rot = require("./common/Rot");

                exports.AABB = require("./collision/AABB");

                exports.Shape = require("./Shape");

                exports.Fixture = require("./Fixture");

                exports.Body = require("./Body");

                exports.Contact = require("./Contact");

                exports.Joint = require("./Joint");

                exports.World = require("./World");

                exports.Circle = require("./shape/CircleShape");

                exports.Edge = require("./shape/EdgeShape");

                exports.Polygon = require("./shape/PolygonShape");

                exports.Chain = require("./shape/ChainShape");

                exports.Box = require("./shape/BoxShape");

                require("./shape/CollideCircle");

                require("./shape/CollideEdgeCircle");

                exports.internal.CollidePolygons = require("./shape/CollidePolygon");

                require("./shape/CollideCirclePolygone");

                require("./shape/CollideEdgePolygon");

                exports.DistanceJoint = require("./joint/DistanceJoint");

                exports.FrictionJoint = require("./joint/FrictionJoint");

                exports.GearJoint = require("./joint/GearJoint");

                exports.MotorJoint = require("./joint/MotorJoint");

                exports.MouseJoint = require("./joint/MouseJoint");

                exports.PrismaticJoint = require("./joint/PrismaticJoint");

                exports.PulleyJoint = require("./joint/PulleyJoint");

                exports.RevoluteJoint = require("./joint/RevoluteJoint");

                exports.RopeJoint = require("./joint/RopeJoint");

                exports.WeldJoint = require("./joint/WeldJoint");

                exports.WheelJoint = require("./joint/WheelJoint");

                exports.internal.Sweep = require("./common/Sweep");

                exports.internal.stats = require("./common/stats");

                exports.internal.Manifold = require("./Manifold");

                exports.internal.Distance = require("./collision/Distance");

                exports.internal.TimeOfImpact = require("./collision/TimeOfImpact");

                exports.internal.DynamicTree = require("./collision/DynamicTree");

                exports.internal.Settings = require("./Settings");
            }, { "./Body": 2, "./Contact": 3, "./Fixture": 4, "./Joint": 5, "./Manifold": 6, "./Settings": 7, "./Shape": 8, "./World": 10, "./collision/AABB": 11, "./collision/Distance": 13, "./collision/DynamicTree": 14, "./collision/TimeOfImpact": 15, "./common/Math": 18, "./common/Rot": 20, "./common/Sweep": 21, "./common/Transform": 22, "./common/Vec2": 23, "./common/stats": 26, "./joint/DistanceJoint": 27, "./joint/FrictionJoint": 28, "./joint/GearJoint": 29, "./joint/MotorJoint": 30, "./joint/MouseJoint": 31, "./joint/PrismaticJoint": 32, "./joint/PulleyJoint": 33, "./joint/RevoluteJoint": 34, "./joint/RopeJoint": 35, "./joint/WeldJoint": 36, "./joint/WheelJoint": 37, "./shape/BoxShape": 38, "./shape/ChainShape": 39, "./shape/CircleShape": 40, "./shape/CollideCircle": 41, "./shape/CollideCirclePolygone": 42, "./shape/CollideEdgeCircle": 43, "./shape/CollideEdgePolygon": 44, "./shape/CollidePolygon": 45, "./shape/EdgeShape": 46, "./shape/PolygonShape": 47 }], 2: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Body;

                var common = require("./util/common");

                var options = require("./util/options");

                var Vec2 = require("./common/Vec2");

                var Rot = require("./common/Rot");

                var Math = require("./common/Math");

                var Sweep = require("./common/Sweep");

                var Transform = require("./common/Transform");

                var Velocity = require("./common/Velocity");

                var Position = require("./common/Position");

                var Fixture = require("./Fixture");

                var Shape = require("./Shape");

                var World = require("./World");

                var staticBody = Body.STATIC = "static";

                var kinematicBody = Body.KINEMATIC = "kinematic";

                var dynamicBody = Body.DYNAMIC = "dynamic";

                /**
                 * @typedef {Object} BodyDef
                 *
                 * @prop type Body types are static, kinematic, or dynamic. Note: if a dynamic
                 *       body would have zero mass, the mass is set to one.
                 *
                 * @prop position The world position of the body. Avoid creating bodies at the
                 *       origin since this can lead to many overlapping shapes.
                 *
                 * @prop angle The world angle of the body in radians.
                 *
                 * @prop linearVelocity The linear velocity of the body's origin in world
                 *       co-ordinates.
                 *
                 * @prop linearDamping Linear damping is use to reduce the linear velocity. The
                 *       damping parameter can be larger than 1.0 but the damping effect becomes
                 *       sensitive to the time step when the damping parameter is large.
                 *
                 * @prop angularDamping Angular damping is use to reduce the angular velocity.
                 *       The damping parameter can be larger than 1.0 but the damping effect
                 *       becomes sensitive to the time step when the damping parameter is large.
                 *
                 * @prop fixedRotation Should this body be prevented from rotating? Useful for
                 *       characters.
                 *
                 * @prop bullet Is this a fast moving body that should be prevented from
                 *       tunneling through other moving bodies? Note that all bodies are
                 *       prevented from tunneling through kinematic and static bodies. This
                 *       setting is only considered on dynamic bodies. Warning: You should use
                 *       this flag sparingly since it increases processing time.
                 *
                 * @prop active Does this body start out active?
                 *
                 * @prop awake Is this body initially awake or sleeping?
                 *
                 * @prop allowSleep Set this flag to false if this body should never fall
                 *       asleep. Note that this increases CPU usage.
                 */
                var BodyDef = {
                    type: staticBody,
                    position: Vec2.zero(),
                    angle: 0,
                    linearVelocity: Vec2.zero(),
                    angularVelocity: 0,
                    linearDamping: 0,
                    angularDamping: 0,
                    fixedRotation: false,
                    bullet: false,
                    gravityScale: 1,
                    allowSleep: true,
                    awake: true,
                    active: true,
                    userData: null
                };

                /**
                 * @class
                 * 
                 * A rigid body composed of one or more fixtures.
                 * 
                 * @param {BodyDef} def
                 */
                function Body(world, def) {
                    def = options(def, BodyDef);
                    //ASSERT && common.assert(Vec2.isValid(def.position));
                    //ASSERT && common.assert(Vec2.isValid(def.linearVelocity));
                    //ASSERT && common.assert(Math.isFinite(def.angle));
                    //ASSERT && common.assert(Math.isFinite(def.angularVelocity));
                    //ASSERT && common.assert(Math.isFinite(def.angularDamping) && def.angularDamping >= 0);
                    //ASSERT && common.assert(Math.isFinite(def.linearDamping) && def.linearDamping >= 0);
                    this.m_world = world;
                    this.m_awakeFlag = def.awake;
                    this.m_autoSleepFlag = def.allowSleep;
                    this.m_bulletFlag = def.bullet;
                    this.m_fixedRotationFlag = def.fixedRotation;
                    this.m_activeFlag = def.active;
                    this.m_islandFlag = false;
                    this.m_toiFlag = false;
                    this.m_userData = def.userData;
                    this.m_type = def.type;
                    if (this.m_type == dynamicBody) {
                        this.m_mass = 1;
                        this.m_invMass = 1;
                    } else {
                        this.m_mass = 0;
                        this.m_invMass = 0;
                    }
                    // Rotational inertia about the center of mass.
                    this.m_I = 0;
                    this.m_invI = 0;
                    // the body origin transform
                    this.m_xf = Transform.identity();
                    this.m_xf.p = Vec2.clone(def.position);
                    this.m_xf.q.setAngle(def.angle);
                    // the swept motion for CCD
                    this.m_sweep = new Sweep();
                    this.m_sweep.setTransform(this.m_xf);
                    // position and velocity correction
                    this.c_velocity = new Velocity();
                    this.c_position = new Position();
                    this.m_force = Vec2.zero();
                    this.m_torque = 0;
                    this.m_linearVelocity = Vec2.clone(def.linearVelocity);
                    this.m_angularVelocity = def.angularVelocity;
                    this.m_linearDamping = def.linearDamping;
                    this.m_angularDamping = def.angularDamping;
                    this.m_gravityScale = def.gravityScale;
                    this.m_sleepTime = 0;
                    this.m_jointList = null;
                    this.m_contactList = null;
                    this.m_fixtureList = null;
                    this.m_prev = null;
                    this.m_next = null;
                }

                Body.prototype.isWorldLocked = function () {
                    return this.m_world && this.m_world.isLocked() ? true : false;
                };

                Body.prototype.getWorld = function () {
                    return this.m_world;
                };

                Body.prototype.getNext = function () {
                    return this.m_next;
                };

                Body.prototype.setUserData = function (data) {
                    this.m_userData = data;
                };

                Body.prototype.getUserData = function () {
                    return this.m_userData;
                };

                Body.prototype.getFixtureList = function () {
                    return this.m_fixtureList;
                };

                Body.prototype.getJointList = function () {
                    return this.m_jointList;
                };

                /**
                 * Warning: this list changes during the time step and you may miss some
                 * collisions if you don't use ContactListener.
                 */
                Body.prototype.getContactList = function () {
                    return this.m_contactList;
                };

                Body.prototype.isStatic = function () {
                    return this.m_type == staticBody;
                };

                Body.prototype.isDynamic = function () {
                    return this.m_type == dynamicBody;
                };

                Body.prototype.isKinematic = function () {
                    return this.m_type == kinematicBody;
                };

                /**
                 * This will alter the mass and velocity.
                 */
                Body.prototype.setStatic = function () {
                    this.setType(staticBody);
                    return this;
                };

                Body.prototype.setDynamic = function () {
                    this.setType(dynamicBody);
                    return this;
                };

                Body.prototype.setKinematic = function () {
                    this.setType(kinematicBody);
                    return this;
                };

                /**
                 * @private
                 */
                Body.prototype.getType = function () {
                    return this.m_type;
                };

                /**
                 * 
                 * @private
                 */
                Body.prototype.setType = function (type) {
                    //ASSERT && common.assert(type === staticBody || type === kinematicBody || type === dynamicBody);
                    //ASSERT && common.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return;
                    }
                    if (this.m_type == type) {
                        return;
                    }
                    this.m_type = type;
                    this.resetMassData();
                    if (this.m_type == staticBody) {
                        this.m_linearVelocity.setZero();
                        this.m_angularVelocity = 0;
                        this.m_sweep.forward();
                        this.synchronizeFixtures();
                    }
                    this.setAwake(true);
                    this.m_force.setZero();
                    this.m_torque = 0;
                    // Delete the attached contacts.
                    var ce = this.m_contactList;
                    while (ce) {
                        var ce0 = ce;
                        ce = ce.next;
                        this.m_world.destroyContact(ce0.contact);
                    }
                    this.m_contactList = null;
                    // Touch the proxies so that new contacts will be created (when appropriate)
                    var broadPhase = this.m_world.m_broadPhase;
                    for (var f = this.m_fixtureList; f; f = f.m_next) {
                        var proxyCount = f.m_proxyCount;
                        for (var i = 0; i < proxyCount; ++i) {
                            broadPhase.touchProxy(f.m_proxies[i].proxyId);
                        }
                    }
                };

                Body.prototype.isBullet = function () {
                    return this.m_bulletFlag;
                };

                /**
                 * Should this body be treated like a bullet for continuous collision detection?
                 */
                Body.prototype.setBullet = function (flag) {
                    this.m_bulletFlag = !!flag;
                };

                Body.prototype.isSleepingAllowed = function () {
                    return this.m_autoSleepFlag;
                };

                Body.prototype.setSleepingAllowed = function (flag) {
                    this.m_autoSleepFlag = !!flag;
                    if (this.m_autoSleepFlag == false) {
                        this.setAwake(true);
                    }
                };

                Body.prototype.isAwake = function () {
                    return this.m_awakeFlag;
                };

                /**
                 * Set the sleep state of the body. A sleeping body has very low CPU cost.
                 * 
                 * @param flag Set to true to wake the body, false to put it to sleep.
                 */
                Body.prototype.setAwake = function (flag) {
                    if (flag) {
                        if (this.m_awakeFlag == false) {
                            this.m_awakeFlag = true;
                            this.m_sleepTime = 0;
                        }
                    } else {
                        this.m_awakeFlag = false;
                        this.m_sleepTime = 0;
                        this.m_linearVelocity.setZero();
                        this.m_angularVelocity = 0;
                        this.m_force.setZero();
                        this.m_torque = 0;
                    }
                };

                Body.prototype.isActive = function () {
                    return this.m_activeFlag;
                };

                /**
                 * Set the active state of the body. An inactive body is not simulated and
                 * cannot be collided with or woken up. If you pass a flag of true, all fixtures
                 * will be added to the broad-phase. If you pass a flag of false, all fixtures
                 * will be removed from the broad-phase and all contacts will be destroyed.
                 * Fixtures and joints are otherwise unaffected.
                 * 
                 * You may continue to create/destroy fixtures and joints on inactive bodies.
                 * Fixtures on an inactive body are implicitly inactive and will not participate
                 * in collisions, ray-casts, or queries. Joints connected to an inactive body
                 * are implicitly inactive. An inactive body is still owned by a World object
                 * and remains
                 */
                Body.prototype.setActive = function (flag) {
                    //ASSERT && common.assert(this.isWorldLocked() == false);
                    if (flag == this.m_activeFlag) {
                        return;
                    }
                    this.m_activeFlag = !!flag;
                    if (this.m_activeFlag) {
                        // Create all proxies.
                        var broadPhase = this.m_world.m_broadPhase;
                        for (var f = this.m_fixtureList; f; f = f.m_next) {
                            f.createProxies(broadPhase, this.m_xf);
                        }
                    } else {
                        // Destroy all proxies.
                        var broadPhase = this.m_world.m_broadPhase;
                        for (var f = this.m_fixtureList; f; f = f.m_next) {
                            f.destroyProxies(broadPhase);
                        }
                        // Destroy the attached contacts.
                        var ce = this.m_contactList;
                        while (ce) {
                            var ce0 = ce;
                            ce = ce.next;
                            this.m_world.destroyContact(ce0.contact);
                        }
                        this.m_contactList = null;
                    }
                };

                Body.prototype.isFixedRotation = function () {
                    return this.m_fixedRotationFlag;
                };

                /**
                 * Set this body to have fixed rotation. This causes the mass to be reset.
                 */
                Body.prototype.setFixedRotation = function (flag) {
                    if (this.m_fixedRotationFlag == flag) {
                        return;
                    }
                    this.m_fixedRotationFlag = !!flag;
                    this.m_angularVelocity = 0;
                    this.resetMassData();
                };

                /**
                 * Get the world transform for the body's origin.
                 */
                Body.prototype.getTransform = function () {
                    return this.m_xf;
                };

                /**
                 * Set the position of the body's origin and rotation. Manipulating a body's
                 * transform may cause non-physical behavior. Note: contacts are updated on the
                 * next call to World.step.
                 * 
                 * @param position The world position of the body's local origin.
                 * @param angle The world rotation in radians.
                 */
                Body.prototype.setTransform = function (position, angle) {
                    //ASSERT && common.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return;
                    }
                    this.m_xf.set(position, angle);
                    this.m_sweep.setTransform(this.m_xf);
                    var broadPhase = this.m_world.m_broadPhase;
                    for (var f = this.m_fixtureList; f; f = f.m_next) {
                        f.synchronize(broadPhase, this.m_xf, this.m_xf);
                    }
                };

                Body.prototype.synchronizeTransform = function () {
                    this.m_sweep.getTransform(this.m_xf, 1);
                };

                /**
                 * Update fixtures in broad-phase.
                 */
                Body.prototype.synchronizeFixtures = function () {
                    var xf = Transform.identity();
                    this.m_sweep.getTransform(xf, 0);
                    var broadPhase = this.m_world.m_broadPhase;
                    for (var f = this.m_fixtureList; f; f = f.m_next) {
                        f.synchronize(broadPhase, xf, this.m_xf);
                    }
                };

                /**
                 * Used in TOI.
                 */
                Body.prototype.advance = function (alpha) {
                    // Advance to the new safe time. This doesn't sync the broad-phase.
                    this.m_sweep.advance(alpha);
                    this.m_sweep.c.set(this.m_sweep.c0);
                    this.m_sweep.a = this.m_sweep.a0;
                    this.m_sweep.getTransform(this.m_xf, 1);
                };

                /**
                 * Get the world position for the body's origin.
                 */
                Body.prototype.getPosition = function () {
                    return this.m_xf.p;
                };

                Body.prototype.setPosition = function (p) {
                    this.setTransform(p, this.m_sweep.a);
                };

                /**
                 * Get the current world rotation angle in radians.
                 */
                Body.prototype.getAngle = function () {
                    return this.m_sweep.a;
                };

                Body.prototype.setAngle = function (angle) {
                    this.setTransform(this.m_xf.p, angle);
                };

                /**
                 * Get the world position of the center of mass.
                 */
                Body.prototype.getWorldCenter = function () {
                    return this.m_sweep.c;
                };

                /**
                 * Get the local position of the center of mass.
                 */
                Body.prototype.getLocalCenter = function () {
                    return this.m_sweep.localCenter;
                };

                /**
                 * Get the linear velocity of the center of mass.
                 * 
                 * @return the linear velocity of the center of mass.
                 */
                Body.prototype.getLinearVelocity = function () {
                    return this.m_linearVelocity;
                };

                /**
                 * Get the world linear velocity of a world point attached to this body.
                 * 
                 * @param worldPoint A point in world coordinates.
                 */
                Body.prototype.getLinearVelocityFromWorldPoint = function (worldPoint) {
                    var localCenter = Vec2.sub(worldPoint, this.m_sweep.c);
                    return Vec2.add(this.m_linearVelocity, Vec2.cross(this.m_angularVelocity, localCenter));
                };

                /**
                 * Get the world velocity of a local point.
                 * 
                 * @param localPoint A point in local coordinates.
                 */
                Body.prototype.getLinearVelocityFromLocalPoint = function (localPoint) {
                    return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));
                };

                /**
                 * Set the linear velocity of the center of mass.
                 * 
                 * @param v The new linear velocity of the center of mass.
                 */
                Body.prototype.setLinearVelocity = function (v) {
                    if (this.m_type == staticBody) {
                        return;
                    }
                    if (Vec2.dot(v, v) > 0) {
                        this.setAwake(true);
                    }
                    this.m_linearVelocity.set(v);
                };

                /**
                 * Get the angular velocity.
                 * 
                 * @returns the angular velocity in radians/second.
                 */
                Body.prototype.getAngularVelocity = function () {
                    return this.m_angularVelocity;
                };

                /**
                 * Set the angular velocity.
                 * 
                 * @param omega The new angular velocity in radians/second.
                 */
                Body.prototype.setAngularVelocity = function (w) {
                    if (this.m_type == staticBody) {
                        return;
                    }
                    if (w * w > 0) {
                        this.setAwake(true);
                    }
                    this.m_angularVelocity = w;
                };

                Body.prototype.getLinearDamping = function () {
                    return this.m_linearDamping;
                };

                Body.prototype.setLinearDamping = function (linearDamping) {
                    this.m_linearDamping = linearDamping;
                };

                Body.prototype.getAngularDamping = function () {
                    return this.m_angularDamping;
                };

                Body.prototype.setAngularDamping = function (angularDamping) {
                    this.m_angularDamping = angularDamping;
                };

                Body.prototype.getGravityScale = function () {
                    return this.m_gravityScale;
                };

                /**
                 * Scale the gravity applied to this body.
                 */
                Body.prototype.setGravityScale = function (scale) {
                    this.m_gravityScale = scale;
                };

                /**
                 * Get the total mass of the body.
                 * 
                 * @returns The mass, usually in kilograms (kg).
                 */
                Body.prototype.getMass = function () {
                    return this.m_mass;
                };

                /**
                 * Get the rotational inertia of the body about the local origin.
                 * 
                 * @return the rotational inertia, usually in kg-m^2.
                 */
                Body.prototype.getInertia = function () {
                    return this.m_I + this.m_mass * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);
                };

                /**
                 * @typedef {Object} MassData This holds the mass data computed for a shape.
                 * 
                 * @prop mass The mass of the shape, usually in kilograms.
                 * @prop center The position of the shape's centroid relative to the shape's
                 *       origin.
                 * @prop I The rotational inertia of the shape about the local origin.
                 */
                function MassData() {
                    this.mass = 0;
                    this.center = Vec2.zero();
                    this.I = 0;
                }

                /**
                 * Copy the mass data of the body to data.
                 */
                Body.prototype.getMassData = function (data) {
                    data.mass = this.m_mass;
                    data.I = this.getInertia();
                    data.center.set(this.m_sweep.localCenter);
                };

                /**
                 * This resets the mass properties to the sum of the mass properties of the
                 * fixtures. This normally does not need to be called unless you called
                 * SetMassData to override the mass and you later want to reset the mass.
                 */
                Body.prototype.resetMassData = function () {
                    // Compute mass data from shapes. Each shape has its own density.
                    this.m_mass = 0;
                    this.m_invMass = 0;
                    this.m_I = 0;
                    this.m_invI = 0;
                    this.m_sweep.localCenter.setZero();
                    // Static and kinematic bodies have zero mass.
                    if (this.isStatic() || this.isKinematic()) {
                        this.m_sweep.c0.set(this.m_xf.p);
                        this.m_sweep.c.set(this.m_xf.p);
                        this.m_sweep.a0 = this.m_sweep.a;
                        return;
                    }
                    //ASSERT && common.assert(this.isDynamic());
                    // Accumulate mass over all fixtures.
                    var localCenter = Vec2.zero();
                    for (var f = this.m_fixtureList; f; f = f.m_next) {
                        if (f.m_density == 0) {
                            continue;
                        }
                        var massData = new MassData();
                        f.getMassData(massData);
                        this.m_mass += massData.mass;
                        localCenter.wAdd(massData.mass, massData.center);
                        this.m_I += massData.I;
                    }
                    // Compute center of mass.
                    if (this.m_mass > 0) {
                        this.m_invMass = 1 / this.m_mass;
                        localCenter.mul(this.m_invMass);
                    } else {
                        // Force all dynamic bodies to have a positive mass.
                        this.m_mass = 1;
                        this.m_invMass = 1;
                    }
                    if (this.m_I > 0 && this.m_fixedRotationFlag == false) {
                        // Center the inertia about the center of mass.
                        this.m_I -= this.m_mass * Vec2.dot(localCenter, localCenter);
                        //ASSERT && common.assert(this.m_I > 0);
                        this.m_invI = 1 / this.m_I;
                    } else {
                        this.m_I = 0;
                        this.m_invI = 0;
                    }
                    // Move center of mass.
                    var oldCenter = Vec2.clone(this.m_sweep.c);
                    this.m_sweep.setLocalCenter(localCenter, this.m_xf);
                    // Update center of mass velocity.
                    this.m_linearVelocity.add(Vec2.cross(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));
                };

                /**
                 * Set the mass properties to override the mass properties of the fixtures. Note
                 * that this changes the center of mass position. Note that creating or
                 * destroying fixtures can also alter the mass. This function has no effect if
                 * the body isn't dynamic.
                 * 
                 * @param massData The mass properties.
                 */
                Body.prototype.setMassData = function (massData) {
                    //ASSERT && common.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return;
                    }
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    this.m_invMass = 0;
                    this.m_I = 0;
                    this.m_invI = 0;
                    this.m_mass = massData.mass;
                    if (this.m_mass <= 0) {
                        this.m_mass = 1;
                    }
                    this.m_invMass = 1 / this.m_mass;
                    if (massData.I > 0 && this.m_fixedRotationFlag == false) {
                        this.m_I = massData.I - this.m_mass * Vec2.dot(massData.center, massData.center);
                        //ASSERT && common.assert(this.m_I > 0);
                        this.m_invI = 1 / this.m_I;
                    }
                    // Move center of mass.
                    var oldCenter = Vec2.clone(this.m_sweep.c);
                    this.m_sweep.setLocalCenter(massData.center, this.m_xf);
                    // Update center of mass velocity.
                    this.m_linearVelocity.add(Vec2.cross(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));
                };

                /**
                 * Apply a force at a world point. If the force is not applied at the center of
                 * mass, it will generate a torque and affect the angular velocity. This wakes
                 * up the body.
                 * 
                 * @param force The world force vector, usually in Newtons (N).
                 * @param point The world position of the point of application.
                 * @param wake Also wake up the body
                 */
                Body.prototype.applyForce = function (force, point, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate a force if the body is sleeping.
                    if (this.m_awakeFlag) {
                        this.m_force.add(force);
                        this.m_torque += Vec2.cross(Vec2.sub(point, this.m_sweep.c), force);
                    }
                };

                /**
                 * Apply a force to the center of mass. This wakes up the body.
                 * 
                 * @param force The world force vector, usually in Newtons (N).
                 * @param wake Also wake up the body
                 */
                Body.prototype.applyForceToCenter = function (force, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate a force if the body is sleeping
                    if (this.m_awakeFlag) {
                        this.m_force.add(force);
                    }
                };

                /**
                 * Apply a torque. This affects the angular velocity without affecting the
                 * linear velocity of the center of mass. This wakes up the body.
                 * 
                 * @param torque About the z-axis (out of the screen), usually in N-m.
                 * @param wake Also wake up the body
                 */
                Body.prototype.applyTorque = function (torque, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate a force if the body is sleeping
                    if (this.m_awakeFlag) {
                        this.m_torque += torque;
                    }
                };

                /**
                 * Apply an impulse at a point. This immediately modifies the velocity. It also
                 * modifies the angular velocity if the point of application is not at the
                 * center of mass. This wakes up the body.
                 * 
                 * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.
                 * @param point The world position of the point of application.
                 * @param wake Also wake up the body
                 */
                Body.prototype.applyLinearImpulse = function (impulse, point, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate velocity if the body is sleeping
                    if (this.m_awakeFlag) {
                        this.m_linearVelocity.wAdd(this.m_invMass, impulse);
                        this.m_angularVelocity += this.m_invI * Vec2.cross(Vec2.sub(point, this.m_sweep.c), impulse);
                    }
                };

                /**
                 * Apply an angular impulse.
                 * 
                 * @param impulse The angular impulse in units of kg*m*m/s
                 * @param wake Also wake up the body
                 */
                Body.prototype.applyAngularImpulse = function (impulse, wake) {
                    if (this.m_type != dynamicBody) {
                        return;
                    }
                    if (wake && this.m_awakeFlag == false) {
                        this.setAwake(true);
                    }
                    // Don't accumulate velocity if the body is sleeping
                    if (this.m_awakeFlag) {
                        this.m_angularVelocity += this.m_invI * impulse;
                    }
                };

                /**
                 * This is used to prevent connected bodies (by joints) from colliding,
                 * depending on the joint's collideConnected flag.
                 */
                Body.prototype.shouldCollide = function (that) {
                    // At least one body should be dynamic.
                    if (this.m_type != dynamicBody && that.m_type != dynamicBody) {
                        return false;
                    }
                    // Does a joint prevent collision?
                    for (var jn = this.m_jointList; jn; jn = jn.next) {
                        if (jn.other == that) {
                            if (jn.joint.m_collideConnected == false) {
                                return false;
                            }
                        }
                    }
                    return true;
                };

                /**
                 * Creates a fixture and attach it to this body.
                 * 
                 * If the density is non-zero, this function automatically updates the mass of
                 * the body.
                 * 
                 * Contacts are not created until the next time step.
                 * 
                 * Warning: This function is locked during callbacks.
                
                 * @param {Shape|FixtureDef} shape Shape or fixture definition.
                 * @param {FixtureDef|number} fixdef Fixture definition or just density.
                 */
                Body.prototype.createFixture = function (shape, fixdef) {
                    //ASSERT && common.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return null;
                    }
                    var fixture = new Fixture(this, shape, fixdef);
                    if (this.m_activeFlag) {
                        var broadPhase = this.m_world.m_broadPhase;
                        fixture.createProxies(broadPhase, this.m_xf);
                    }
                    fixture.m_next = this.m_fixtureList;
                    this.m_fixtureList = fixture;
                    // Adjust mass properties if needed.
                    if (fixture.m_density > 0) {
                        this.resetMassData();
                    }
                    // Let the world know we have a new fixture. This will cause new contacts
                    // to be created at the beginning of the next time step.
                    this.m_world.m_newFixture = true;
                    return fixture;
                };

                /**
                 * Destroy a fixture. This removes the fixture from the broad-phase and destroys
                 * all contacts associated with this fixture. This will automatically adjust the
                 * mass of the body if the body is dynamic and the fixture has positive density.
                 * All fixtures attached to a body are implicitly destroyed when the body is
                 * destroyed.
                 * 
                 * Warning: This function is locked during callbacks.
                 * 
                 * @param fixture The fixture to be removed.
                 */
                Body.prototype.destroyFixture = function (fixture) {
                    //ASSERT && common.assert(this.isWorldLocked() == false);
                    if (this.isWorldLocked() == true) {
                        return;
                    }
                    //ASSERT && common.assert(fixture.m_body == this);
                    // Remove the fixture from this body's singly linked list.
                    var node = this.m_fixtureList;
                    var found = false;
                    while (node != null) {
                        if (node == fixture) {
                            node = fixture.m_next;
                            found = true;
                            break;
                        }
                        node = node.m_next;
                    }
                    // You tried to remove a shape that is not attached to this body.
                    //ASSERT && common.assert(found);
                    // Destroy any contacts associated with the fixture.
                    var edge = this.m_contactList;
                    while (edge) {
                        var c = edge.contact;
                        edge = edge.next;
                        var fixtureA = c.getFixtureA();
                        var fixtureB = c.getFixtureB();
                        if (fixture == fixtureA || fixture == fixtureB) {
                            // This destroys the contact and removes it from
                            // this body's contact list.
                            this.m_world.destroyContact(c);
                        }
                    }
                    if (this.m_activeFlag) {
                        var broadPhase = this.m_world.m_broadPhase;
                        fixture.destroyProxies(broadPhase);
                    }
                    fixture.m_body = null;
                    fixture.m_next = null;
                    this.m_world.publish("remove-fixture", fixture);
                    // Reset the mass data.
                    this.resetMassData();
                };

                /**
                 * Get the corresponding world point of a local point.
                 */
                Body.prototype.getWorldPoint = function (localPoint) {
                    return Transform.mul(this.m_xf, localPoint);
                };

                /**
                 * Get the corresponding world vector of a local vector.
                 */
                Body.prototype.getWorldVector = function (localVector) {
                    return Rot.mul(this.m_xf.q, localVector);
                };

                /**
                 * Gets the corresponding local point of a world point.
                 */
                Body.prototype.getLocalPoint = function (worldPoint) {
                    return Transform.mulT(this.m_xf, worldPoint);
                };

                /**
                 * 
                 * Gets the corresponding local vector of a world vector.
                 */
                Body.prototype.getLocalVector = function (worldVector) {
                    return Rot.mulT(this.m_xf.q, worldVector);
                };
            }, { "./Fixture": 4, "./Shape": 8, "./World": 10, "./common/Math": 18, "./common/Position": 19, "./common/Rot": 20, "./common/Sweep": 21, "./common/Transform": 22, "./common/Vec2": 23, "./common/Velocity": 25, "./util/common": 50, "./util/options": 52 }], 3: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var DEBUG_SOLVER = false;

                var common = require("./util/common");

                var Math = require("./common/Math");

                var Vec2 = require("./common/Vec2");

                var Transform = require("./common/Transform");

                var Mat22 = require("./common/Mat22");

                var Rot = require("./common/Rot");

                var Settings = require("./Settings");

                var Manifold = require("./Manifold");

                var Distance = require("./collision/Distance");

                module.exports = Contact;

                /**
                 * A contact edge is used to connect bodies and contacts together in a contact
                 * graph where each body is a node and each contact is an edge. A contact edge
                 * belongs to a doubly linked list maintained in each attached body. Each
                 * contact has two contact nodes, one for each attached body.
                 * 
                 * @prop {Contact} contact The contact
                 * @prop {ContactEdge} prev The previous contact edge in the body's contact list
                 * @prop {ContactEdge} next The next contact edge in the body's contact list
                 * @prop {Body} other Provides quick access to the other body attached.
                 */
                function ContactEdge(contact) {
                    this.contact = contact;
                    this.prev;
                    this.next;
                    this.other;
                }

                /**
                 * @function Contact~evaluate
                 * 
                 * @param manifold
                 * @param xfA
                 * @param fixtureA
                 * @param indexA
                 * @param xfB
                 * @param fixtureB
                 * @param indexB
                 */
                /**
                 * The class manages contact between two shapes. A contact exists for each
                 * overlapping AABB in the broad-phase (except if filtered). Therefore a contact
                 * object may exist that has no contact points.
                 * 
                 * @param {Fixture} fA
                 * @param {int} indexA
                 * @param {Fixture} fB
                 * @param {int} indexB
                 * @param {Contact~evaluate} evaluateFcn
                 */
                function Contact(fA, indexA, fB, indexB, evaluateFcn) {
                    // Nodes for connecting bodies.
                    this.m_nodeA = new ContactEdge(this);
                    this.m_nodeB = new ContactEdge(this);
                    this.m_fixtureA = fA;
                    this.m_fixtureB = fB;
                    this.m_indexA = indexA;
                    this.m_indexB = indexB;
                    this.m_evaluateFcn = evaluateFcn;
                    this.m_manifold = new Manifold();
                    this.m_prev = null;
                    this.m_next = null;
                    this.m_toi = 1;
                    this.m_toiCount = 0;
                    // This contact has a valid TOI in m_toi
                    this.m_toiFlag = false;
                    this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
                    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
                    this.m_tangentSpeed = 0;
                    // This contact can be disabled (by user)
                    this.m_enabledFlag = true;
                    // Used when crawling contact graph when forming islands.
                    this.m_islandFlag = false;
                    // Set when the shapes are touching.
                    this.m_touchingFlag = false;
                    // This contact needs filtering because a fixture filter was changed.
                    this.m_filterFlag = false;
                    // This bullet contact had a TOI event
                    this.m_bulletHitFlag = false;
                    this.v_points = [];
                    // VelocityConstraintPoint[maxManifoldPoints]
                    this.v_normal = Vec2.zero();
                    this.v_normalMass = new Mat22();
                    this.v_K = new Mat22();
                    this.v_pointCount;
                    this.v_tangentSpeed;
                    this.v_friction;
                    this.v_restitution;
                    this.v_invMassA;
                    this.v_invMassB;
                    this.v_invIA;
                    this.v_invIB;
                    this.p_localPoints = [];
                    // Vec2[maxManifoldPoints];
                    this.p_localNormal = Vec2.zero();
                    this.p_localPoint = Vec2.zero();
                    this.p_localCenterA = Vec2.zero();
                    this.p_localCenterB = Vec2.zero();
                    this.p_type;
                    // Manifold.Type
                    this.p_radiusA;
                    this.p_radiusB;
                    this.p_pointCount;
                    this.p_invMassA;
                    this.p_invMassB;
                    this.p_invIA;
                    this.p_invIB;
                }

                Contact.prototype.initConstraint = function (step) {
                    var fixtureA = this.m_fixtureA;
                    var fixtureB = this.m_fixtureB;
                    var shapeA = fixtureA.getShape();
                    var shapeB = fixtureB.getShape();
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    var manifold = this.getManifold();
                    var pointCount = manifold.pointCount;
                    //ASSERT && common.assert(pointCount > 0);
                    this.v_invMassA = bodyA.m_invMass;
                    this.v_invMassB = bodyB.m_invMass;
                    this.v_invIA = bodyA.m_invI;
                    this.v_invIB = bodyB.m_invI;
                    this.v_friction = this.m_friction;
                    this.v_restitution = this.m_restitution;
                    this.v_tangentSpeed = this.m_tangentSpeed;
                    this.v_pointCount = pointCount;
                    //DEBUG && common.debug("pc", this.v_pointCount, pointCount);
                    this.v_K.setZero();
                    this.v_normalMass.setZero();
                    this.p_invMassA = bodyA.m_invMass;
                    this.p_invMassB = bodyB.m_invMass;
                    this.p_invIA = bodyA.m_invI;
                    this.p_invIB = bodyB.m_invI;
                    this.p_localCenterA = Vec2.clone(bodyA.m_sweep.localCenter);
                    this.p_localCenterB = Vec2.clone(bodyB.m_sweep.localCenter);
                    this.p_radiusA = shapeA.m_radius;
                    this.p_radiusB = shapeB.m_radius;
                    this.p_type = manifold.type;
                    this.p_localNormal = Vec2.clone(manifold.localNormal);
                    this.p_localPoint = Vec2.clone(manifold.localPoint);
                    this.p_pointCount = pointCount;
                    for (var j = 0; j < pointCount; ++j) {
                        var cp = manifold.points[j];
                        // ManifoldPoint
                        var vcp = this.v_points[j] = new VelocityConstraintPoint();
                        if (step.warmStarting) {
                            vcp.normalImpulse = step.dtRatio * cp.normalImpulse;
                            vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;
                        } else {
                            vcp.normalImpulse = 0;
                            vcp.tangentImpulse = 0;
                        }
                        vcp.rA.setZero();
                        vcp.rB.setZero();
                        vcp.normalMass = 0;
                        vcp.tangentMass = 0;
                        vcp.velocityBias = 0;
                        this.p_localPoints[j] = Vec2.clone(cp.localPoint);
                    }
                };

                /**
                 * Get the contact manifold. Do not modify the manifold unless you understand
                 * the internals of the library.
                 */
                Contact.prototype.getManifold = function () {
                    return this.m_manifold;
                };

                /**
                 * Get the world manifold.
                 * 
                 * @param {WorldManifold} [worldManifold]
                 */
                Contact.prototype.getWorldManifold = function (worldManifold) {
                    var bodyA = this.m_fixtureA.getBody();
                    var bodyB = this.m_fixtureB.getBody();
                    var shapeA = this.m_fixtureA.getShape();
                    var shapeB = this.m_fixtureB.getShape();
                    return this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);
                };

                /**
                 * Enable/disable this contact. This can be used inside the pre-solve contact
                 * listener. The contact is only disabled for the current time step (or sub-step
                 * in continuous collisions).
                 */
                Contact.prototype.setEnabled = function (flag) {
                    this.m_enabledFlag = !!flag;
                };

                /**
                 * Has this contact been disabled?
                 */
                Contact.prototype.isEnabled = function () {
                    return this.m_enabledFlag;
                };

                /**
                 * Is this contact touching?
                 */
                Contact.prototype.isTouching = function () {
                    return this.m_touchingFlag;
                };

                /**
                 * Get the next contact in the world's contact list.
                 */
                Contact.prototype.getNext = function () {
                    return this.m_next;
                };

                /**
                 * Get fixture A in this contact.
                 */
                Contact.prototype.getFixtureA = function () {
                    return this.m_fixtureA;
                };

                /**
                 * Get fixture B in this contact.
                 */
                Contact.prototype.getFixtureB = function () {
                    return this.m_fixtureB;
                };

                /**
                 * Get the child primitive index for fixture A.
                 */
                Contact.prototype.getChildIndexA = function () {
                    return this.m_indexA;
                };

                /**
                 * Get the child primitive index for fixture B.
                 */
                Contact.prototype.getChildIndexB = function () {
                    return this.m_indexB;
                };

                /**
                 * Flag this contact for filtering. Filtering will occur the next time step.
                 */
                Contact.prototype.flagForFiltering = function () {
                    this.m_filterFlag = true;
                };

                /**
                 * Override the default friction mixture. You can call this in
                 * ContactListener.preSolve. This value persists until set or reset.
                 */
                Contact.prototype.setFriction = function (friction) {
                    this.m_friction = friction;
                };

                /**
                 * Get the friction.
                 */
                Contact.prototype.getFriction = function () {
                    return this.m_friction;
                };

                /**
                 * Reset the friction mixture to the default value.
                 */
                Contact.prototype.resetFriction = function () {
                    this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
                };

                /**
                 * Override the default restitution mixture. You can call this in
                 * ContactListener.preSolve. The value persists until you set or reset.
                 */
                Contact.prototype.setRestitution = function (restitution) {
                    this.m_restitution = restitution;
                };

                /**
                 * Get the restitution.
                 */
                Contact.prototype.getRestitution = function () {
                    return this.m_restitution;
                };

                /**
                 * Reset the restitution to the default value.
                 */
                Contact.prototype.resetRestitution = function () {
                    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
                };

                /**
                 * Set the desired tangent speed for a conveyor belt behavior. In meters per
                 * second.
                 */
                Contact.prototype.setTangentSpeed = function (speed) {
                    this.m_tangentSpeed = speed;
                };

                /**
                 * Get the desired tangent speed. In meters per second.
                 */
                Contact.prototype.getTangentSpeed = function () {
                    return this.m_tangentSpeed;
                };

                /**
                 * Called by Update method, and implemented by subclasses.
                 */
                Contact.prototype.evaluate = function (manifold, xfA, xfB) {
                    this.m_evaluateFcn(manifold, xfA, this.m_fixtureA, this.m_indexA, xfB, this.m_fixtureB, this.m_indexB);
                };

                /**
                 * Updates the contact manifold and touching status.
                 * 
                 * Note: do not assume the fixture AABBs are overlapping or are valid.
                 * 
                 * @param {function} listener.beginContact
                 * @param {function} listener.endContact
                 * @param {function} listener.preSolve
                 */
                Contact.prototype.update = function (listener) {
                    // Re-enable this contact.
                    this.m_enabledFlag = true;
                    var touching = false;
                    var wasTouching = this.m_touchingFlag;
                    var sensorA = this.m_fixtureA.isSensor();
                    var sensorB = this.m_fixtureB.isSensor();
                    var sensor = sensorA || sensorB;
                    var bodyA = this.m_fixtureA.getBody();
                    var bodyB = this.m_fixtureB.getBody();
                    var xfA = bodyA.getTransform();
                    var xfB = bodyB.getTransform();
                    // Is this contact a sensor?
                    if (sensor) {
                        var shapeA = this.m_fixtureA.getShape();
                        var shapeB = this.m_fixtureB.getShape();
                        touching = Distance.testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);
                        // Sensors don't generate manifolds.
                        this.m_manifold.pointCount = 0;
                    } else {
                        // TODO reuse manifold
                        var oldManifold = this.m_manifold;
                        this.m_manifold = new Manifold();
                        this.evaluate(this.m_manifold, xfA, xfB);
                        touching = this.m_manifold.pointCount > 0;
                        // Match old contact ids to new contact ids and copy the
                        // stored impulses to warm start the solver.
                        for (var i = 0; i < this.m_manifold.pointCount; ++i) {
                            var nmp = this.m_manifold.points[i];
                            nmp.normalImpulse = 0;
                            nmp.tangentImpulse = 0;
                            for (var j = 0; j < oldManifold.pointCount; ++j) {
                                var omp = oldManifold.points[j];
                                if (omp.id.key == nmp.id.key) {
                                    // ContactID.key
                                    nmp.normalImpulse = omp.normalImpulse;
                                    nmp.tangentImpulse = omp.tangentImpulse;
                                    break;
                                }
                            }
                        }
                        if (touching != wasTouching) {
                            bodyA.setAwake(true);
                            bodyB.setAwake(true);
                        }
                    }
                    this.m_touchingFlag = touching;
                    if (wasTouching == false && touching == true && listener) {
                        listener.beginContact(this);
                    }
                    if (wasTouching == true && touching == false && listener) {
                        listener.endContact(this);
                    }
                    if (sensor == false && touching && listener) {
                        listener.preSolve(this, oldManifold);
                    }
                };

                Contact.prototype.solvePositionConstraint = function (step) {
                    return this._solvePositionConstraint(step, false);
                };

                Contact.prototype.solvePositionConstraintTOI = function (step, toiA, toiB) {
                    return this._solvePositionConstraint(step, true, toiA, toiB);
                };

                Contact.prototype._solvePositionConstraint = function (step, toi, toiA, toiB) {
                    var fixtureA = this.m_fixtureA;
                    var fixtureB = this.m_fixtureB;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    var velocityA = bodyA.c_velocity;
                    var velocityB = bodyB.c_velocity;
                    var positionA = bodyA.c_position;
                    var positionB = bodyB.c_position;
                    var localCenterA = Vec2.clone(this.p_localCenterA);
                    var localCenterB = Vec2.clone(this.p_localCenterB);
                    var mA = 0;
                    var iA = 0;
                    if (!toi || bodyA == toiA || bodyA == toiB) {
                        mA = this.p_invMassA;
                        iA = this.p_invIA;
                    }
                    var mB = 0;
                    var iB = 0;
                    if (!toi || bodyB == toiA || bodyB == toiB) {
                        mB = this.p_invMassB;
                        iB = this.p_invIB;
                    }
                    var cA = Vec2.clone(positionA.c);
                    var aA = positionA.a;
                    var cB = Vec2.clone(positionB.c);
                    var aB = positionB.a;
                    var minSeparation = 0;
                    // Solve normal constraints
                    for (var j = 0; j < this.p_pointCount; ++j) {
                        var xfA = Transform.identity();
                        var xfB = Transform.identity();
                        xfA.q.set(aA);
                        xfB.q.set(aB);
                        xfA.p = Vec2.sub(cA, Rot.mul(xfA.q, localCenterA));
                        xfB.p = Vec2.sub(cB, Rot.mul(xfB.q, localCenterB));
                        // PositionSolverManifold
                        var normal, point, separation;
                        switch (this.p_type) {
                            case Manifold.e_circles:
                                var pointA = Transform.mul(xfA, this.p_localPoint);
                                var pointB = Transform.mul(xfB, this.p_localPoints[0]);
                                normal = Vec2.sub(pointB, pointA);
                                normal.normalize();
                                point = Vec2.wAdd(.5, pointA, .5, pointB);
                                separation = Vec2.dot(Vec2.sub(pointB, pointA), normal) - this.p_radiusA - this.p_radiusB;
                                break;

                            case Manifold.e_faceA:
                                normal = Rot.mul(xfA.q, this.p_localNormal);
                                var planePoint = Transform.mul(xfA, this.p_localPoint);
                                var clipPoint = Transform.mul(xfB, this.p_localPoints[j]);
                                separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;
                                point = clipPoint;
                                break;

                            case Manifold.e_faceB:
                                normal = Rot.mul(xfB.q, this.p_localNormal);
                                var planePoint = Transform.mul(xfB, this.p_localPoint);
                                var clipPoint = Transform.mul(xfA, this.p_localPoints[j]);
                                separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;
                                point = clipPoint;
                                // Ensure normal points from A to B
                                normal.mul(-1);
                                break;
                        }
                        var rA = Vec2.sub(point, cA);
                        var rB = Vec2.sub(point, cB);
                        // Track max constraint error.
                        minSeparation = Math.min(minSeparation, separation);
                        var baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;
                        var linearSlop = Settings.linearSlop;
                        var maxLinearCorrection = Settings.maxLinearCorrection;
                        // Prevent large corrections and allow slop.
                        var C = Math.clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0);
                        // Compute the effective mass.
                        var rnA = Vec2.cross(rA, normal);
                        var rnB = Vec2.cross(rB, normal);
                        var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                        // Compute normal impulse
                        var impulse = K > 0 ? -C / K : 0;
                        var P = Vec2.mul(impulse, normal);
                        cA.wSub(mA, P);
                        aA -= iA * Vec2.cross(rA, P);
                        cB.wAdd(mB, P);
                        aB += iB * Vec2.cross(rB, P);
                    }
                    positionA.c.set(cA);
                    positionA.a = aA;
                    positionB.c.set(cB);
                    positionB.a = aB;
                    return minSeparation;
                };

                // TODO merge with ManifoldPoint
                function VelocityConstraintPoint() {
                    this.rA = Vec2.zero();
                    this.rB = Vec2.zero();
                    this.normalImpulse = 0;
                    this.tangentImpulse = 0;
                    this.normalMass = 0;
                    this.tangentMass = 0;
                    this.velocityBias = 0;
                }

                Contact.prototype.initVelocityConstraint = function (step) {
                    var fixtureA = this.m_fixtureA;
                    var fixtureB = this.m_fixtureB;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    var velocityA = bodyA.c_velocity;
                    var velocityB = bodyB.c_velocity;
                    var positionA = bodyA.c_position;
                    var positionB = bodyB.c_position;
                    var radiusA = this.p_radiusA;
                    var radiusB = this.p_radiusB;
                    var manifold = this.getManifold();
                    var mA = this.v_invMassA;
                    var mB = this.v_invMassB;
                    var iA = this.v_invIA;
                    var iB = this.v_invIB;
                    var localCenterA = Vec2.clone(this.p_localCenterA);
                    var localCenterB = Vec2.clone(this.p_localCenterB);
                    var cA = Vec2.clone(positionA.c);
                    var aA = positionA.a;
                    var vA = Vec2.clone(velocityA.v);
                    var wA = velocityA.w;
                    var cB = Vec2.clone(positionB.c);
                    var aB = positionB.a;
                    var vB = Vec2.clone(velocityB.v);
                    var wB = velocityB.w;
                    //ASSERT && common.assert(manifold.pointCount > 0);
                    var xfA = Transform.identity();
                    var xfB = Transform.identity();
                    xfA.q.set(aA);
                    xfB.q.set(aB);
                    xfA.p.wSet(1, cA, -1, Rot.mul(xfA.q, localCenterA));
                    xfB.p.wSet(1, cB, -1, Rot.mul(xfB.q, localCenterB));
                    var worldManifold = manifold.getWorldManifold(null, xfA, radiusA, xfB, radiusB);
                    this.v_normal.set(worldManifold.normal);
                    for (var j = 0; j < this.v_pointCount; ++j) {
                        var vcp = this.v_points[j];
                        // VelocityConstraintPoint
                        vcp.rA.set(Vec2.sub(worldManifold.points[j], cA));
                        vcp.rB.set(Vec2.sub(worldManifold.points[j], cB));
                        //DEBUG && common.debug("vcp.rA", worldManifold.points[j].x, worldManifold.points[j].y, cA.x, cA.y, vcp.rA.x, vcp.rA.y);
                        var rnA = Vec2.cross(vcp.rA, this.v_normal);
                        var rnB = Vec2.cross(vcp.rB, this.v_normal);
                        var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                        vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;
                        var tangent = Vec2.cross(this.v_normal, 1);
                        var rtA = Vec2.cross(vcp.rA, tangent);
                        var rtB = Vec2.cross(vcp.rB, tangent);
                        var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
                        vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;
                        // Setup a velocity bias for restitution.
                        vcp.velocityBias = 0;
                        var vRel = Vec2.dot(this.v_normal, vB) + Vec2.dot(this.v_normal, Vec2.cross(wB, vcp.rB)) - Vec2.dot(this.v_normal, vA) - Vec2.dot(this.v_normal, Vec2.cross(wA, vcp.rA));
                        if (vRel < -Settings.velocityThreshold) {
                            vcp.velocityBias = -this.v_restitution * vRel;
                        }
                    }
                    // If we have two points, then prepare the block solver.
                    if (this.v_pointCount == 2 && step.blockSolve) {
                        var vcp1 = this.v_points[0];
                        // VelocityConstraintPoint
                        var vcp2 = this.v_points[1];
                        // VelocityConstraintPoint
                        var rn1A = Vec2.cross(vcp1.rA, this.v_normal);
                        var rn1B = Vec2.cross(vcp1.rB, this.v_normal);
                        var rn2A = Vec2.cross(vcp2.rA, this.v_normal);
                        var rn2B = Vec2.cross(vcp2.rB, this.v_normal);
                        var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
                        var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
                        var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
                        // Ensure a reasonable condition number.
                        var k_maxConditionNumber = 1e3;
                        //DEBUG && common.debug("k1x2: ", k11, k22, k12, mA, mB, iA, rn1A, rn2A, iB, rn1B, rn2B);
                        if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                            // K is safe to invert.
                            this.v_K.ex.set(k11, k12);
                            this.v_K.ey.set(k12, k22);
                            this.v_normalMass.set(this.v_K.getInverse());
                        } else {
                            // The constraints are redundant, just use one.
                            // TODO_ERIN use deepest?
                            this.v_pointCount = 1;
                        }
                    }
                    positionA.c.set(cA);
                    positionA.a = aA;
                    velocityA.v.set(vA);
                    velocityA.w = wA;
                    positionB.c.set(cB);
                    positionB.a = aB;
                    velocityB.v.set(vB);
                    velocityB.w = wB;
                };

                Contact.prototype.warmStartConstraint = function (step) {
                    var fixtureA = this.m_fixtureA;
                    var fixtureB = this.m_fixtureB;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    var velocityA = bodyA.c_velocity;
                    var velocityB = bodyB.c_velocity;
                    var positionA = bodyA.c_position;
                    var positionB = bodyB.c_position;
                    var mA = this.v_invMassA;
                    var iA = this.v_invIA;
                    var mB = this.v_invMassB;
                    var iB = this.v_invIB;
                    var vA = Vec2.clone(velocityA.v);
                    var wA = velocityA.w;
                    var vB = Vec2.clone(velocityB.v);
                    var wB = velocityB.w;
                    var normal = this.v_normal;
                    var tangent = Vec2.cross(normal, 1);
                    for (var j = 0; j < this.v_pointCount; ++j) {
                        var vcp = this.v_points[j];
                        // VelocityConstraintPoint
                        var P = Vec2.wAdd(vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);
                        //DEBUG && common.debug(iA, iB, vcp.rA.x, vcp.rA.y, vcp.rB.x, vcp.rB.y, P.x, P.y);
                        wA -= iA * Vec2.cross(vcp.rA, P);
                        vA.wSub(mA, P);
                        wB += iB * Vec2.cross(vcp.rB, P);
                        vB.wAdd(mB, P);
                    }
                    velocityA.v.set(vA);
                    velocityA.w = wA;
                    velocityB.v.set(vB);
                    velocityB.w = wB;
                };

                Contact.prototype.storeConstraintImpulses = function (step) {
                    var manifold = this.m_manifold;
                    for (var j = 0; j < this.v_pointCount; ++j) {
                        manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;
                        manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;
                    }
                };

                Contact.prototype.solveVelocityConstraint = function (step) {
                    var bodyA = this.m_fixtureA.m_body;
                    var bodyB = this.m_fixtureB.m_body;
                    var velocityA = bodyA.c_velocity;
                    var positionA = bodyA.c_position;
                    var velocityB = bodyB.c_velocity;
                    var positionB = bodyB.c_position;
                    var mA = this.v_invMassA;
                    var iA = this.v_invIA;
                    var mB = this.v_invMassB;
                    var iB = this.v_invIB;
                    var vA = Vec2.clone(velocityA.v);
                    var wA = velocityA.w;
                    var vB = Vec2.clone(velocityB.v);
                    var wB = velocityB.w;
                    var normal = this.v_normal;
                    var tangent = Vec2.cross(normal, 1);
                    var friction = this.v_friction;
                    //ASSERT && common.assert(this.v_pointCount == 1 || this.v_pointCount == 2);
                    // Solve tangent constraints first because non-penetration is more important
                    // than friction.
                    for (var j = 0; j < this.v_pointCount; ++j) {
                        var vcp = this.v_points[j];
                        // VelocityConstraintPoint
                        // Relative velocity at contact
                        var dv = Vec2.zero();
                        dv.wAdd(1, vB, 1, Vec2.cross(wB, vcp.rB));
                        dv.wSub(1, vA, 1, Vec2.cross(wA, vcp.rA));
                        // Compute tangent force
                        var vt = Vec2.dot(dv, tangent) - this.v_tangentSpeed;
                        var lambda = vcp.tangentMass * -vt;
                        // Clamp the accumulated force
                        var maxFriction = friction * vcp.normalImpulse;
                        var newImpulse = Math.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
                        lambda = newImpulse - vcp.tangentImpulse;
                        vcp.tangentImpulse = newImpulse;
                        // Apply contact impulse
                        var P = Vec2.mul(lambda, tangent);
                        vA.wSub(mA, P);
                        wA -= iA * Vec2.cross(vcp.rA, P);
                        vB.wAdd(mB, P);
                        wB += iB * Vec2.cross(vcp.rB, P);
                    }
                    // Solve normal constraints
                    if (this.v_pointCount == 1 || step.blockSolve == false) {
                        for (var i = 0; i < this.v_pointCount; ++i) {
                            var vcp = this.v_points[i];
                            // VelocityConstraintPoint
                            // Relative velocity at contact
                            var dv = Vec2.zero();
                            dv.wAdd(1, vB, 1, Vec2.cross(wB, vcp.rB));
                            dv.wSub(1, vA, 1, Vec2.cross(wA, vcp.rA));
                            // Compute normal impulse
                            var vn = Vec2.dot(dv, normal);
                            var lambda = -vcp.normalMass * (vn - vcp.velocityBias);
                            // Clamp the accumulated impulse
                            var newImpulse = Math.max(vcp.normalImpulse + lambda, 0);
                            lambda = newImpulse - vcp.normalImpulse;
                            vcp.normalImpulse = newImpulse;
                            // Apply contact impulse
                            var P = Vec2.mul(lambda, normal);
                            vA.wSub(mA, P);
                            wA -= iA * Vec2.cross(vcp.rA, P);
                            vB.wAdd(mB, P);
                            wB += iB * Vec2.cross(vcp.rB, P);
                        }
                    } else {
                        // Block solver developed in collaboration with Dirk Gregorius (back in
                        // 01/07 on Box2D_Lite).
                        // Build the mini LCP for this contact patch
                        //
                        // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i =
                        // 1..2
                        //
                        // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )
                        // b = vn0 - velocityBias
                        //
                        // The system is solved using the "Total enumeration method" (s. Murty).
                        // The complementary constraint vn_i * x_i
                        // implies that we must have in any solution either vn_i = 0 or x_i = 0.
                        // So for the 2D contact problem the cases
                        // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and
                        // vn1 = 0 need to be tested. The first valid
                        // solution that satisfies the problem is chosen.
                        // 
                        // In order to account of the accumulated impulse 'a' (because of the
                        // iterative nature of the solver which only requires
                        // that the accumulated impulse is clamped and not the incremental
                        // impulse) we change the impulse variable (x_i).
                        //
                        // Substitute:
                        // 
                        // x = a + d
                        // 
                        // a := old total impulse
                        // x := new total impulse
                        // d := incremental impulse
                        //
                        // For the current iteration we extend the formula for the incremental
                        // impulse
                        // to compute the new total impulse:
                        //
                        // vn = A * d + b
                        // = A * (x - a) + b
                        // = A * x + b - A * a
                        // = A * x + b'
                        // b' = b - A * a;
                        var vcp1 = this.v_points[0];
                        // VelocityConstraintPoint
                        var vcp2 = this.v_points[1];
                        // VelocityConstraintPoint
                        var a = Vec2.neo(vcp1.normalImpulse, vcp2.normalImpulse);
                        //ASSERT && common.assert(a.x >= 0 && a.y >= 0);
                        // Relative velocity at contact
                        var dv1 = Vec2.zero().add(vB).add(Vec2.cross(wB, vcp1.rB)).sub(vA).sub(Vec2.cross(wA, vcp1.rA));
                        var dv2 = Vec2.zero().add(vB).add(Vec2.cross(wB, vcp2.rB)).sub(vA).sub(Vec2.cross(wA, vcp2.rA));
                        // Compute normal velocity
                        var vn1 = Vec2.dot(dv1, normal);
                        var vn2 = Vec2.dot(dv2, normal);
                        var b = Vec2.neo(vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);
                        // Compute b'
                        b.sub(Mat22.mul(this.v_K, a));
                        var k_errorTol = .001;
                        // NOT_USED(k_errorTol);
                        for (;;) {
                            //
                            // Case 1: vn = 0
                            //
                            // 0 = A * x + b'
                            //
                            // Solve for x:
                            //
                            // x = - inv(A) * b'
                            //
                            var x = Vec2.neg(Mat22.mul(this.v_normalMass, b));
                            if (x.x >= 0 && x.y >= 0) {
                                // Get the incremental impulse
                                var d = Vec2.sub(x, a);
                                // Apply incremental impulse
                                var P1 = Vec2.mul(d.x, normal);
                                var P2 = Vec2.mul(d.y, normal);
                                vA.wSub(mA, P1, mA, P2);
                                wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));
                                vB.wAdd(mB, P1, mB, P2);
                                wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));
                                // Accumulate
                                vcp1.normalImpulse = x.x;
                                vcp2.normalImpulse = x.y;
                                if (DEBUG_SOLVER) {
                                    // Postconditions
                                    dv1 = vB + Vec2.cross(wB, vcp1.rB) - vA - Vec2.cross(wA, vcp1.rA);
                                    dv2 = vB + Vec2.cross(wB, vcp2.rB) - vA - Vec2.cross(wA, vcp2.rA);
                                    // Compute normal velocity
                                    vn1 = Dot(dv1, normal);
                                    vn2 = Dot(dv2, normal);
                                    //ASSERT && common.assert(Abs(vn1 - vcp1.velocityBias) < k_errorTol);
                                    //ASSERT && common.assert(Abs(vn2 - vcp2.velocityBias) < k_errorTol);
                                }
                                break;
                            }
                            //
                            // Case 2: vn1 = 0 and x2 = 0
                            //
                            // 0 = a11 * x1 + a12 * 0 + b1'
                            // vn2 = a21 * x1 + a22 * 0 + b2'
                            //
                            x.x = -vcp1.normalMass * b.x;
                            x.y = 0;
                            vn1 = 0;
                            vn2 = this.v_K.ex.y * x.x + b.y;
                            if (x.x >= 0 && vn2 >= 0) {
                                // Get the incremental impulse
                                var d = Vec2.sub(x, a);
                                // Apply incremental impulse
                                var P1 = Vec2.mul(d.x, normal);
                                var P2 = Vec2.mul(d.y, normal);
                                vA.wSub(mA, P1, mA, P2);
                                wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));
                                vB.wAdd(mB, P1, mB, P2);
                                wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));
                                // Accumulate
                                vcp1.normalImpulse = x.x;
                                vcp2.normalImpulse = x.y;
                                if (DEBUG_SOLVER) {
                                    // Postconditions
                                    var dv1B = Vec2.add(vB, Vec2.cross(wB, vcp1.rB));
                                    var dv1A = Vec2.add(vA, Vec2.cross(wA, vcp1.rA));
                                    var dv1 = Vec2.sub(dv1B, dv1A);
                                    // Compute normal velocity
                                    vn1 = Vec2.dot(dv1, normal);
                                    //ASSERT && common.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);
                                }
                                break;
                            }
                            //
                            // Case 3: vn2 = 0 and x1 = 0
                            //
                            // vn1 = a11 * 0 + a12 * x2 + b1'
                            // 0 = a21 * 0 + a22 * x2 + b2'
                            //
                            x.x = 0;
                            x.y = -vcp2.normalMass * b.y;
                            vn1 = this.v_K.ey.x * x.y + b.x;
                            vn2 = 0;
                            if (x.y >= 0 && vn1 >= 0) {
                                // Resubstitute for the incremental impulse
                                var d = Vec2.sub(x, a);
                                // Apply incremental impulse
                                var P1 = Vec2.mul(d.x, normal);
                                var P2 = Vec2.mul(d.y, normal);
                                vA.wSub(mA, P1, mA, P2);
                                wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));
                                vB.wAdd(mB, P1, mB, P2);
                                wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));
                                // Accumulate
                                vcp1.normalImpulse = x.x;
                                vcp2.normalImpulse = x.y;
                                if (DEBUG_SOLVER) {
                                    // Postconditions
                                    var dv2B = Vec2.add(vB, Vec2.cross(wB, vcp2.rB));
                                    var dv2A = Vec2.add(vA, Vec2.cross(wA, vcp2.rA));
                                    var dv1 = Vec2.sub(dv2B, dv2A);
                                    // Compute normal velocity
                                    vn2 = Vec2.dot(dv2, normal);
                                    //ASSERT && common.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);
                                }
                                break;
                            }
                            //
                            // Case 4: x1 = 0 and x2 = 0
                            // 
                            // vn1 = b1
                            // vn2 = b2;
                            //
                            x.x = 0;
                            x.y = 0;
                            vn1 = b.x;
                            vn2 = b.y;
                            if (vn1 >= 0 && vn2 >= 0) {
                                // Resubstitute for the incremental impulse
                                var d = Vec2.sub(x, a);
                                // Apply incremental impulse
                                var P1 = Vec2.mul(d.x, normal);
                                var P2 = Vec2.mul(d.y, normal);
                                vA.wSub(mA, P1, mA, P2);
                                wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));
                                vB.wAdd(mB, P1, mB, P2);
                                wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));
                                // Accumulate
                                vcp1.normalImpulse = x.x;
                                vcp2.normalImpulse = x.y;
                                break;
                            }
                            // No solution, give up. This is hit sometimes, but it doesn't seem to
                            // matter.
                            break;
                        }
                    }
                    velocityA.v.set(vA);
                    velocityA.w = wA;
                    velocityB.v.set(vB);
                    velocityB.w = wB;
                };

                /**
                 * Friction mixing law. The idea is to allow either fixture to drive the
                 * restitution to zero. For example, anything slides on ice.
                 */
                function mixFriction(friction1, friction2) {
                    return Math.sqrt(friction1 * friction2);
                }

                /**
                 * Restitution mixing law. The idea is allow for anything to bounce off an
                 * inelastic surface. For example, a superball bounces on anything.
                 */
                function mixRestitution(restitution1, restitution2) {
                    return restitution1 > restitution2 ? restitution1 : restitution2;
                }

                var s_registers = [];

                /**
                 * @param fn function(fixtureA, indexA, fixtureB, indexB) Contact
                 */
                Contact.addType = function (type1, type2, callback) {
                    s_registers[type1] = s_registers[type1] || {};
                    s_registers[type1][type2] = callback;
                };

                Contact.create = function (fixtureA, indexA, fixtureB, indexB) {
                    var typeA = fixtureA.getType();
                    // Shape.Type
                    var typeB = fixtureB.getType();
                    // Shape.Type
                    // TODO: pool contacts
                    var contact, evaluateFcn;
                    if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {
                        contact = new Contact(fixtureA, indexA, fixtureB, indexB, evaluateFcn);
                    } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {
                        contact = new Contact(fixtureB, indexB, fixtureA, indexA, evaluateFcn);
                    } else {
                        return null;
                    }
                    // Contact creation may swap fixtures.
                    fixtureA = contact.getFixtureA();
                    fixtureB = contact.getFixtureB();
                    indexA = contact.getChildIndexA();
                    indexB = contact.getChildIndexB();
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    // Connect to body A
                    contact.m_nodeA.contact = contact;
                    contact.m_nodeA.other = bodyB;
                    contact.m_nodeA.prev = null;
                    contact.m_nodeA.next = bodyA.m_contactList;
                    if (bodyA.m_contactList != null) {
                        bodyA.m_contactList.prev = contact.m_nodeA;
                    }
                    bodyA.m_contactList = contact.m_nodeA;
                    // Connect to body B
                    contact.m_nodeB.contact = contact;
                    contact.m_nodeB.other = bodyA;
                    contact.m_nodeB.prev = null;
                    contact.m_nodeB.next = bodyB.m_contactList;
                    if (bodyB.m_contactList != null) {
                        bodyB.m_contactList.prev = contact.m_nodeB;
                    }
                    bodyB.m_contactList = contact.m_nodeB;
                    // Wake up the bodies
                    if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {
                        bodyA.setAwake(true);
                        bodyB.setAwake(true);
                    }
                    return contact;
                };

                Contact.destroy = function (contact, listener) {
                    var fixtureA = contact.m_fixtureA;
                    var fixtureB = contact.m_fixtureB;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    if (contact.isTouching()) {
                        listener.endContact(contact);
                    }
                    // Remove from body 1
                    if (contact.m_nodeA.prev) {
                        contact.m_nodeA.prev.next = contact.m_nodeA.next;
                    }
                    if (contact.m_nodeA.next) {
                        contact.m_nodeA.next.prev = contact.m_nodeA.prev;
                    }
                    if (contact.m_nodeA == bodyA.m_contactList) {
                        bodyA.m_contactList = contact.m_nodeA.next;
                    }
                    // Remove from body 2
                    if (contact.m_nodeB.prev) {
                        contact.m_nodeB.prev.next = contact.m_nodeB.next;
                    }
                    if (contact.m_nodeB.next) {
                        contact.m_nodeB.next.prev = contact.m_nodeB.prev;
                    }
                    if (contact.m_nodeB == bodyB.m_contactList) {
                        bodyB.m_contactList = contact.m_nodeB.next;
                    }
                    if (contact.m_manifold.pointCount > 0 && fixtureA.isSensor() == false && fixtureB.isSensor() == false) {
                        bodyA.setAwake(true);
                        bodyB.setAwake(true);
                    }
                    var typeA = fixtureA.getType();
                    // Shape.Type
                    var typeB = fixtureB.getType();
                    // Shape.Type
                    var destroyFcn = s_registers[typeA][typeB].destroyFcn;
                    if (typeof destroyFcn === "function") {
                        destroyFcn(contact);
                    }
                };
            }, { "./Manifold": 6, "./Settings": 7, "./collision/Distance": 13, "./common/Mat22": 16, "./common/Math": 18, "./common/Rot": 20, "./common/Transform": 22, "./common/Vec2": 23, "./util/common": 50 }], 4: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Fixture;

                var common = require("./util/common");

                var options = require("./util/options");

                var Vec2 = require("./common/Vec2");

                var AABB = require("./collision/AABB");

                /**
                 * @typedef {Object} FixtureDef
                 *
                 * A fixture definition is used to create a fixture. This class defines an
                 * abstract fixture definition. You can reuse fixture definitions safely.
                 * 
                 * @prop friction The friction coefficient, usually in the range [0,1]
                 * @prop restitution The restitution (elasticity) usually in the range [0,1]
                 * @prop density The density, usually in kg/m^2
                 * @prop isSensor A sensor shape collects contact information but never
                 *       generates a collision response
                 * @prop userData
                 * @prop filterGroupIndex Zero, positive or negative collision group. Fixtures with same positive groupIndex always collide and fixtures with same
                 * negative groupIndex never collide.
                 * @prop filterCategoryBits Collision category bit or bits that this fixture belongs
                 *       to. If groupIndex is zero or not matching, then at least one bit in this fixture
                 * categoryBits should match other fixture maskBits and vice versa.
                 * @prop filterMaskBits Collision category bit or bits that this fixture accept for
                 *       collision.
                 */
                var FixtureDef = {
                    userData: null,
                    friction: .2,
                    restitution: 0,
                    density: 0,
                    isSensor: false,
                    filterGroupIndex: 0,
                    filterCategoryBits: 1,
                    filterMaskBits: 65535
                };

                /**
                 * This proxy is used internally to connect shape children to the broad-phase.
                 */
                function FixtureProxy(fixture, childIndex) {
                    this.aabb = new AABB();
                    this.fixture = fixture;
                    this.childIndex = childIndex;
                    this.proxyId;
                }

                /**
                 * A fixture is used to attach a shape to a body for collision detection. A
                 * fixture inherits its transform from its parent. Fixtures hold additional
                 * non-geometric data such as friction, collision filters, etc. Fixtures are
                 * created via Body.createFixture.
                 * 
                 * @param {Shape|FixtureDef} shape Shape of fixture definition.
                 * @param {FixtureDef|number} def Fixture definition or number.
                 */
                function Fixture(body, shape, def) {
                    if (shape.shape) {
                        def = shape;
                        shape = shape.shape;
                    } else if (typeof def === "number") {
                        def = {
                            density: def
                        };
                    }
                    def = options(def, FixtureDef);
                    this.m_body = body;
                    this.m_friction = def.friction;
                    this.m_restitution = def.restitution;
                    this.m_density = def.density;
                    this.m_isSensor = def.isSensor;
                    this.m_filterGroupIndex = def.filterGroupIndex;
                    this.m_filterCategoryBits = def.filterCategoryBits;
                    this.m_filterMaskBits = def.filterMaskBits;
                    // TODO validate shape
                    this.m_shape = shape;
                    //.clone();
                    this.m_next = null;
                    this.m_proxies = [];
                    this.m_proxyCount = 0;
                    var childCount = this.m_shape.getChildCount();
                    for (var i = 0; i < childCount; ++i) {
                        this.m_proxies[i] = new FixtureProxy(this, i);
                    }
                    this.m_userData = def.userData;
                }

                /**
                 * Get the type of the child shape. You can use this to down cast to the
                 * concrete shape.
                 */
                Fixture.prototype.getType = function () {
                    return this.m_shape.getType();
                };

                /**
                 * Get the child shape. You can modify the child shape, however you should not
                 * change the number of vertices because this will crash some collision caching
                 * mechanisms. Manipulating the shape may lead to non-physical behavior.
                 */
                Fixture.prototype.getShape = function () {
                    return this.m_shape;
                };

                /**
                 * A sensor shape collects contact information but never generates a collision
                 * response.
                 */
                Fixture.prototype.isSensor = function () {
                    return this.m_isSensor;
                };

                /**
                 * Set if this fixture is a sensor.
                 */
                Fixture.prototype.setSensor = function (sensor) {
                    if (sensor != this.m_isSensor) {
                        this.m_body.setAwake(true);
                        this.m_isSensor = sensor;
                    }
                };

                /**
                 * Get the contact filtering data.
                 */
                // Fixture.prototype.getFilterData = function() {
                //   return this.m_filter;
                // }
                /**
                 * Get the user data that was assigned in the fixture definition. Use this to
                 * store your application specific data.
                 */
                Fixture.prototype.getUserData = function () {
                    return this.m_userData;
                };

                /**
                 * Set the user data. Use this to store your application specific data.
                 */
                Fixture.prototype.setUserData = function (data) {
                    this.m_userData = data;
                };

                /**
                 * Get the parent body of this fixture. This is null if the fixture is not
                 * attached.
                 */
                Fixture.prototype.getBody = function () {
                    return this.m_body;
                };

                /**
                 * Get the next fixture in the parent body's fixture list.
                 */
                Fixture.prototype.getNext = function () {
                    return this.m_next;
                };

                /**
                 * Get the density of this fixture.
                 */
                Fixture.prototype.getDensity = function () {
                    return this.m_density;
                };

                /**
                 * Set the density of this fixture. This will _not_ automatically adjust the
                 * mass of the body. You must call Body.resetMassData to update the body's mass.
                 */
                Fixture.prototype.setDensity = function (density) {
                    //ASSERT && common.assert(Math.isFinite(density) && density >= 0);
                    this.m_density = density;
                };

                /**
                 * Get the coefficient of friction, usually in the range [0,1].
                 */
                Fixture.prototype.getFriction = function () {
                    return this.m_friction;
                };

                /**
                 * Set the coefficient of friction. This will not change the friction of
                 * existing contacts.
                 */
                Fixture.prototype.setFriction = function (friction) {
                    this.m_friction = friction;
                };

                /**
                 * Get the coefficient of restitution.
                 */
                Fixture.prototype.getRestitution = function () {
                    return this.m_restitution;
                };

                /**
                 * Set the coefficient of restitution. This will not change the restitution of
                 * existing contacts.
                 */
                Fixture.prototype.setRestitution = function (restitution) {
                    this.m_restitution = restitution;
                };

                /**
                 * Test a point in world coordinates for containment in this fixture.
                 */
                Fixture.prototype.testPoint = function (p) {
                    return this.m_shape.testPoint(this.m_body.getTransform(), p);
                };

                /**
                 * Cast a ray against this shape.
                 */
                Fixture.prototype.rayCast = function (output, input, childIndex) {
                    return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);
                };

                /**
                 * Get the mass data for this fixture. The mass data is based on the density and
                 * the shape. The rotational inertia is about the shape's origin. This operation
                 * may be expensive.
                 */
                Fixture.prototype.getMassData = function (massData) {
                    this.m_shape.computeMass(massData, this.m_density);
                };

                /**
                 * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a
                 * more accurate AABB, compute it using the shape and the body transform.
                 */
                Fixture.prototype.getAABB = function (childIndex) {
                    //ASSERT && common.assert(0 <= childIndex && childIndex < this.m_proxyCount);
                    return this.m_proxies[childIndex].aabb;
                };

                /**
                 * These support body activation/deactivation.
                 */
                Fixture.prototype.createProxies = function (broadPhase, xf) {
                    //ASSERT && common.assert(this.m_proxyCount == 0);
                    // Create proxies in the broad-phase.
                    this.m_proxyCount = this.m_shape.getChildCount();
                    for (var i = 0; i < this.m_proxyCount; ++i) {
                        var proxy = this.m_proxies[i];
                        this.m_shape.computeAABB(proxy.aabb, xf, i);
                        proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);
                    }
                };

                Fixture.prototype.destroyProxies = function (broadPhase) {
                    // Destroy proxies in the broad-phase.
                    for (var i = 0; i < this.m_proxyCount; ++i) {
                        var proxy = this.m_proxies[i];
                        broadPhase.destroyProxy(proxy.proxyId);
                        proxy.proxyId = null;
                    }
                    this.m_proxyCount = 0;
                };

                /**
                 * Updates this fixture proxy in broad-phase (with combined AABB of current and
                 * next transformation).
                 */
                Fixture.prototype.synchronize = function (broadPhase, xf1, xf2) {
                    for (var i = 0; i < this.m_proxyCount; ++i) {
                        var proxy = this.m_proxies[i];
                        // Compute an AABB that covers the swept shape (may miss some rotation
                        // effect).
                        var aabb1 = new AABB();
                        var aabb2 = new AABB();
                        this.m_shape.computeAABB(aabb1, xf1, proxy.childIndex);
                        this.m_shape.computeAABB(aabb2, xf2, proxy.childIndex);
                        proxy.aabb.combine(aabb1, aabb2);
                        var displacement = Vec2.sub(xf2.p, xf1.p);
                        broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);
                    }
                };

                /**
                 * Set the contact filtering data. This will not update contacts until the next
                 * time step when either parent body is active and awake. This automatically
                 * calls refilter.
                 */
                Fixture.prototype.setFilterData = function (filter) {
                    this.m_filterGroupIndex = filter.groupIndex;
                    this.m_filterCategoryBits = filter.categoryBits;
                    this.m_filterMaskBits = filter.maskBits;
                    this.refilter();
                };

                Fixture.prototype.getFilterGroupIndex = function () {
                    return this.m_filterGroupIndex;
                };

                Fixture.prototype.getFilterCategoryBits = function () {
                    return this.m_filterCategoryBits;
                };

                Fixture.prototype.getFilterMaskBits = function () {
                    return this.m_filterMaskBits;
                };

                /**
                 * Call this if you want to establish collision that was previously disabled by
                 * ContactFilter.
                 */
                Fixture.prototype.refilter = function () {
                    if (this.m_body == null) {
                        return;
                    }
                    // Flag associated contacts for filtering.
                    var edge = this.m_body.getContactList();
                    while (edge) {
                        var contact = edge.contact;
                        var fixtureA = contact.getFixtureA();
                        var fixtureB = contact.getFixtureB();
                        if (fixtureA == this || fixtureB == this) {
                            contact.flagForFiltering();
                        }
                        edge = edge.next;
                    }
                    var world = this.m_body.getWorld();
                    if (world == null) {
                        return;
                    }
                    // Touch each proxy so that new pairs may be created
                    var broadPhase = world.m_broadPhase;
                    for (var i = 0; i < this.m_proxyCount; ++i) {
                        broadPhase.touchProxy(this.m_proxies[i].proxyId);
                    }
                };

                /**
                 * Implement this method to provide collision filtering, if you want finer
                 * control over contact creation.
                 * 
                 * Return true if contact calculations should be performed between these two
                 * fixtures.
                 * 
                 * Warning: for performance reasons this is only called when the AABBs begin to
                 * overlap.
                 * 
                 * @param {Fixture} fixtureA
                 * @param {Fixture} fixtureB
                 */
                Fixture.prototype.shouldCollide = function (that) {
                    if (that.m_filterGroupIndex == this.m_filterGroupIndex && that.m_filterGroupIndex != 0) {
                        return that.m_filterGroupIndex > 0;
                    }
                    var collide = (that.m_filterMaskBits & this.m_filterCategoryBits) != 0 && (that.m_filterCategoryBits & this.m_filterMaskBits) != 0;
                    return collide;
                };
            }, { "./collision/AABB": 11, "./common/Vec2": 23, "./util/common": 50, "./util/options": 52 }], 5: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Joint;

                var common = require("./util/common");

                /**
                 * A joint edge is used to connect bodies and joints together in a joint graph
                 * where each body is a node and each joint is an edge. A joint edge belongs to
                 * a doubly linked list maintained in each attached body. Each joint has two
                 * joint nodes, one for each attached body.
                 * 
                 * @prop {Body} other provides quick access to the other body attached.
                 * @prop {Joint} joint the joint
                 * @prop {JointEdge} prev the previous joint edge in the body's joint list
                 * @prop {JointEdge} next the next joint edge in the body's joint list
                 */
                function JointEdge() {
                    this.other = null;
                    this.joint = null;
                    this.prev = null;
                    this.next = null;
                }

                /**
                 * @typedef {Object} JointDef
                 *
                 * Joint definitions are used to construct joints.
                 * 
                 * @prop userData Use this to attach application specific data to your joints.
                 *       void userData;
                 * @prop {boolean} collideConnected Set this flag to true if the attached bodies
                 *       should collide.
                 */
                var JointDef = {
                    userData: null,
                    collideConnected: false
                };

                /**
                 * The base joint class. Joints are used to constraint two bodies together in
                 * various fashions. Some joints also feature limits and motors.
                 * 
                 * @param {JointDef} def
                 * @param {Body} bodyA first attached body.
                 * @param {Body} bodyB The second attached body.
                 */
                function Joint(def, bodyA, bodyB) {
                    bodyA = def.bodyA || bodyA;
                    bodyB = def.bodyB || bodyB;
                    //ASSERT && common.assert(bodyA);
                    //ASSERT && common.assert(bodyB);
                    //ASSERT && common.assert(bodyA != bodyB);
                    this.m_type = "unknown-joint";
                    this.m_bodyA = bodyA;
                    this.m_bodyB = bodyB;
                    this.m_index = 0;
                    this.m_collideConnected = !!def.collideConnected;
                    this.m_prev = null;
                    this.m_next = null;
                    this.m_edgeA = new JointEdge();
                    this.m_edgeB = new JointEdge();
                    this.m_islandFlag = false;
                    this.m_userData = def.userData;
                }

                /**
                 * Short-cut function to determine if either body is inactive.
                 * 
                 * @returns {boolean}
                 */
                Joint.prototype.isActive = function () {
                    return this.m_bodyA.isActive() && this.m_bodyB.isActive();
                };

                /**
                 * Get the type of the concrete joint.
                 * 
                 * @returns JointType
                 */
                Joint.prototype.getType = function () {
                    return this.m_type;
                };

                /**
                 * Get the first body attached to this joint.
                 * 
                 * @returns Body
                 */
                Joint.prototype.getBodyA = function () {
                    return this.m_bodyA;
                };

                /**
                 * Get the second body attached to this joint.
                 * 
                 * @returns Body
                 */
                Joint.prototype.getBodyB = function () {
                    return this.m_bodyB;
                };

                /**
                 * Get the next joint the world joint list.
                 * 
                 * @returns Joint
                 */
                Joint.prototype.getNext = function () {
                    return this.m_next;
                };

                Joint.prototype.getUserData = function () {
                    return this.m_userData;
                };

                Joint.prototype.setUserData = function (data) {
                    this.m_userData = data;
                };

                /**
                 * Get collide connected. Note: modifying the collide connect flag won't work
                 * correctly because the flag is only checked when fixture AABBs begin to
                 * overlap.
                 * 
                 * @returns {boolean}
                 */
                Joint.prototype.getCollideConnected = function () {
                    return this.m_collideConnected;
                };

                /**
                 * Get the anchor point on bodyA in world coordinates.
                 * 
                 * @return {Vec2}
                 */
                Joint.prototype.getAnchorA = function () {};

                /**
                 * Get the anchor point on bodyB in world coordinates.
                 * 
                 * @return {Vec2}
                 */
                Joint.prototype.getAnchorB = function () {};

                /**
                 * Get the reaction force on bodyB at the joint anchor in Newtons.
                 * 
                 * @param {float} inv_dt
                 * @return {Vec2}
                 */
                Joint.prototype.getReactionForce = function (inv_dt) {};

                /**
                 * Get the reaction torque on bodyB in N*m.
                 * 
                 * @param {float} inv_dt
                 * @return {float}
                 */
                Joint.prototype.getReactionTorque = function (inv_dt) {};

                /**
                 * Shift the origin for any points stored in world coordinates.
                 * 
                 * @param {Vec2} newOrigin
                 */
                Joint.prototype.shiftOrigin = function (newOrigin) {};

                /**
                 */
                Joint.prototype.initVelocityConstraints = function (step) {};

                /**
                 */
                Joint.prototype.solveVelocityConstraints = function (step) {};

                /**
                 * This returns true if the position errors are within tolerance.
                 */
                Joint.prototype.solvePositionConstraints = function (step) {};
            }, { "./util/common": 50 }], 6: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var common = require("./util/common");

                var Vec2 = require("./common/Vec2");

                var Transform = require("./common/Transform");

                var Math = require("./common/Math");

                var Rot = require("./common/Rot");

                module.exports = Manifold;

                module.exports.clipSegmentToLine = clipSegmentToLine;

                module.exports.clipVertex = ClipVertex;

                module.exports.getPointStates = getPointStates;

                module.exports.PointState = PointState;

                // Manifold Type
                Manifold.e_circles = 0;

                Manifold.e_faceA = 1;

                Manifold.e_faceB = 2;

                // ContactFeature Type
                Manifold.e_vertex = 0;

                Manifold.e_face = 1;

                /**
                 * A manifold for two touching convex shapes. Manifolds are created in `evaluate`
                 * method of Contact subclasses.
                 * 
                 * Supported manifold types are e_faceA or e_faceB for clip point versus plane
                 * with radius and e_circles point versus point with radius.
                 * 
                 * We store contacts in this way so that position correction can account for
                 * movement, which is critical for continuous physics. All contact scenarios
                 * must be expressed in one of these types. This structure is stored across time
                 * steps, so we keep it small.
                 * 
                 * @prop type e_circle, e_faceA, e_faceB
                 * @prop localPoint Usage depends on manifold type:<br>
                 *       e_circles: the local center of circleA <br>
                 *       e_faceA: the center of faceA <br>
                 *       e_faceB: the center of faceB
                 * @prop localNormal Usage depends on manifold type:<br>
                 *       e_circles: not used <br>
                 *       e_faceA: the normal on polygonA <br>
                 *       e_faceB: the normal on polygonB
                 * @prop points The points of contact {ManifoldPoint[]}
                 * @prop pointCount The number of manifold points
                 */
                function Manifold() {
                    this.type;
                    this.localNormal = Vec2.zero();
                    this.localPoint = Vec2.zero();
                    this.points = [new ManifoldPoint(), new ManifoldPoint()];
                    this.pointCount = 0;
                }

                /**
                 * A manifold point is a contact point belonging to a contact manifold. It holds
                 * details related to the geometry and dynamics of the contact points.
                 * 
                 * This structure is stored across time steps, so we keep it small.
                 * 
                 * Note: impulses are used for internal caching and may not provide reliable
                 * contact forces, especially for high speed collisions.
                 * 
                 * @prop {Vec2} localPoint Usage depends on manifold type:<br>
                 *       e_circles: the local center of circleB<br>
                 *       e_faceA: the local center of cirlceB or the clip point of polygonB<br>
                 *       e_faceB: the clip point of polygonA.
                 * @prop normalImpulse The non-penetration impulse
                 * @prop tangentImpulse The friction impulse
                 * @prop {ContactID} id Uniquely identifies a contact point between two shapes
                 *       to facilatate warm starting
                 */
                function ManifoldPoint() {
                    this.localPoint = Vec2.zero();
                    this.normalImpulse = 0;
                    this.tangentImpulse = 0;
                    this.id = new ContactID();
                }

                /**
                 * Contact ids to facilitate warm starting.
                 * 
                 * @prop {ContactFeature} cf
                 * @prop key Used to quickly compare contact ids.
                 * 
                 */
                function ContactID() {
                    // TODO merge with ManifoldPoint?
                    this.cf = new ContactFeature();
                    this.key;
                }

                ContactID.prototype.set = function (o) {
                    this.key = o.key;
                    this.cf.set(o.cf);
                };

                /**
                 * The features that intersect to form the contact point.
                 * 
                 * @prop indexA Feature index on shapeA
                 * @prop indexB Feature index on shapeB
                 * @prop typeA The feature type on shapeA
                 * @prop typeB The feature type on shapeB
                 */
                function ContactFeature() {
                    // TODO merge with ContactID?
                    this.indexA;
                    this.indexB;
                    this.typeA;
                    this.typeB;
                }

                ContactFeature.prototype.set = function (o) {
                    this.indexA = o.indexA;
                    this.indexB = o.indexB;
                    this.typeA = o.typeA;
                    this.typeB = o.typeB;
                };

                /**
                 * This is used to compute the current state of a contact manifold.
                 * 
                 * @prop normal World vector pointing from A to B
                 * @prop points World contact point (point of intersection)
                 * @prop separations A negative value indicates overlap, in meters
                 */
                function WorldManifold() {
                    this.normal;
                    this.points = [];
                    // [maxManifoldPoints]
                    this.separations = [];
                }

                /**
                 * Evaluate the manifold with supplied transforms. This assumes modest motion
                 * from the original state. This does not change the point count, impulses, etc.
                 * The radii must come from the shapes that generated the manifold.
                 * 
                 * @param {WorldManifold} [wm]
                 */
                Manifold.prototype.getWorldManifold = function (wm, xfA, radiusA, xfB, radiusB) {
                    if (this.pointCount == 0) {
                        return;
                    }
                    wm = wm || new WorldManifold();
                    var normal = wm.normal;
                    var points = wm.points;
                    var separations = wm.separations;
                    // TODO: improve
                    switch (this.type) {
                        case Manifold.e_circles:
                            normal = Vec2.neo(1, 0);
                            var pointA = Transform.mul(xfA, this.localPoint);
                            var pointB = Transform.mul(xfB, this.points[0].localPoint);
                            var dist = Vec2.sub(pointB, pointA);
                            if (Vec2.lengthSquared(dist) > Math.EPSILON * Math.EPSILON) {
                                normal.set(dist);
                                normal.normalize();
                            }
                            points[0] = Vec2.mid(pointA, pointB);
                            separations[0] = -radiusB - radiusA;
                            points.length = 1;
                            separations.length = 1;
                            break;

                        case Manifold.e_faceA:
                            normal = Rot.mul(xfA.q, this.localNormal);
                            var planePoint = Transform.mul(xfA, this.localPoint);
                            //DEBUG && common.debug("faceA", this.localPoint.x, this.localPoint.y, this.localNormal.x, this.localNormal.y, normal.x, normal.y);
                            for (var i = 0; i < this.pointCount; ++i) {
                                var clipPoint = Transform.mul(xfB, this.points[i].localPoint);
                                var cA = Vec2.clone(clipPoint).wAdd(radiusA - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);
                                var cB = Vec2.clone(clipPoint).wSub(radiusB, normal);
                                points[i] = Vec2.mid(cA, cB);
                                separations[i] = Vec2.dot(Vec2.sub(cB, cA), normal);
                                //DEBUG && common.debug(i, this.points[i].localPoint.x, this.points[i].localPoint.y, planePoint.x, planePoint.y, xfA.p.x, xfA.p.y, xfA.q.c, xfA.q.s, xfB.p.x, xfB.p.y, xfB.q.c, xfB.q.s, radiusA, radiusB, clipPoint.x, clipPoint.y, cA.x, cA.y, cB.x, cB.y, separations[i], points[i].x, points[i].y);
                            }
                            points.length = this.pointCount;
                            separations.length = this.pointCount;
                            break;

                        case Manifold.e_faceB:
                            normal = Rot.mul(xfB.q, this.localNormal);
                            var planePoint = Transform.mul(xfB, this.localPoint);
                            for (var i = 0; i < this.pointCount; ++i) {
                                var clipPoint = Transform.mul(xfA, this.points[i].localPoint);
                                var cB = Vec2.zero().wSet(1, clipPoint, radiusB - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);
                                var cA = Vec2.zero().wSet(1, clipPoint, -radiusA, normal);
                                points[i] = Vec2.mid(cA, cB);
                                separations[i] = Vec2.dot(Vec2.sub(cA, cB), normal);
                            }
                            points.length = this.pointCount;
                            separations.length = this.pointCount;
                            // Ensure normal points from A to B.
                            normal.mul(-1);
                            break;
                    }
                    wm.normal = normal;
                    wm.points = points;
                    wm.separations = separations;
                    return wm;
                };

                /**
                 * This is used for determining the state of contact points.
                 * 
                 * @prop {0} nullState Point does not exist
                 * @prop {1} addState Point was added in the update
                 * @prop {2} persistState Point persisted across the update
                 * @prop {3} removeState Point was removed in the update
                 */
                var PointState = {
                    // TODO: use constants
                    nullState: 0,
                    addState: 1,
                    persistState: 2,
                    removeState: 3
                };

                /**
                 * Compute the point states given two manifolds. The states pertain to the
                 * transition from manifold1 to manifold2. So state1 is either persist or remove
                 * while state2 is either add or persist.
                 * 
                 * @param {PointState[Settings.maxManifoldPoints]} state1
                 * @param {PointState[Settings.maxManifoldPoints]} state2
                 */
                function getPointStates(state1, state2, manifold1, manifold2) {
                    // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {
                    // state1[i] = PointState.nullState;
                    // state2[i] = PointState.nullState;
                    // }
                    // Detect persists and removes.
                    for (var i = 0; i < manifold1.pointCount; ++i) {
                        var id = manifold1.points[i].id;
                        // ContactID
                        state1[i] = PointState.removeState;
                        for (var j = 0; j < manifold2.pointCount; ++j) {
                            if (manifold2.points[j].id.key == id.key) {
                                state1[i] = PointState.persistState;
                                break;
                            }
                        }
                    }
                    // Detect persists and adds.
                    for (var i = 0; i < manifold2.pointCount; ++i) {
                        var id = manifold2.points[i].id;
                        // ContactID
                        state2[i] = PointState.addState;
                        for (var j = 0; j < manifold1.pointCount; ++j) {
                            if (manifold1.points[j].id.key == id.key) {
                                state2[i] = PointState.persistState;
                                break;
                            }
                        }
                    }
                }

                /**
                 * Used for computing contact manifolds.
                 * 
                 * @prop {Vec2} v
                 * @prop {ContactID} id
                 */
                function ClipVertex() {
                    this.v = Vec2.zero();
                    this.id = new ContactID();
                }

                ClipVertex.prototype.set = function (o) {
                    this.v.set(o.v);
                    this.id.set(o.id);
                };

                /**
                 * Clipping for contact manifolds. Sutherland-Hodgman clipping.
                 * 
                 * @param {ClipVertex[2]} vOut
                 * @param {ClipVertex[2]} vIn
                 */
                function clipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {
                    // Start with no output points
                    var numOut = 0;
                    // Calculate the distance of end points to the line
                    var distance0 = Vec2.dot(normal, vIn[0].v) - offset;
                    var distance1 = Vec2.dot(normal, vIn[1].v) - offset;
                    // If the points are behind the plane
                    if (distance0 <= 0) vOut[numOut++].set(vIn[0]);
                    if (distance1 <= 0) vOut[numOut++].set(vIn[1]);
                    // If the points are on different sides of the plane
                    if (distance0 * distance1 < 0) {
                        // Find intersection point of edge and plane
                        var interp = distance0 / (distance0 - distance1);
                        vOut[numOut].v.wSet(1 - interp, vIn[0].v, interp, vIn[1].v);
                        // VertexA is hitting edgeB.
                        vOut[numOut].id.cf.indexA = vertexIndexA;
                        vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;
                        vOut[numOut].id.cf.typeA = ContactFeature.e_vertex;
                        vOut[numOut].id.cf.typeB = ContactFeature.e_face;
                        ++numOut;
                    }
                    return numOut;
                }
            }, { "./common/Math": 18, "./common/Rot": 20, "./common/Transform": 22, "./common/Vec2": 23, "./util/common": 50 }], 7: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                // TODO merge with World options?
                var Settings = exports;

                /**
                 * Tuning constants based on meters-kilograms-seconds (MKS) units.
                 */
                // Collision
                /**
                 * The maximum number of contact points between two convex shapes. Do not change
                 * this value.
                 */
                Settings.maxManifoldPoints = 2;

                /**
                 * The maximum number of vertices on a convex polygon. You cannot increase this
                 * too much because BlockAllocator has a maximum object size.
                 */
                Settings.maxPolygonVertices = 12;

                /**
                 * This is used to fatten AABBs in the dynamic tree. This allows proxies to move
                 * by a small amount without triggering a tree adjustment. This is in meters.
                 */
                Settings.aabbExtension = .1;

                /**
                 * This is used to fatten AABBs in the dynamic tree. This is used to predict the
                 * future position based on the current displacement. This is a dimensionless
                 * multiplier.
                 */
                Settings.aabbMultiplier = 2;

                /**
                 * A small length used as a collision and constraint tolerance. Usually it is
                 * chosen to be numerically significant, but visually insignificant.
                 */
                Settings.linearSlop = .005;

                Settings.linearSlopSquared = Settings.linearSlop * Settings.linearSlop;

                /**
                 * A small angle used as a collision and constraint tolerance. Usually it is
                 * chosen to be numerically significant, but visually insignificant.
                 */
                Settings.angularSlop = 2 / 180 * Math.PI;

                /**
                 * The radius of the polygon/edge shape skin. This should not be modified.
                 * Making this smaller means polygons will have an insufficient buffer for
                 * continuous collision. Making it larger may create artifacts for vertex
                 * collision.
                 */
                Settings.polygonRadius = 2 * Settings.linearSlop;

                /**
                 * Maximum number of sub-steps per contact in continuous physics simulation.
                 */
                Settings.maxSubSteps = 8;

                // Dynamics
                /**
                 * Maximum number of contacts to be handled to solve a TOI impact.
                 */
                Settings.maxTOIContacts = 32;

                /**
                 * Maximum iterations to solve a TOI.
                 */
                Settings.maxTOIIterations = 20;

                /**
                 * Maximum iterations to find Distance.
                 */
                Settings.maxDistnceIterations = 20;

                /**
                 * A velocity threshold for elastic collisions. Any collision with a relative
                 * linear velocity below this threshold will be treated as inelastic.
                 */
                Settings.velocityThreshold = 1;

                /**
                 * The maximum linear position correction used when solving constraints. This
                 * helps to prevent overshoot.
                 */
                Settings.maxLinearCorrection = .2;

                /**
                 * The maximum angular position correction used when solving constraints. This
                 * helps to prevent overshoot.
                 */
                Settings.maxAngularCorrection = 8 / 180 * Math.PI;

                /**
                 * The maximum linear velocity of a body. This limit is very large and is used
                 * to prevent numerical problems. You shouldn't need to adjust this.
                 */
                Settings.maxTranslation = 2;

                Settings.maxTranslationSquared = Settings.maxTranslation * Settings.maxTranslation;

                /**
                 * The maximum angular velocity of a body. This limit is very large and is used
                 * to prevent numerical problems. You shouldn't need to adjust this.
                 */
                Settings.maxRotation = .5 * Math.PI;

                Settings.maxRotationSquared = Settings.maxRotation * Settings.maxRotation;

                /**
                 * This scale factor controls how fast overlap is resolved. Ideally this would
                 * be 1 so that overlap is removed in one time step. However using values close
                 * to 1 often lead to overshoot.
                 */
                Settings.baumgarte = .2;

                Settings.toiBaugarte = .75;

                // Sleep
                /**
                 * The time that a body must be still before it will go to sleep.
                 */
                Settings.timeToSleep = .5;

                /**
                 * A body cannot sleep if its linear velocity is above this tolerance.
                 */
                Settings.linearSleepTolerance = .01;

                Settings.linearSleepToleranceSqr = Math.pow(Settings.linearSleepTolerance, 2);

                /**
                 * A body cannot sleep if its angular velocity is above this tolerance.
                 */
                Settings.angularSleepTolerance = 2 / 180 * Math.PI;

                Settings.angularSleepToleranceSqr = Math.pow(Settings.angularSleepTolerance, 2);
            }, {}], 8: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Shape;

                var Math = require("./common/Math");

                /**
                 * A shape is used for collision detection. You can create a shape however you
                 * like. Shapes used for simulation in World are created automatically when a
                 * Fixture is created. Shapes may encapsulate one or more child shapes.
                 */
                function Shape() {
                    this.m_type;
                    this.m_radius;
                }

                Shape.isValid = function (shape) {
                    return !!shape;
                };

                Shape.prototype.getRadius = function () {
                    return this.m_radius;
                };

                /**
                 * Get the type of this shape. You can use this to down cast to the concrete
                 * shape.
                 * 
                 * @return the shape type.
                 */
                Shape.prototype.getType = function () {
                    return this.m_type;
                };

                /**
                 * @deprecated
                 *
                 * clone the concrete shape.
                 */
                Shape.prototype._clone = function () {};

                /**
                 * // Get the number of child primitives.
                 */
                Shape.prototype.getChildCount = function () {};

                /**
                 * Test a point for containment in this shape. This only works for convex
                 * shapes.
                 * 
                 * @param {Transform} xf The shape world transform.
                 * @param p A point in world coordinates.
                 */
                Shape.prototype.testPoint = function (xf, p) {};

                /**
                 * Cast a ray against a child shape.
                 * 
                 * @param {RayCastOutput} output The ray-cast results.
                 * @param {RayCastInput} input The ray-cast input parameters.
                 * @param {Transform} transform The transform to be applied to the shape.
                 * @param childIndex The child shape index
                 */
                Shape.prototype.rayCast = function (output, input, transform, childIndex) {};

                /**
                 * Given a transform, compute the associated axis aligned bounding box for a
                 * child shape.
                 * 
                 * @param {AABB} aabb Returns the axis aligned box.
                 * @param {Transform} xf The world transform of the shape.
                 * @param childIndex The child shape
                 */
                Shape.prototype.computeAABB = function (aabb, xf, childIndex) {};

                /**
                 * Compute the mass properties of this shape using its dimensions and density.
                 * The inertia tensor is computed about the local origin.
                 * 
                 * @param {MassData} massData Returns the mass data for this shape.
                 * @param density The density in kilograms per meter squared.
                 */
                Shape.prototype.computeMass = function (massData, density) {};

                /**
                 * @param {DistanceProxy} proxy
                 */
                Shape.prototype.computeDistanceProxy = function (proxy) {};
            }, { "./common/Math": 18 }], 9: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof //ASSERT === "undefined" ? false : ASSERT;

                module.exports = Solver;

                module.exports.TimeStep = TimeStep;

                var Settings = require("./Settings");

                var common = require("./util/common");

                var Timer = require("./util/Timer");

                var Vec2 = require("./common/Vec2");

                var Math = require("./common/Math");

                var Body = require("./Body");

                var Contact = require("./Contact");

                var Joint = require("./Joint");

                var TimeOfImpact = require("./collision/TimeOfImpact");

                var TOIInput = TimeOfImpact.Input;

                var TOIOutput = TimeOfImpact.Output;

                var Distance = require("./collision/Distance");

                var DistanceInput = Distance.Input;

                var DistanceOutput = Distance.Output;

                var DistanceProxy = Distance.Proxy;

                var SimplexCache = Distance.Cache;

                /**
                 * Profiling data. Times are in milliseconds.
                 */
                function Profile() {
                    this.solveInit;
                    this.solveVelocity;
                    this.solvePosition;
                }

                function TimeStep(dt) {
                    this.dt = 0;
                    // time step
                    this.inv_dt = 0;
                    // inverse time step (0 if dt == 0)
                    this.velocityIterations = 0;
                    this.positionIterations = 0;
                    this.warmStarting = false;
                    this.blockSolve = true;
                    // timestep ratio for variable timestep
                    this.inv_dt0 = 0;
                    this.dtRatio = 1;
                }

                TimeStep.prototype.reset = function (dt) {
                    if (this.dt > 0) {
                        this.inv_dt0 = this.inv_dt;
                    }
                    this.dt = dt;
                    this.inv_dt = dt == 0 ? 0 : 1 / dt;
                    this.dtRatio = dt * this.inv_dt0;
                };

                /**
                 * Finds and solves islands. An island is a connected subset of the world.
                 * 
                 * @param {World} world
                 * @param {Profile} profile
                 */
                function Solver(world) {
                    this.m_world = world;
                    this.m_profile = new Profile();
                    this.m_stack = [];
                    this.m_bodies = [];
                    this.m_contacts = [];
                    this.m_joints = [];
                }

                Solver.prototype.clear = function () {
                    this.m_stack.length = 0;
                    this.m_bodies.length = 0;
                    this.m_contacts.length = 0;
                    this.m_joints.length = 0;
                };

                Solver.prototype.addBody = function (body) {
                    //ASSERT && common.assert(body instanceof Body, "Not a Body!", body);
                    this.m_bodies.push(body);
                };

                Solver.prototype.addContact = function (contact) {
                    //ASSERT && common.assert(contact instanceof Contact, "Not a Contact!", contact);
                    this.m_contacts.push(contact);
                };

                Solver.prototype.addJoint = function (joint) {
                    //ASSERT && common.assert(joint instanceof Joint, "Not a Joint!", joint);
                    this.m_joints.push(joint);
                };

                /**
                 * @param {TimeStep} step
                 */
                Solver.prototype.solveWorld = function (step) {
                    var world = this.m_world;
                    var profile = this.m_profile;
                    profile.solveInit = 0;
                    profile.solveVelocity = 0;
                    profile.solvePosition = 0;
                    // Clear all the island flags.
                    for (var b = world.m_bodyList; b; b = b.m_next) {
                        b.m_islandFlag = false;
                    }
                    for (var c = world.m_contactList; c; c = c.m_next) {
                        c.m_islandFlag = false;
                    }
                    for (var j = world.m_jointList; j; j = j.m_next) {
                        j.m_islandFlag = false;
                    }
                    // Build and simulate all awake islands.
                    var stack = this.m_stack;
                    var loop = -1;
                    for (var seed = world.m_bodyList; seed; seed = seed.m_next) {
                        loop++;
                        if (seed.m_islandFlag) {
                            continue;
                        }
                        if (seed.isAwake() == false || seed.isActive() == false) {
                            continue;
                        }
                        // The seed can be dynamic or kinematic.
                        if (seed.isStatic()) {
                            continue;
                        }
                        // Reset island and stack.
                        this.clear();
                        stack.push(seed);
                        seed.m_islandFlag = true;
                        // Perform a depth first search (DFS) on the constraint graph.
                        while (stack.length > 0) {
                            // Grab the next body off the stack and add it to the island.
                            var b = stack.pop();
                            //ASSERT && common.assert(b.isActive() == true);
                            this.addBody(b);
                            // Make sure the body is awake.
                            b.setAwake(true);
                            // To keep islands as small as possible, we don't
                            // propagate islands across static bodies.
                            if (b.isStatic()) {
                                continue;
                            }
                            // Search all contacts connected to this body.
                            for (var ce = b.m_contactList; ce; ce = ce.next) {
                                var contact = ce.contact;
                                // Has this contact already been added to an island?
                                if (contact.m_islandFlag) {
                                    continue;
                                }
                                // Is this contact solid and touching?
                                if (contact.isEnabled() == false || contact.isTouching() == false) {
                                    continue;
                                }
                                // Skip sensors.
                                var sensorA = contact.m_fixtureA.m_isSensor;
                                var sensorB = contact.m_fixtureB.m_isSensor;
                                if (sensorA || sensorB) {
                                    continue;
                                }
                                this.addContact(contact);
                                contact.m_islandFlag = true;
                                var other = ce.other;
                                // Was the other body already added to this island?
                                if (other.m_islandFlag) {
                                    continue;
                                }
                                // ASSERT && common.assert(stack.length < world.m_bodyCount);
                                stack.push(other);
                                other.m_islandFlag = true;
                            }
                            // Search all joints connect to this body.
                            for (var je = b.m_jointList; je; je = je.next) {
                                if (je.joint.m_islandFlag == true) {
                                    continue;
                                }
                                var other = je.other;
                                // Don't simulate joints connected to inactive bodies.
                                if (other.isActive() == false) {
                                    continue;
                                }
                                this.addJoint(je.joint);
                                je.joint.m_islandFlag = true;
                                if (other.m_islandFlag) {
                                    continue;
                                }
                                // ASSERT && common.assert(stack.length < world.m_bodyCount);
                                stack.push(other);
                                other.m_islandFlag = true;
                            }
                        }
                        this.solveIsland(step);
                        // Post solve cleanup.
                        for (var i = 0; i < this.m_bodies.length; ++i) {
                            // Allow static bodies to participate in other islands.
                            // TODO: are they added at all?
                            var b = this.m_bodies[i];
                            if (b.isStatic()) {
                                b.m_islandFlag = false;
                            }
                        }
                    }
                };

                /**
                 * @param {TimeStep} step
                 */
                Solver.prototype.solveIsland = function (step) {
                    var world = this.m_world;
                    var profile = this.m_profile;
                    var gravity = world.m_gravity;
                    var allowSleep = world.m_allowSleep;
                    var timer = Timer.now();
                    var h = step.dt;
                    // Integrate velocities and apply damping. Initialize the body state.
                    for (var i = 0; i < this.m_bodies.length; ++i) {
                        var body = this.m_bodies[i];
                        var c = Vec2.clone(body.m_sweep.c);
                        var a = body.m_sweep.a;
                        var v = Vec2.clone(body.m_linearVelocity);
                        var w = body.m_angularVelocity;
                        // Store positions for continuous collision.
                        body.m_sweep.c0.set(body.m_sweep.c);
                        body.m_sweep.a0 = body.m_sweep.a;
                        //DEBUG && common.debug("P: ", a, c.x, c.y, w, v.x, v.y);
                        if (body.isDynamic()) {
                            // Integrate velocities.
                            v.wAdd(h * body.m_gravityScale, gravity);
                            v.wAdd(h * body.m_invMass, body.m_force);
                            w += h * body.m_invI * body.m_torque;
                            //DEBUG && common.debug("N: " + h, body.m_gravityScale, gravity.x, gravity.y, body.m_invMass, body.m_force.x, body.m_force.y);
                            /**
                            * <pre>
                            * Apply damping.
                            * ODE: dv/dt + c * v = 0
                            * Solution: v(t) = v0 * exp(-c * t)
                            * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
                            * v2 = exp(-c * dt) * v1
                            * Pade approximation:
                            * v2 = v1 * 1 / (1 + c * dt)
                            * </pre>
                            */
                            v.mul(1 / (1 + h * body.m_linearDamping));
                            w *= 1 / (1 + h * body.m_angularDamping);
                        }
                        //common.debug("A: ", a, c.x, c.y, w, v.x, v.y);
                        body.c_position.c = c;
                        body.c_position.a = a;
                        body.c_velocity.v = v;
                        body.c_velocity.w = w;
                    }
                    timer = Timer.now();
                    for (var i = 0; i < this.m_contacts.length; ++i) {
                        var contact = this.m_contacts[i];
                        contact.initConstraint(step);
                    }
                    //DEBUG && this.printBodies("M: ");
                    for (var i = 0; i < this.m_contacts.length; ++i) {
                        var contact = this.m_contacts[i];
                        contact.initVelocityConstraint(step);
                    }
                    //DEBUG && this.printBodies("R: ");
                    if (step.warmStarting) {
                        // Warm start.
                        for (var i = 0; i < this.m_contacts.length; ++i) {
                            var contact = this.m_contacts[i];
                            contact.warmStartConstraint(step);
                        }
                    }
                    //DEBUG && this.printBodies("Q: ");
                    for (var i = 0; i < this.m_joints.length; ++i) {
                        var joint = this.m_joints[i];
                        joint.initVelocityConstraints(step);
                    }
                    //DEBUG && this.printBodies("E: ");
                    profile.solveInit = Timer.diff(timer);
                    // Solve velocity constraints
                    timer = Timer.now();
                    for (var i = 0; i < step.velocityIterations; ++i) {
                        //DEBUG && common.debug("--", i);
                        for (var j = 0; j < this.m_joints.length; ++j) {
                            var joint = this.m_joints[j];
                            joint.solveVelocityConstraints(step);
                        }
                        for (var j = 0; j < this.m_contacts.length; ++j) {
                            var contact = this.m_contacts[j];
                            contact.solveVelocityConstraint(step);
                        }
                    }
                    //DEBUG && this.printBodies("D: ");
                    // Store impulses for warm starting
                    for (var i = 0; i < this.m_contacts.length; ++i) {
                        var contact = this.m_contacts[i];
                        contact.storeConstraintImpulses(step);
                    }
                    profile.solveVelocity = Timer.diff(timer);
                    //DEBUG && this.printBodies("C: ");
                    // Integrate positions
                    for (var i = 0; i < this.m_bodies.length; ++i) {
                        var body = this.m_bodies[i];
                        var c = Vec2.clone(body.c_position.c);
                        var a = body.c_position.a;
                        var v = Vec2.clone(body.c_velocity.v);
                        var w = body.c_velocity.w;
                        // Check for large velocities
                        var translation = Vec2.mul(h, v);
                        if (Vec2.lengthSquared(translation) > Settings.maxTranslationSquared) {
                            var ratio = Settings.maxTranslation / translation.length();
                            v.mul(ratio);
                        }
                        var rotation = h * w;
                        if (rotation * rotation > Settings.maxRotationSquared) {
                            var ratio = Settings.maxRotation / Math.abs(rotation);
                            w *= ratio;
                        }
                        // Integrate
                        c.wAdd(h, v);
                        a += h * w;
                        body.c_position.c.set(c);
                        body.c_position.a = a;
                        body.c_velocity.v.set(v);
                        body.c_velocity.w = w;
                    }
                    //DEBUG && this.printBodies("B: ");
                    // Solve position constraints
                    timer = Timer.now();
                    var positionSolved = false;
                    for (var i = 0; i < step.positionIterations; ++i) {
                        var minSeparation = 0;
                        for (var j = 0; j < this.m_contacts.length; ++j) {
                            var contact = this.m_contacts[j];
                            var separation = contact.solvePositionConstraint(step);
                            minSeparation = Math.min(minSeparation, separation);
                        }
                        // We can't expect minSpeparation >= -Settings.linearSlop because we don't
                        // push the separation above -Settings.linearSlop.
                        var contactsOkay = minSeparation >= -3 * Settings.linearSlop;
                        var jointsOkay = true;
                        for (var j = 0; j < this.m_joints.length; ++j) {
                            var joint = this.m_joints[j];
                            var jointOkay = joint.solvePositionConstraints(step);
                            jointsOkay = jointsOkay && jointOkay;
                        }
                        if (contactsOkay && jointsOkay) {
                            // Exit early if the position errors are small.
                            positionSolved = true;
                            break;
                        }
                    }
                    //DEBUG && this.printBodies("L: ");
                    // Copy state buffers back to the bodies
                    for (var i = 0; i < this.m_bodies.length; ++i) {
                        var body = this.m_bodies[i];
                        body.m_sweep.c.set(body.c_position.c);
                        body.m_sweep.a = body.c_position.a;
                        body.m_linearVelocity.set(body.c_velocity.v);
                        body.m_angularVelocity = body.c_velocity.w;
                        body.synchronizeTransform();
                    }
                    profile.solvePosition = Timer.diff(timer);
                    this.postSolveIsland();
                    if (allowSleep) {
                        var minSleepTime = Infinity;
                        var linTolSqr = Settings.linearSleepToleranceSqr;
                        var angTolSqr = Settings.angularSleepToleranceSqr;
                        for (var i = 0; i < this.m_bodies.length; ++i) {
                            var body = this.m_bodies[i];
                            if (body.isStatic()) {
                                continue;
                            }
                            if (body.m_autoSleepFlag == false || body.m_angularVelocity * body.m_angularVelocity > angTolSqr || Vec2.lengthSquared(body.m_linearVelocity) > linTolSqr) {
                                body.m_sleepTime = 0;
                                minSleepTime = 0;
                            } else {
                                body.m_sleepTime += h;
                                minSleepTime = Math.min(minSleepTime, body.m_sleepTime);
                            }
                        }
                        if (minSleepTime >= Settings.timeToSleep && positionSolved) {
                            for (var i = 0; i < this.m_bodies.length; ++i) {
                                var body = this.m_bodies[i];
                                body.setAwake(false);
                            }
                        }
                    }
                };

                Solver.prototype.printBodies = function (tag) {
                    for (var i = 0; i < this.m_bodies.length; ++i) {
                        var b = this.m_bodies[i];
                        //common.debug(tag, b.c_position.a, b.c_position.c.x, b.c_position.c.y, b.c_velocity.w, b.c_velocity.v.x, b.c_velocity.v.y);
                    }
                };

                var s_subStep = new TimeStep();

                // reuse
                /**
                 * Find TOI contacts and solve them.
                 *
                 * @param {TimeStep} step
                 */
                Solver.prototype.solveWorldTOI = function (step) {
                    //DEBUG && common.debug("TOI++++++World");
                    var world = this.m_world;
                    var profile = this.m_profile;
                    //DEBUG && common.debug("Z:", world.m_stepComplete);
                    if (world.m_stepComplete) {
                        for (var b = world.m_bodyList; b; b = b.m_next) {
                            b.m_islandFlag = false;
                            b.m_sweep.alpha0 = 0;
                            //DEBUG && common.debug("b.alpha0:", b.m_sweep.alpha0);
                        }
                        for (var c = world.m_contactList; c; c = c.m_next) {
                            // Invalidate TOI
                            c.m_toiFlag = false;
                            c.m_islandFlag = false;
                            c.m_toiCount = 0;
                            c.m_toi = 1;
                        }
                    }
                    //if (DEBUG) for (var c = world.m_contactList; c; c = c.m_next) {
                    //DEBUG && common.debug("X:", c.m_toiFlag);
                    //}
                    // Find TOI events and solve them.
                    for (;;) {
                        //DEBUG && common.debug(";;");
                        // Find the first TOI.
                        var minContact = null;
                        // Contact
                        var minAlpha = 1;
                        for (var c = world.m_contactList; c; c = c.m_next) {
                            //DEBUG && common.debug("alpha0::", c.getFixtureA().getBody().m_sweep.alpha0, c.getFixtureB().getBody().m_sweep.alpha0);
                            // Is this contact disabled?
                            if (c.isEnabled() == false) {
                                continue;
                            }
                            // && common.debug("toiCount:", c.m_toiCount, Settings.maxSubSteps);
                            // Prevent excessive sub-stepping.
                            if (c.m_toiCount > Settings.maxSubSteps) {
                                continue;
                            }
                            //DEBUG && common.debug("toiFlag:", c.m_toiFlag);
                            var alpha = 1;
                            if (c.m_toiFlag) {
                                // This contact has a valid cached TOI.
                                alpha = c.m_toi;
                            } else {
                                var fA = c.getFixtureA();
                                var fB = c.getFixtureB();
                                //DEBUG && common.debug("sensor:", fA.isSensor(), fB.isSensor());
                                // Is there a sensor?
                                if (fA.isSensor() || fB.isSensor()) {
                                    continue;
                                }
                                var bA = fA.getBody();
                                var bB = fB.getBody();
                                //ASSERT && common.assert(bA.isDynamic() || bB.isDynamic());
                                var activeA = bA.isAwake() && !bA.isStatic();
                                var activeB = bB.isAwake() && !bB.isStatic();
                                //DEBUG && common.debug("awakestatic:", bA.isAwake(), bA.isStatic());
                                //DEBUG && common.debug("awakestatic:", bB.isAwake(), bB.isStatic());
                                //DEBUG && common.debug("active:", activeA, activeB);
                                // Is at least one body active (awake and dynamic or kinematic)?
                                if (activeA == false && activeB == false) {
                                    continue;
                                }
                                //DEBUG && common.debug("alpha:", alpha, bA.m_sweep.alpha0, bB.m_sweep.alpha0);
                                var collideA = bA.isBullet() || !bA.isDynamic();
                                var collideB = bB.isBullet() || !bB.isDynamic();
                                //DEBUG && common.debug("collide:", collideA, collideB);
                                // Are these two non-bullet dynamic bodies?
                                if (collideA == false && collideB == false) {
                                    continue;
                                }
                                // Compute the TOI for this contact.
                                // Put the sweeps onto the same time interval.
                                var alpha0 = bA.m_sweep.alpha0;
                                if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
                                    alpha0 = bB.m_sweep.alpha0;
                                    bA.m_sweep.advance(alpha0);
                                } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
                                    alpha0 = bA.m_sweep.alpha0;
                                    bB.m_sweep.advance(alpha0);
                                }
                                //DEBUG && common.debug("alpha0:", alpha0, bA.m_sweep.alpha0, bB.m_sweep.alpha0);
                                //ASSERT && common.assert(alpha0 < 1);
                                var indexA = c.getChildIndexA();
                                var indexB = c.getChildIndexB();
                                var sweepA = bA.m_sweep;
                                var sweepB = bB.m_sweep;
                                //DEBUG && common.debug("sweepA", sweepA.localCenter.x, sweepA.localCenter.y, sweepA.c.x, sweepA.c.y, sweepA.a, sweepA.alpha0, sweepA.c0.x, sweepA.c0.y, sweepA.a0);
                                //DEBUG && common.debug("sweepB", sweepB.localCenter.x, sweepB.localCenter.y, sweepB.c.x, sweepB.c.y, sweepB.a, sweepB.alpha0, sweepB.c0.x, sweepB.c0.y, sweepB.a0);
                                // Compute the time of impact in interval [0, minTOI]
                                var input = new TOIInput();
                                // TODO: reuse
                                input.proxyA.set(fA.getShape(), indexA);
                                input.proxyB.set(fB.getShape(), indexB);
                                input.sweepA.set(bA.m_sweep);
                                input.sweepB.set(bB.m_sweep);
                                input.tMax = 1;
                                var output = new TOIOutput();
                                // TODO: reuse
                                TimeOfImpact(output, input);
                                // DEBUG && common.debug(output.t, output.state);
                                // Beta is the fraction of the remaining portion of the [time?].
                                var beta = output.t;
                                //DEBUG && common.debug("state:", output.state, TOIOutput.e_touching);
                                if (output.state == TOIOutput.e_touching) {
                                    alpha = Math.min(alpha0 + (1 - alpha0) * beta, 1);
                                } else {
                                    alpha = 1;
                                }
                                c.m_toi = alpha;
                                c.m_toiFlag = true;
                            }
                            //DEBUG && common.debug("minAlpha:", minAlpha, alpha);
                            if (alpha < minAlpha) {
                                // This is the minimum TOI found so far.
                                minContact = c;
                                minAlpha = alpha;
                            }
                        }
                        //DEBUG && common.debug("minContact:", minContact == null, 1 - 10 * Math.EPSILON < minAlpha, minAlpha);
                        if (minContact == null || 1 - 10 * Math.EPSILON < minAlpha) {
                            // No more TOI events. Done!
                            world.m_stepComplete = true;
                            break;
                        }
                        // Advance the bodies to the TOI.
                        var fA = minContact.getFixtureA();
                        var fB = minContact.getFixtureB();
                        var bA = fA.getBody();
                        var bB = fB.getBody();
                        var backup1 = bA.m_sweep.clone();
                        var backup2 = bB.m_sweep.clone();
                        bA.advance(minAlpha);
                        bB.advance(minAlpha);
                        // The TOI contact likely has some new contact points.
                        minContact.update(world);
                        minContact.m_toiFlag = false;
                        ++minContact.m_toiCount;
                        // Is the contact solid?
                        if (minContact.isEnabled() == false || minContact.isTouching() == false) {
                            // Restore the sweeps.
                            minContact.setEnabled(false);
                            bA.m_sweep.set(backup1);
                            bB.m_sweep.set(backup2);
                            bA.synchronizeTransform();
                            bB.synchronizeTransform();
                            continue;
                        }
                        bA.setAwake(true);
                        bB.setAwake(true);
                        // Build the island
                        this.clear();
                        this.addBody(bA);
                        this.addBody(bB);
                        this.addContact(minContact);
                        bA.m_islandFlag = true;
                        bB.m_islandFlag = true;
                        minContact.m_islandFlag = true;
                        // Get contacts on bodyA and bodyB.
                        var bodies = [bA, bB];
                        for (var i = 0; i < bodies.length; ++i) {
                            var body = bodies[i];
                            if (body.isDynamic()) {
                                for (var ce = body.m_contactList; ce; ce = ce.next) {
                                    // if (this.m_bodyCount == this.m_bodyCapacity) { break; }
                                    // if (this.m_contactCount == this.m_contactCapacity) { break; }
                                    var contact = ce.contact;
                                    // Has this contact already been added to the island?
                                    if (contact.m_islandFlag) {
                                        continue;
                                    }
                                    // Only add if either is static, kinematic or bullet.
                                    var other = ce.other;
                                    if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {
                                        continue;
                                    }
                                    // Skip sensors.
                                    var sensorA = contact.m_fixtureA.m_isSensor;
                                    var sensorB = contact.m_fixtureB.m_isSensor;
                                    if (sensorA || sensorB) {
                                        continue;
                                    }
                                    // Tentatively advance the body to the TOI.
                                    var backup = other.m_sweep.clone();
                                    if (other.m_islandFlag == false) {
                                        other.advance(minAlpha);
                                    }
                                    // Update the contact points
                                    contact.update(world);
                                    // Was the contact disabled by the user?
                                    // Are there contact points?
                                    if (contact.isEnabled() == false || contact.isTouching() == false) {
                                        other.m_sweep.set(backup);
                                        other.synchronizeTransform();
                                        continue;
                                    }
                                    // Add the contact to the island
                                    contact.m_islandFlag = true;
                                    this.addContact(contact);
                                    // Has the other body already been added to the island?
                                    if (other.m_islandFlag) {
                                        continue;
                                    }
                                    // Add the other body to the island.
                                    other.m_islandFlag = true;
                                    if (!other.isStatic()) {
                                        other.setAwake(true);
                                    }
                                    this.addBody(other);
                                }
                            }
                        }
                        s_subStep.reset((1 - minAlpha) * step.dt);
                        s_subStep.dtRatio = 1;
                        s_subStep.positionIterations = 20;
                        s_subStep.velocityIterations = step.velocityIterations;
                        s_subStep.warmStarting = false;
                        this.solveIslandTOI(s_subStep, bA, bB);
                        // Reset island flags and synchronize broad-phase proxies.
                        for (var i = 0; i < this.m_bodies.length; ++i) {
                            var body = this.m_bodies[i];
                            body.m_islandFlag = false;
                            if (!body.isDynamic()) {
                                continue;
                            }
                            body.synchronizeFixtures();
                            // Invalidate all contact TOIs on this displaced body.
                            for (var ce = body.m_contactList; ce; ce = ce.next) {
                                ce.contact.m_toiFlag = false;
                                ce.contact.m_islandFlag = false;
                            }
                        }
                        // Commit fixture proxy movements to the broad-phase so that new contacts
                        // are created.
                        // Also, some contacts can be destroyed.
                        world.findNewContacts();
                        if (world.m_subStepping) {
                            world.m_stepComplete = false;
                            break;
                        }
                    }
                    //if (DEBUG) for (var b = world.m_bodyList; b; b = b.m_next) {
                    //    var c = b.m_sweep.c;
                    //    var a = b.m_sweep.a;
                    //    var v = b.m_linearVelocity;
                    //    var w = b.m_angularVelocity;
                    //    DEBUG && common.debug("== ", a, c.x, c.y, w, v.x, v.y);
                    //}
                };

                /**
                 * @param {TimeStep} subStep
                 * @param toiA
                 * @param toiB
                 */
                Solver.prototype.solveIslandTOI = function (subStep, toiA, toiB) {
                    //DEBUG && common.debug("TOI++++++Island");
                    var world = this.m_world;
                    var profile = this.m_profile;
                    // Initialize the body state.
                    for (var i = 0; i < this.m_bodies.length; ++i) {
                        var body = this.m_bodies[i];
                        body.c_position.c.set(body.m_sweep.c);
                        body.c_position.a = body.m_sweep.a;
                        body.c_velocity.v.set(body.m_linearVelocity);
                        body.c_velocity.w = body.m_angularVelocity;
                    }
                    for (var i = 0; i < this.m_contacts.length; ++i) {
                        var contact = this.m_contacts[i];
                        contact.initConstraint(subStep);
                    }
                    // Solve position constraints.
                    for (var i = 0; i < subStep.positionIterations; ++i) {
                        var minSeparation = 0;
                        for (var j = 0; j < this.m_contacts.length; ++j) {
                            var contact = this.m_contacts[j];
                            var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);
                            minSeparation = Math.min(minSeparation, separation);
                        }
                        // We can't expect minSpeparation >= -Settings.linearSlop because we don't
                        // push the separation above -Settings.linearSlop.
                        var contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;
                        if (contactsOkay) {
                            break;
                        }
                    }
                    if (false) {
                        // Is the new position really safe?
                        for (var i = 0; i < this.m_contacts.length; ++i) {
                            var c = this.m_contacts[i];
                            var fA = c.getFixtureA();
                            var fB = c.getFixtureB();
                            var bA = fA.getBody();
                            var bB = fB.getBody();
                            var indexA = c.getChildIndexA();
                            var indexB = c.getChildIndexB();
                            var input = new DistanceInput();
                            input.proxyA.set(fA.getShape(), indexA);
                            input.proxyB.set(fB.getShape(), indexB);
                            input.transformA = bA.getTransform();
                            input.transformB = bB.getTransform();
                            input.useRadii = false;
                            var output = new DistanceOutput();
                            var cache = new SimplexCache();
                            Distance(output, cache, input);
                            if (output.distance == 0 || cache.count == 3) {
                                cache.count += 0;
                            }
                        }
                    }
                    // Leap of faith to new safe state.
                    toiA.m_sweep.c0.set(toiA.c_position.c);
                    toiA.m_sweep.a0 = toiA.c_position.a;
                    toiB.m_sweep.c0.set(toiB.c_position.c);
                    toiB.m_sweep.a0 = toiB.c_position.a;
                    // No warm starting is needed for TOI events because warm
                    // starting impulses were applied in the discrete solver.
                    for (var i = 0; i < this.m_contacts.length; ++i) {
                        var contact = this.m_contacts[i];
                        contact.initVelocityConstraint(subStep);
                    }
                    // Solve velocity constraints.
                    for (var i = 0; i < subStep.velocityIterations; ++i) {
                        for (var j = 0; j < this.m_contacts.length; ++j) {
                            var contact = this.m_contacts[j];
                            contact.solveVelocityConstraint(subStep);
                        }
                    }
                    // Don't store the TOI contact forces for warm starting
                    // because they can be quite large.
                    var h = subStep.dt;
                    // Integrate positions
                    for (var i = 0; i < this.m_bodies.length; ++i) {
                        var body = this.m_bodies[i];
                        var c = Vec2.clone(body.c_position.c);
                        var a = body.c_position.a;
                        var v = Vec2.clone(body.c_velocity.v);
                        var w = body.c_velocity.w;
                        // Check for large velocities
                        var translation = Vec2.mul(h, v);
                        if (Vec2.dot(translation, translation) > Settings.maxTranslationSquared) {
                            var ratio = Settings.maxTranslation / translation.length();
                            v.mul(ratio);
                        }
                        var rotation = h * w;
                        if (rotation * rotation > Settings.maxRotationSquared) {
                            var ratio = Settings.maxRotation / Math.abs(rotation);
                            w *= ratio;
                        }
                        // Integrate
                        c.wAdd(h, v);
                        a += h * w;
                        body.c_position.c = c;
                        body.c_position.a = a;
                        body.c_velocity.v = v;
                        body.c_velocity.w = w;
                        // Sync bodies
                        body.m_sweep.c = c;
                        body.m_sweep.a = a;
                        body.m_linearVelocity = v;
                        body.m_angularVelocity = w;
                        body.synchronizeTransform();
                    }
                    this.postSolveIsland();
                    //DEBUG && common.debug("TOI------Island");
                };

                /**
                 * Contact impulses for reporting. Impulses are used instead of forces because
                 * sub-step forces may approach infinity for rigid body collisions. These match
                 * up one-to-one with the contact points in Manifold.
                 */
                function ContactImpulse() {
                    this.normalImpulses = [];
                    this.tangentImpulses = [];
                }

                Solver.prototype.postSolveIsland = function () {
                    // TODO: report contact.v_points instead of new object?
                    var impulse = new ContactImpulse();
                    for (var c = 0; c < this.m_contacts.length; ++c) {
                        var contact = this.m_contacts[c];
                        for (var p = 0; p < contact.v_points.length; ++p) {
                            impulse.normalImpulses.push(contact.v_points[p].normalImpulse);
                            impulse.tangentImpulses.push(contact.v_points[p].tangentImpulse);
                        }
                        this.m_world.postSolve(contact, impulse);
                    }
                };
            }, { "./Body": 2, "./Contact": 3, "./Joint": 5, "./Settings": 7, "./collision/Distance": 13, "./collision/TimeOfImpact": 15, "./common/Math": 18, "./common/Vec2": 23, "./util/Timer": 49, "./util/common": 50 }], 10: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = World;

                var options = require("./util/options");

                var common = require("./util/common");

                var Timer = require("./util/Timer");

                var Vec2 = require("./common/Vec2");

                var BroadPhase = require("./collision/BroadPhase");

                var Solver = require("./Solver");

                var Body = require("./Body");

                var Contact = require("./Contact");

                /**
                 * @typedef {Object} WorldDef
                 *
                 * @prop {Vec2} [gravity = { x : 0, y : 0}]
                 * @prop {boolean} [allowSleep = true]
                 * @prop {boolean} [warmStarting = false]
                 * @prop {boolean} [continuousPhysics = false]
                 * @prop {boolean} [subStepping = false]
                 * @prop {boolean} [blockSolve = true]
                 * @prop {int} [velocityIterations = 8] For the velocity constraint solver.
                 * @prop {int} [positionIterations = 3] For the position constraint solver.
                 */
                var WorldDef = {
                    gravity: Vec2.zero(),
                    allowSleep: true,
                    warmStarting: true,
                    continuousPhysics: true,
                    subStepping: false,
                    blockSolve: true,
                    velocityIterations: 8,
                    positionIterations: 3
                };

                /**
                 * @param {WordDef|Vec2} def World definition or gravity vector.
                 */
                function World(def) {
                    if (!(this instanceof World)) {
                        return new World(def);
                    }
                    if (def && Vec2.isValid(def)) {
                        def = {
                            gravity: def
                        };
                    }
                    def = options(def, WorldDef);
                    this.m_solver = new Solver(this);
                    this.m_broadPhase = new BroadPhase();
                    this.m_contactList = null;
                    this.m_contactCount = 0;
                    this.m_bodyList = null;
                    this.m_bodyCount = 0;
                    this.m_jointList = null;
                    this.m_jointCount = 0;
                    this.m_stepComplete = true;
                    this.m_allowSleep = def.allowSleep;
                    this.m_gravity = Vec2.clone(def.gravity);
                    this.m_clearForces = true;
                    this.m_newFixture = false;
                    this.m_locked = false;
                    // These are for debugging the solver.
                    this.m_warmStarting = def.warmStarting;
                    this.m_continuousPhysics = def.continuousPhysics;
                    this.m_subStepping = def.subStepping;
                    this.m_blockSolve = def.blockSolve;
                    this.m_velocityIterations = def.velocityIterations;
                    this.m_positionIterations = def.positionIterations;
                    this.m_t = 0;
                    this.m_stepCount = 0;
                    // Broad-phase callback.
                    this.addPair = this.createContact.bind(this);
                }

                /**
                 * Get the world body list. With the returned body, use Body.getNext to get the
                 * next body in the world list. A null body indicates the end of the list.
                 * 
                 * @return the head of the world body list.
                 */
                World.prototype.getBodyList = function () {
                    return this.m_bodyList;
                };

                /**
                 * Get the world joint list. With the returned joint, use Joint.getNext to get
                 * the next joint in the world list. A null joint indicates the end of the list.
                 * 
                 * @return the head of the world joint list.
                 */
                World.prototype.getJointList = function () {
                    return this.m_jointList;
                };

                /**
                 * Get the world contact list. With the returned contact, use Contact.getNext to
                 * get the next contact in the world list. A null contact indicates the end of
                 * the list.
                 * 
                 * @return the head of the world contact list. Warning: contacts are created and
                 *         destroyed in the middle of a time step. Use ContactListener to avoid
                 *         missing contacts.
                 */
                World.prototype.getContactList = function () {
                    return this.m_contactList;
                };

                World.prototype.getBodyCount = function () {
                    return this.m_bodyCount;
                };

                World.prototype.getJointCount = function () {
                    return this.m_jointCount;
                };

                /**
                 * Get the number of contacts (each may have 0 or more contact points).
                 */
                World.prototype.getContactCount = function () {
                    return this.m_contactCount;
                };

                /**
                 * Change the global gravity vector.
                 */
                World.prototype.setGravity = function (gravity) {
                    this.m_gravity = gravity;
                };

                /**
                 * Get the global gravity vector.
                 */
                World.prototype.getGravity = function () {
                    return this.m_gravity;
                };

                /**
                 * Is the world locked (in the middle of a time step).
                 */
                World.prototype.isLocked = function () {
                    return this.m_locked;
                };

                /**
                 * Enable/disable sleep.
                 */
                World.prototype.setAllowSleeping = function (flag) {
                    if (flag == this.m_allowSleep) {
                        return;
                    }
                    this.m_allowSleep = flag;
                    if (this.m_allowSleep == false) {
                        for (var b = this.m_bodyList; b; b = b.m_next) {
                            b.setAwake(true);
                        }
                    }
                };

                World.prototype.getAllowSleeping = function () {
                    return this.m_allowSleep;
                };

                /**
                 * Enable/disable warm starting. For testing.
                 */
                World.prototype.setWarmStarting = function (flag) {
                    this.m_warmStarting = flag;
                };

                World.prototype.getWarmStarting = function () {
                    return this.m_warmStarting;
                };

                /**
                 * Enable/disable continuous physics. For testing.
                 */
                World.prototype.setContinuousPhysics = function (flag) {
                    this.m_continuousPhysics = flag;
                };

                World.prototype.getContinuousPhysics = function () {
                    return this.m_continuousPhysics;
                };

                /**
                 * Enable/disable single stepped continuous physics. For testing.
                 */
                World.prototype.setSubStepping = function (flag) {
                    this.m_subStepping = flag;
                };

                World.prototype.getSubStepping = function () {
                    return this.m_subStepping;
                };

                /**
                 * Set flag to control automatic clearing of forces after each time step.
                 */
                World.prototype.setAutoClearForces = function (flag) {
                    this.m_clearForces = flag;
                };

                /**
                 * Get the flag that controls automatic clearing of forces after each time step.
                 */
                World.prototype.getAutoClearForces = function () {
                    return this.m_clearForces;
                };

                /**
                 * Manually clear the force buffer on all bodies. By default, forces are cleared
                 * automatically after each call to step. The default behavior is modified by
                 * calling setAutoClearForces. The purpose of this function is to support
                 * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step
                 * under a variable frame-rate. When you perform sub-stepping you will disable
                 * auto clearing of forces and instead call clearForces after all sub-steps are
                 * complete in one pass of your game loop.
                 * 
                 * @see setAutoClearForces
                 */
                World.prototype.clearForces = function () {
                    for (var body = this.m_bodyList; body; body = body.getNext()) {
                        body.m_force.setZero();
                        body.m_torque = 0;
                    }
                };

                /**
                 * @function World~rayCastCallback
                 * 
                 * @param fixture
                 */
                /**
                 * Query the world for all fixtures that potentially overlap the provided AABB.
                 * 
                 * @param {World~queryCallback} queryCallback Called for each fixture
                 *          found in the query AABB. It may return `false` to terminate the
                 *          query.
                 * 
                 * @param aabb The query box.
                 */
                World.prototype.queryAABB = function (aabb, queryCallback) {
                    //ASSERT && common.assert(typeof queryCallback === "function");
                    var broadPhase = this.m_broadPhase;
                    this.m_broadPhase.query(aabb, function (proxyId) {
                        //TODO GC
                        var proxy = broadPhase.getUserData(proxyId);
                        // FixtureProxy
                        return queryCallback(proxy.fixture);
                    });
                };

                /**
                 * @function World~rayCastCallback
                 * 
                 * Callback class for ray casts. See World.rayCast
                 * 
                 * Called for each fixture found in the query. You control how the ray cast
                 * proceeds by returning a float: return -1: ignore this fixture and continue
                 * return 0: terminate the ray cast return fraction: clip the ray to this point
                 * return 1: don't clip the ray and continue
                 * 
                 * @param fixture The fixture hit by the ray
                 * @param point The point of initial intersection
                 * @param normal The normal vector at the point of intersection
                 * @param fraction
                 * 
                 * @return {float} -1 to filter, 0 to terminate, fraction to clip the ray for
                 *         closest hit, 1 to continue
                 */
                /**
                 * 
                 * Ray-cast the world for all fixtures in the path of the ray. Your callback
                 * controls whether you get the closest point, any point, or n-points. The
                 * ray-cast ignores shapes that contain the starting point.
                 * 
                 * @param {World~RayCastCallback} reportFixtureCallback A user implemented
                 *          callback function.
                 * @param point1 The ray starting point
                 * @param point2 The ray ending point
                 */
                World.prototype.rayCast = function (point1, point2, reportFixtureCallback) {
                    //ASSERT && common.assert(typeof reportFixtureCallback === "function");
                    var broadPhase = this.m_broadPhase;
                    this.m_broadPhase.rayCast({
                        maxFraction: 1,
                        p1: point1,
                        p2: point2
                    }, function (input, proxyId) {
                        // TODO GC
                        var proxy = broadPhase.getUserData(proxyId);
                        // FixtureProxy
                        var fixture = proxy.fixture;
                        var index = proxy.childIndex;
                        var output = {};
                        // TODO GC
                        var hit = fixture.rayCast(output, input, index);
                        if (hit) {
                            var fraction = output.fraction;
                            var point = Vec2.add(Vec2.mul(1 - fraction, input.p1), Vec2.mul(fraction, input.p2));
                            return reportFixtureCallback(fixture, point, output.normal, fraction);
                        }
                        return input.maxFraction;
                    });
                };

                /**
                 * Get the number of broad-phase proxies.
                 */
                World.prototype.getProxyCount = function () {
                    return this.m_broadPhase.getProxyCount();
                };

                /**
                 * Get the height of broad-phase dynamic tree.
                 */
                World.prototype.getTreeHeight = function () {
                    return this.m_broadPhase.getTreeHeight();
                };

                /**
                 * Get the balance of broad-phase dynamic tree.
                 * 
                 * @returns {int}
                 */
                World.prototype.getTreeBalance = function () {
                    return this.m_broadPhase.getTreeBalance();
                };

                /**
                 * Get the quality metric of broad-phase dynamic tree. The smaller the better.
                 * The minimum is 1.
                 * 
                 * @returns {float}
                 */
                World.prototype.getTreeQuality = function () {
                    return this.m_broadPhase.getTreeQuality();
                };

                /**
                 * Shift the world origin. Useful for large worlds. The body shift formula is:
                 * position -= newOrigin
                 * 
                 * @param {Vec2} newOrigin The new origin with respect to the old origin
                 */
                World.prototype.shiftOrigin = function (newOrigin) {
                    //ASSERT && common.assert(this.m_locked == false);
                    if (this.m_locked) {
                        return;
                    }
                    for (var b = this.m_bodyList; b; b = b.m_next) {
                        b.m_xf.p.sub(newOrigin);
                        b.m_sweep.c0.sub(newOrigin);
                        b.m_sweep.c.sub(newOrigin);
                    }
                    for (var j = this.m_jointList; j; j = j.m_next) {
                        j.shiftOrigin(newOrigin);
                    }
                    this.m_broadPhase.shiftOrigin(newOrigin);
                };

                /**
                 * Create a rigid body given a definition. No reference to the definition is
                 * retained.
                 * 
                 * Warning: This function is locked during callbacks.
                 * 
                 * @param {BodyDef|Vec2} def Body definition or position.
                 * @param {float} angle Body angle if def is position.
                 */
                World.prototype.createBody = function (def, angle) {
                    //ASSERT && common.assert(this.isLocked() == false);
                    if (this.isLocked()) {
                        return null;
                    }
                    if (def && Vec2.isValid(def)) {
                        def = {
                            position: def,
                            angle: angle
                        };
                    }
                    var body = new Body(this, def);
                    // Add to world doubly linked list.
                    body.m_prev = null;
                    body.m_next = this.m_bodyList;
                    if (this.m_bodyList) {
                        this.m_bodyList.m_prev = body;
                    }
                    this.m_bodyList = body;
                    ++this.m_bodyCount;
                    return body;
                };

                World.prototype.createDynamicBody = function (def, angle) {
                    if (!def) {
                        def = {};
                    } else if (Vec2.isValid(def)) {
                        def = {
                            position: def,
                            angle: angle
                        };
                    }
                    def.type = "dynamic";
                    return this.createBody(def);
                };

                World.prototype.createKinematicBody = function (def, angle) {
                    if (!def) {
                        def = {};
                    } else if (Vec2.isValid(def)) {
                        def = {
                            position: def,
                            angle: angle
                        };
                    }
                    def.type = "kinematic";
                    return this.createBody(def);
                };

                /**
                 * Destroy a rigid body given a definition. No reference to the definition is
                 * retained.
                 * 
                 * Warning: This automatically deletes all associated shapes and joints.
                 * 
                 * Warning: This function is locked during callbacks.
                 * 
                 * @param {Body} b
                 */
                World.prototype.destroyBody = function (b) {
                    //ASSERT && common.assert(this.m_bodyCount > 0);
                    //ASSERT && common.assert(this.isLocked() == false);
                    if (this.isLocked()) {
                        return;
                    }
                    if (b.m_destroyed) {
                        return false;
                    }
                    // Delete the attached joints.
                    var je = b.m_jointList;
                    while (je) {
                        var je0 = je;
                        je = je.next;
                        this.publish("remove-joint", je0.joint);
                        this.destroyJoint(je0.joint);
                        b.m_jointList = je;
                    }
                    b.m_jointList = null;
                    // Delete the attached contacts.
                    var ce = b.m_contactList;
                    while (ce) {
                        var ce0 = ce;
                        ce = ce.next;
                        this.destroyContact(ce0.contact);
                        b.m_contactList = ce;
                    }
                    b.m_contactList = null;
                    // Delete the attached fixtures. This destroys broad-phase proxies.
                    var f = b.m_fixtureList;
                    while (f) {
                        var f0 = f;
                        f = f.m_next;
                        this.publish("remove-fixture", f0);
                        f0.destroyProxies(this.m_broadPhase);
                        b.m_fixtureList = f;
                    }
                    b.m_fixtureList = null;
                    // Remove world body list.
                    if (b.m_prev) {
                        b.m_prev.m_next = b.m_next;
                    }
                    if (b.m_next) {
                        b.m_next.m_prev = b.m_prev;
                    }
                    if (b == this.m_bodyList) {
                        this.m_bodyList = b.m_next;
                    }
                    b.m_destroyed = true;
                    --this.m_bodyCount;
                    return true;
                };

                /**
                 * Create a joint to constrain bodies together. No reference to the definition
                 * is retained. This may cause the connected bodies to cease colliding.
                 * 
                 * Warning: This function is locked during callbacks.
                 * 
                 * @param {Joint} join
                 * @param {Body} bodyB
                 * @param {Body} bodyA
                 */
                World.prototype.createJoint = function (joint) {
                    //ASSERT && common.assert(!!joint.m_bodyA);
                    //ASSERT && common.assert(!!joint.m_bodyB);
                    //ASSERT && common.assert(this.isLocked() == false);
                    if (this.isLocked()) {
                        return null;
                    }
                    // Connect to the world list.
                    joint.m_prev = null;
                    joint.m_next = this.m_jointList;
                    if (this.m_jointList) {
                        this.m_jointList.m_prev = joint;
                    }
                    this.m_jointList = joint;
                    ++this.m_jointCount;
                    // Connect to the bodies' doubly linked lists.
                    joint.m_edgeA.joint = joint;
                    joint.m_edgeA.other = joint.m_bodyB;
                    joint.m_edgeA.prev = null;
                    joint.m_edgeA.next = joint.m_bodyA.m_jointList;
                    if (joint.m_bodyA.m_jointList) joint.m_bodyA.m_jointList.prev = joint.m_edgeA;
                    joint.m_bodyA.m_jointList = joint.m_edgeA;
                    joint.m_edgeB.joint = joint;
                    joint.m_edgeB.other = joint.m_bodyA;
                    joint.m_edgeB.prev = null;
                    joint.m_edgeB.next = joint.m_bodyB.m_jointList;
                    if (joint.m_bodyB.m_jointList) joint.m_bodyB.m_jointList.prev = joint.m_edgeB;
                    joint.m_bodyB.m_jointList = joint.m_edgeB;
                    // If the joint prevents collisions, then flag any contacts for filtering.
                    if (joint.m_collideConnected == false) {
                        for (var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {
                            if (edge.other == joint.m_bodyA) {
                                // Flag the contact for filtering at the next time step (where either
                                // body is awake).
                                edge.contact.flagForFiltering();
                            }
                        }
                    }
                    // Note: creating a joint doesn't wake the bodies.
                    return joint;
                };

                /**
                 * Destroy a joint. This may cause the connected bodies to begin colliding.
                 * Warning: This function is locked during callbacks.
                 * 
                 * @param {Joint} join
                 */
                World.prototype.destroyJoint = function (joint) {
                    //ASSERT && common.assert(this.isLocked() == false);
                    if (this.isLocked()) {
                        return;
                    }
                    // Remove from the doubly linked list.
                    if (joint.m_prev) {
                        joint.m_prev.m_next = joint.m_next;
                    }
                    if (joint.m_next) {
                        joint.m_next.m_prev = joint.m_prev;
                    }
                    if (joint == this.m_jointList) {
                        this.m_jointList = joint.m_next;
                    }
                    // Disconnect from bodies.
                    var bodyA = joint.m_bodyA;
                    var bodyB = joint.m_bodyB;
                    // Wake up connected bodies.
                    bodyA.setAwake(true);
                    bodyB.setAwake(true);
                    // Remove from body 1.
                    if (joint.m_edgeA.prev) {
                        joint.m_edgeA.prev.next = joint.m_edgeA.next;
                    }
                    if (joint.m_edgeA.next) {
                        joint.m_edgeA.next.prev = joint.m_edgeA.prev;
                    }
                    if (joint.m_edgeA == bodyA.m_jointList) {
                        bodyA.m_jointList = joint.m_edgeA.next;
                    }
                    joint.m_edgeA.prev = null;
                    joint.m_edgeA.next = null;
                    // Remove from body 2
                    if (joint.m_edgeB.prev) {
                        joint.m_edgeB.prev.next = joint.m_edgeB.next;
                    }
                    if (joint.m_edgeB.next) {
                        joint.m_edgeB.next.prev = joint.m_edgeB.prev;
                    }
                    if (joint.m_edgeB == bodyB.m_jointList) {
                        bodyB.m_jointList = joint.m_edgeB.next;
                    }
                    joint.m_edgeB.prev = null;
                    joint.m_edgeB.next = null;
                    //ASSERT && common.assert(this.m_jointCount > 0);
                    --this.m_jointCount;
                    // If the joint prevents collisions, then flag any contacts for filtering.
                    if (joint.m_collideConnected == false) {
                        var edge = bodyB.getContactList();
                        while (edge) {
                            if (edge.other == bodyA) {
                                // Flag the contact for filtering at the next time step (where either
                                // body is awake).
                                edge.contact.flagForFiltering();
                            }
                            edge = edge.next;
                        }
                    }
                    this.publish("remove-joint", joint);
                };

                var s_step = new Solver.TimeStep();

                // reuse
                /**
                 * Take a time step. This performs collision detection, integration, and
                 * constraint solution.
                 *
                 * Broad-phase, narrow-phase, solve and solve time of impacts.
                 *
                 * @param {float} timeStep Time step, this should not vary.
                 * @param {int} velocityIterations
                 * @param {int} positionIterations
                 */
                World.prototype.step = function (timeStep, velocityIterations, positionIterations) {
                    if ((velocityIterations | 0) !== velocityIterations) {
                        // TODO: remove this in future
                        velocityIterations = 0;
                    }
                    velocityIterations = velocityIterations || this.m_velocityIterations;
                    positionIterations = positionIterations || this.m_positionIterations;
                    // TODO: move this to testbed
                    this.m_stepCount++;
                    // If new fixtures were added, we need to find the new contacts.
                    if (this.m_newFixture) {
                        this.findNewContacts();
                        this.m_newFixture = false;
                    }
                    this.m_locked = true;
                    s_step.reset(timeStep);
                    s_step.velocityIterations = velocityIterations;
                    s_step.positionIterations = positionIterations;
                    s_step.warmStarting = this.m_warmStarting;
                    s_step.blockSolve = this.m_blockSolve;
                    // Update contacts. This is where some contacts are destroyed.
                    this.updateContacts();
                    // Integrate velocities, solve velocity constraints, and integrate positions.
                    if (this.m_stepComplete && timeStep > 0) {
                        this.m_solver.solveWorld(s_step);
                        // Synchronize fixtures, check for out of range bodies.
                        for (var b = this.m_bodyList; b; b = b.getNext()) {
                            // If a body was not in an island then it did not move.
                            if (b.m_islandFlag == false) {
                                continue;
                            }
                            if (b.isStatic()) {
                                continue;
                            }
                            // Update fixtures (for broad-phase).
                            b.synchronizeFixtures();
                        }
                        // Look for new contacts.
                        this.findNewContacts();
                    }
                    // Handle TOI events.
                    if (this.m_continuousPhysics && timeStep > 0) {
                        this.m_solver.solveWorldTOI(s_step);
                    }
                    if (this.m_clearForces) {
                        this.clearForces();
                    }
                    this.m_locked = false;
                };

                /**
                 * Call this method to find new contacts.
                 */
                World.prototype.findNewContacts = function () {
                    this.m_broadPhase.updatePairs(this.addPair);
                };

                /**
                 * @private
                 * 
                 * @param {FixtureProxy} proxyA
                 * @param {FixtureProxy} proxyB
                 */
                World.prototype.createContact = function (proxyA, proxyB) {
                    var fixtureA = proxyA.fixture;
                    var fixtureB = proxyB.fixture;
                    var indexA = proxyA.childIndex;
                    var indexB = proxyB.childIndex;
                    var bodyA = fixtureA.getBody();
                    var bodyB = fixtureB.getBody();
                    // Are the fixtures on the same body?
                    if (bodyA == bodyB) {
                        return;
                    }
                    // TODO_ERIN use a hash table to remove a potential bottleneck when both
                    // bodies have a lot of contacts.
                    // Does a contact already exist?
                    var edge = bodyB.getContactList();
                    // ContactEdge
                    while (edge) {
                        if (edge.other == bodyA) {
                            var fA = edge.contact.getFixtureA();
                            var fB = edge.contact.getFixtureB();
                            var iA = edge.contact.getChildIndexA();
                            var iB = edge.contact.getChildIndexB();
                            if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {
                                // A contact already exists.
                                return;
                            }
                            if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {
                                // A contact already exists.
                                return;
                            }
                        }
                        edge = edge.next;
                    }
                    if (bodyB.shouldCollide(bodyA) == false) {
                        return;
                    }
                    if (fixtureB.shouldCollide(fixtureA) == false) {
                        return;
                    }
                    // Call the factory.
                    var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);
                    if (contact == null) {
                        return;
                    }
                    // Insert into the world.
                    contact.m_prev = null;
                    if (this.m_contactList != null) {
                        contact.m_next = this.m_contactList;
                        this.m_contactList.m_prev = contact;
                    }
                    this.m_contactList = contact;
                    ++this.m_contactCount;
                };

                /**
                 * Removes old non-overlapping contacts, applies filters and updates contacts.
                 */
                World.prototype.updateContacts = function () {
                    // Update awake contacts.
                    var c,
                        next_c = this.m_contactList;
                    while (c = next_c) {
                        next_c = c.getNext();
                        var fixtureA = c.getFixtureA();
                        var fixtureB = c.getFixtureB();
                        var indexA = c.getChildIndexA();
                        var indexB = c.getChildIndexB();
                        var bodyA = fixtureA.getBody();
                        var bodyB = fixtureB.getBody();
                        // Is this contact flagged for filtering?
                        if (c.m_filterFlag) {
                            if (bodyB.shouldCollide(bodyA) == false) {
                                this.destroyContact(c);
                                continue;
                            }
                            if (fixtureB.shouldCollide(fixtureA) == false) {
                                this.destroyContact(c);
                                continue;
                            }
                            // Clear the filtering flag.
                            c.m_filterFlag = false;
                        }
                        var activeA = bodyA.isAwake() && !bodyA.isStatic();
                        var activeB = bodyB.isAwake() && !bodyB.isStatic();
                        // At least one body must be awake and it must be dynamic or kinematic.
                        if (activeA == false && activeB == false) {
                            continue;
                        }
                        var proxyIdA = fixtureA.m_proxies[indexA].proxyId;
                        var proxyIdB = fixtureB.m_proxies[indexB].proxyId;
                        var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);
                        // Here we destroy contacts that cease to overlap in the broad-phase.
                        if (overlap == false) {
                            this.destroyContact(c);
                            continue;
                        }
                        // The contact persists.
                        c.update(this);
                    }
                };

                /**
                 * @param {Contact} contact
                 */
                World.prototype.destroyContact = function (contact) {
                    Contact.destroy(contact, this);
                    // Remove from the world.
                    if (contact.m_prev) {
                        contact.m_prev.m_next = contact.m_next;
                    }
                    if (contact.m_next) {
                        contact.m_next.m_prev = contact.m_prev;
                    }
                    if (contact == this.m_contactList) {
                        this.m_contactList = contact.m_next;
                    }
                    --this.m_contactCount;
                };

                World.prototype._listeners = null;

                /**
                 * Register an event listener.
                 *
                 * @param {string} name
                 * @param {function} listener
                 */
                World.prototype.on = function (name, listener) {
                    if (typeof name !== "string" || typeof listener !== "function") {
                        return this;
                    }
                    if (!this._listeners) {
                        this._listeners = {};
                    }
                    if (!this._listeners[name]) {
                        this._listeners[name] = [];
                    }
                    this._listeners[name].push(listener);
                    return this;
                };

                /**
                 * Remove an event listener.
                 *
                 * @param {string} name
                 * @param {function} listener
                 */
                World.prototype.off = function (name, listener) {
                    if (typeof name !== "string" || typeof listener !== "function") {
                        return this;
                    }
                    var listeners = this._listeners && this._listeners[name];
                    if (!listeners || !listeners.length) {
                        return this;
                    }
                    var index = listeners.indexOf(listener);
                    if (index >= 0) {
                        listeners.splice(index, 1);
                    }
                    return this;
                };

                World.prototype.publish = function (name, arg1, arg2, arg3) {
                    var listeners = this._listeners && this._listeners[name];
                    if (!listeners || !listeners.length) {
                        return 0;
                    }
                    for (var l = 0; l < listeners.length; l++) {
                        listeners[l].call(this, arg1, arg2, arg3);
                    }
                    return listeners.length;
                };

                /**
                 * @event World#remove-body
                 * @event World#remove-joint
                 * @event World#remove-fixture
                 *
                 * Joints and fixtures are destroyed when their associated body is destroyed.
                 * Register a destruction listener so that you may nullify references to these
                 * joints and shapes.
                 *
                 * `function(object)` is called when any joint or fixture is about to
                 * be destroyed due to the destruction of one of its attached or parent bodies.
                 */
                /**
                 * @private
                 * @param {Contact} contact
                 */
                World.prototype.beginContact = function (contact) {
                    this.publish("begin-contact", contact);
                };

                /**
                 * @event World#begin-contact
                 *
                 * Called when two fixtures begin to touch.
                 *
                 * Implement contact callbacks to get contact information. You can use these
                 * results for things like sounds and game logic. You can also get contact
                 * results by traversing the contact lists after the time step. However, you
                 * might miss some contacts because continuous physics leads to sub-stepping.
                 * Additionally you may receive multiple callbacks for the same contact in a
                 * single time step. You should strive to make your callbacks efficient because
                 * there may be many callbacks per time step.
                 *
                 * Warning: You cannot create/destroy world entities inside these callbacks.
                 */
                /**
                 * @private
                 * @param {Contact} contact
                 */
                World.prototype.endContact = function (contact) {
                    this.publish("end-contact", contact);
                };

                /**
                 * @event World#end-contact
                 *
                 * Called when two fixtures cease to touch.
                 *
                 * Implement contact callbacks to get contact information. You can use these
                 * results for things like sounds and game logic. You can also get contact
                 * results by traversing the contact lists after the time step. However, you
                 * might miss some contacts because continuous physics leads to sub-stepping.
                 * Additionally you may receive multiple callbacks for the same contact in a
                 * single time step. You should strive to make your callbacks efficient because
                 * there may be many callbacks per time step.
                 *
                 * Warning: You cannot create/destroy world entities inside these callbacks.
                 */
                /**
                 * @private
                 * @param {Contact} contact
                 * @param {Manifold} oldManifold
                 */
                World.prototype.preSolve = function (contact, oldManifold) {
                    this.publish("pre-solve", contact, oldManifold);
                };

                /**
                 * @event World#pre-solve
                 *
                 * This is called after a contact is updated. This allows you to inspect a
                 * contact before it goes to the solver. If you are careful, you can modify the
                 * contact manifold (e.g. disable contact). A copy of the old manifold is
                 * provided so that you can detect changes. Note: this is called only for awake
                 * bodies. Note: this is called even when the number of contact points is zero.
                 * Note: this is not called for sensors. Note: if you set the number of contact
                 * points to zero, you will not get an endContact callback. However, you may get
                 * a beginContact callback the next step.
                 *
                 * Warning: You cannot create/destroy world entities inside these callbacks.
                 */
                /**
                 * @private
                 * @param {Contact} contact
                 * @param {ContactImpulse} impulse
                 */
                World.prototype.postSolve = function (contact, impulse) {
                    this.publish("post-solve", contact, impulse);
                };
            }, { "./Body": 2, "./Contact": 3, "./Solver": 9, "./collision/BroadPhase": 12, "./common/Vec2": 23, "./util/Timer": 49, "./util/common": 50, "./util/options": 52 }], 11: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                module.exports = AABB;

                function AABB(lower, upper) {
                    if (!(this instanceof AABB)) {
                        return new AABB(lower, upper);
                    }
                    this.lowerBound = Vec2.zero();
                    this.upperBound = Vec2.zero();
                    if ((typeof lower === 'undefined' ? 'undefined' : _typeof(lower)) === "object") {
                        this.lowerBound.set(lower);
                    }
                    if ((typeof upper === 'undefined' ? 'undefined' : _typeof(upper)) === "object") {
                        this.upperBound.set(upper);
                    }
                }

                /**
                 * Verify that the bounds are sorted.
                 */
                AABB.prototype.isValid = function () {
                    return AABB.isValid(this);
                };

                AABB.isValid = function (aabb) {
                    var d = Vec2.sub(aabb.upperBound, aabb.lowerBound);
                    var valid = d.x >= 0 && d.y >= 0 && Vec2.isValid(aabb.lowerBound) && Vec2.isValid(aabb.upperBound);
                    return valid;
                };

                /**
                 * Get the center of the AABB.
                 */
                AABB.prototype.getCenter = function () {
                    return Vec2.neo((this.lowerBound.x + this.upperBound.x) * .5, (this.lowerBound.y + this.upperBound.y) * .5);
                };

                /**
                 * Get the extents of the AABB (half-widths).
                 */
                AABB.prototype.getExtents = function () {
                    return Vec2.neo((this.upperBound.x - this.lowerBound.x) * .5, (this.upperBound.y - this.lowerBound.y) * .5);
                };

                /**
                 * Get the perimeter length.
                 */
                AABB.prototype.getPerimeter = function () {
                    return 2 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);
                };

                /**
                 * Combine one or two AABB into this one.
                 */
                AABB.prototype.combine = function (a, b) {
                    b = b || this;
                    this.lowerBound.set(Math.min(a.lowerBound.x, b.lowerBound.x), Math.min(a.lowerBound.y, b.lowerBound.y));
                    this.upperBound.set(Math.max(a.upperBound.x, b.upperBound.x), Math.max(a.upperBound.y, b.upperBound.y));
                };

                AABB.prototype.combinePoints = function (a, b) {
                    this.lowerBound.set(Math.min(a.x, b.x), Math.min(a.y, b.y));
                    this.upperBound.set(Math.max(a.x, b.x), Math.max(a.y, b.y));
                };

                AABB.prototype.set = function (aabb) {
                    this.lowerBound.set(aabb.lowerBound.x, aabb.lowerBound.y);
                    this.upperBound.set(aabb.upperBound.x, aabb.upperBound.y);
                };

                AABB.prototype.contains = function (aabb) {
                    var result = true;
                    result = result && this.lowerBound.x <= aabb.lowerBound.x;
                    result = result && this.lowerBound.y <= aabb.lowerBound.y;
                    result = result && aabb.upperBound.x <= this.upperBound.x;
                    result = result && aabb.upperBound.y <= this.upperBound.y;
                    return result;
                };

                AABB.prototype.extend = function (value) {
                    AABB.extend(this, value);
                };

                AABB.extend = function (aabb, value) {
                    aabb.lowerBound.x -= value;
                    aabb.lowerBound.y -= value;
                    aabb.upperBound.x += value;
                    aabb.upperBound.y += value;
                };

                AABB.testOverlap = function (a, b) {
                    var d1x = b.lowerBound.x - a.upperBound.x;
                    var d2x = a.lowerBound.x - b.upperBound.x;
                    var d1y = b.lowerBound.y - a.upperBound.y;
                    var d2y = a.lowerBound.y - b.upperBound.y;
                    if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {
                        return false;
                    }
                    return true;
                };

                AABB.areEqual = function (a, b) {
                    return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);
                };

                AABB.diff = function (a, b) {
                    var wD = Math.max(0, Math.min(a.upperBound.x, b.upperBound.x) - Math.max(b.lowerBound.x, a.lowerBound.x));
                    var hD = Math.max(0, Math.min(a.upperBound.y, b.upperBound.y) - Math.max(b.lowerBound.y, a.lowerBound.y));
                    var wA = a.upperBound.x - a.lowerBound.x;
                    var hA = a.upperBound.y - a.lowerBound.y;
                    var hB = b.upperBound.y - b.lowerBound.y;
                    var hB = b.upperBound.y - b.lowerBound.y;
                    return wA * hA + wB * hB - wD * hD;
                };

                /**
                 * @typedef RayCastInput
                 *
                 * Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
                 *
                 * @prop {Vec2} p1
                 * @prop {Vec2} p2
                 * @prop {number} maxFraction
                 */
                /**
                 * @typedef RayCastInput
                 *
                 * Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and
                 * p2 come from RayCastInput.
                 *
                 * @prop {Vec2} normal
                 * @prop {number} fraction
                 */
                /**
                 * @param {RayCastOutput} output
                 * @param {RayCastInput} input
                 * @returns {boolean}
                 */
                AABB.prototype.rayCast = function (output, input) {
                    // From Real-time Collision Detection, p179.
                    var tmin = -Infinity;
                    var tmax = Infinity;
                    var p = input.p1;
                    var d = Vec2.sub(input.p2, input.p1);
                    var absD = Vec2.abs(d);
                    var normal = Vec2.zero();
                    for (var f = "x"; f !== null; f = f === "x" ? "y" : null) {
                        if (absD.x < Math.EPSILON) {
                            // Parallel.
                            if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {
                                return false;
                            }
                        } else {
                            var inv_d = 1 / d[f];
                            var t1 = (this.lowerBound[f] - p[f]) * inv_d;
                            var t2 = (this.upperBound[f] - p[f]) * inv_d;
                            // Sign of the normal vector.
                            var s = -1;
                            if (t1 > t2) {
                                var temp = t1;
                                t1 = t2, t2 = temp;
                                s = 1;
                            }
                            // Push the min up
                            if (t1 > tmin) {
                                normal.setZero();
                                normal[f] = s;
                                tmin = t1;
                            }
                            // Pull the max down
                            tmax = Math.min(tmax, t2);
                            if (tmin > tmax) {
                                return false;
                            }
                        }
                    }
                    // Does the ray start inside the box?
                    // Does the ray intersect beyond the max fraction?
                    if (tmin < 0 || input.maxFraction < tmin) {
                        return false;
                    }
                    // Intersection.
                    output.fraction = tmin;
                    output.normal = normal;
                    return true;
                };

                AABB.prototype.toString = function () {
                    return JSON.stringify(this);
                };
            }, { "../Settings": 7, "../common/Math": 18, "../common/Vec2": 23 }], 12: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var Settings = require("../Settings");

                var common = require("../util/common");

                var Math = require("../common/Math");

                var AABB = require("./AABB");

                var DynamicTree = require("./DynamicTree");

                module.exports = BroadPhase;

                /**
                 * The broad-phase wraps and extends a dynamic-tree keep to track of moved
                 * objects and query them on update.
                 */
                function BroadPhase() {
                    this.m_tree = new DynamicTree();
                    this.m_proxyCount = 0;
                    this.m_moveBuffer = [];
                    this.queryCallback = this.queryCallback.bind(this);
                }

                /**
                 * Get user data from a proxy. Returns null if the id is invalid.
                 */
                BroadPhase.prototype.getUserData = function (proxyId) {
                    return this.m_tree.getUserData(proxyId);
                };

                /**
                 * Test overlap of fat AABBs.
                 */
                BroadPhase.prototype.testOverlap = function (proxyIdA, proxyIdB) {
                    var aabbA = this.m_tree.getFatAABB(proxyIdA);
                    var aabbB = this.m_tree.getFatAABB(proxyIdB);
                    return AABB.testOverlap(aabbA, aabbB);
                };

                /**
                 * Get the fat AABB for a proxy.
                 */
                BroadPhase.prototype.getFatAABB = function (proxyId) {
                    return this.m_tree.getFatAABB(proxyId);
                };

                /**
                 * Get the number of proxies.
                 */
                BroadPhase.prototype.getProxyCount = function () {
                    return this.m_proxyCount;
                };

                /**
                 * Get the height of the embedded tree.
                 */
                BroadPhase.prototype.getTreeHeight = function () {
                    return this.m_tree.getHeight();
                };

                /**
                 * Get the balance (integer) of the embedded tree.
                 */
                BroadPhase.prototype.getTreeBalance = function () {
                    return this.m_tree.getMaxBalance();
                };

                /**
                 * Get the quality metric of the embedded tree.
                 */
                BroadPhase.prototype.getTreeQuality = function () {
                    return this.m_tree.getAreaRatio();
                };

                /**
                 * Query an AABB for overlapping proxies. The callback class is called for each
                 * proxy that overlaps the supplied AABB.
                 */
                BroadPhase.prototype.query = function (aabb, queryCallback) {
                    this.m_tree.query(aabb, queryCallback);
                };

                /**
                 * Ray-cast against the proxies in the tree. This relies on the callback to
                 * perform a exact ray-cast in the case were the proxy contains a shape. The
                 * callback also performs the any collision filtering. This has performance
                 * roughly equal to k * log(n), where k is the number of collisions and n is the
                 * number of proxies in the tree.
                 * 
                 * @param input The ray-cast input data. The ray extends from p1 to p1 +
                 *          maxFraction * (p2 - p1).
                 * @param rayCastCallback A function that is called for each proxy that is hit by
                 *          the ray.
                 */
                BroadPhase.prototype.rayCast = function (input, rayCastCallback) {
                    this.m_tree.rayCast(input, rayCastCallback);
                };

                /**
                 * Shift the world origin. Useful for large worlds. The shift formula is:
                 * position -= newOrigin
                 * 
                 * @param newOrigin The new origin with respect to the old origin
                 */
                BroadPhase.prototype.shiftOrigin = function (newOrigin) {
                    this.m_tree.shiftOrigin(newOrigin);
                };

                /**
                 * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs
                 * is called.
                 */
                BroadPhase.prototype.createProxy = function (aabb, userData) {
                    //ASSERT && common.assert(AABB.isValid(aabb));
                    var proxyId = this.m_tree.createProxy(aabb, userData);
                    this.m_proxyCount++;
                    this.bufferMove(proxyId);
                    return proxyId;
                };

                /**
                 * Destroy a proxy. It is up to the client to remove any pairs.
                 */
                BroadPhase.prototype.destroyProxy = function (proxyId) {
                    this.unbufferMove(proxyId);
                    this.m_proxyCount--;
                    this.m_tree.destroyProxy(proxyId);
                };

                /**
                 * Call moveProxy as many times as you like, then when you are done call
                 * UpdatePairs to finalized the proxy pairs (for your time step).
                 */
                BroadPhase.prototype.moveProxy = function (proxyId, aabb, displacement) {
                    //ASSERT && common.assert(AABB.isValid(aabb));
                    var changed = this.m_tree.moveProxy(proxyId, aabb, displacement);
                    if (changed) {
                        this.bufferMove(proxyId);
                    }
                };

                /**
                 * Call to trigger a re-processing of it's pairs on the next call to
                 * UpdatePairs.
                 */
                BroadPhase.prototype.touchProxy = function (proxyId) {
                    this.bufferMove(proxyId);
                };

                BroadPhase.prototype.bufferMove = function (proxyId) {
                    this.m_moveBuffer.push(proxyId);
                };

                BroadPhase.prototype.unbufferMove = function (proxyId) {
                    for (var i = 0; i < this.m_moveBuffer.length; ++i) {
                        if (this.m_moveBuffer[i] == proxyId) {
                            this.m_moveBuffer[i] = null;
                        }
                    }
                };

                /**
                 * @function BroadPhase~addPair
                 * @param {Object} userDataA
                 * @param {Object} userDataB
                 */
                /**
                 * Update the pairs. This results in pair callbacks. This can only add pairs.
                 * 
                 * @param {BroadPhase~AddPair} addPairCallback
                 */
                BroadPhase.prototype.updatePairs = function (addPairCallback) {
                    //ASSERT && common.assert(typeof addPairCallback === "function");
                    this.m_callback = addPairCallback;
                    // Perform tree queries for all moving proxies.
                    while (this.m_moveBuffer.length > 0) {
                        this.m_queryProxyId = this.m_moveBuffer.pop();
                        if (this.m_queryProxyId === null) {
                            continue;
                        }
                        // We have to query the tree with the fat AABB so that
                        // we don't fail to create a pair that may touch later.
                        var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);
                        // Query tree, create pairs and add them pair buffer.
                        this.m_tree.query(fatAABB, this.queryCallback);
                    }
                };

                BroadPhase.prototype.queryCallback = function (proxyId) {
                    // A proxy cannot form a pair with itself.
                    if (proxyId == this.m_queryProxyId) {
                        return true;
                    }
                    var proxyIdA = Math.min(proxyId, this.m_queryProxyId);
                    var proxyIdB = Math.max(proxyId, this.m_queryProxyId);
                    // TODO: Skip any duplicate pairs.
                    var userDataA = this.m_tree.getUserData(proxyIdA);
                    var userDataB = this.m_tree.getUserData(proxyIdB);
                    // Send the pairs back to the client.
                    this.m_callback(userDataA, userDataB);
                    return true;
                };
            }, { "../Settings": 7, "../common/Math": 18, "../util/common": 50, "./AABB": 11, "./DynamicTree": 14 }], 13: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Distance;

                module.exports.Input = DistanceInput;

                module.exports.Output = DistanceOutput;

                module.exports.Proxy = DistanceProxy;

                module.exports.Cache = SimplexCache;

                var Settings = require("../Settings");

                var common = require("../util/common");

                var Timer = require("../util/Timer");

                var stats = require("../common/stats");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                /**
                 * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.
                 */
                stats.gjkCalls = 0;

                stats.gjkIters = 0;

                stats.gjkMaxIters = 0;

                /**
                 * Input for Distance. You have to option to use the shape radii in the
                 * computation. Even
                 */
                function DistanceInput() {
                    this.proxyA = new DistanceProxy();
                    this.proxyB = new DistanceProxy();
                    this.transformA = null;
                    this.transformB = null;
                    this.useRadii = false;
                }

                /**
                 * Output for Distance.
                 *
                 * @prop {Vec2} pointA closest point on shapeA
                 * @prop {Vec2} pointB closest point on shapeB
                 * @prop distance
                 * @prop iterations number of GJK iterations used
                 */
                function DistanceOutput() {
                    this.pointA = Vec2.zero();
                    this.pointB = Vec2.zero();
                    this.distance;
                    this.iterations;
                }

                /**
                 * Used to warm start Distance. Set count to zero on first call.
                 *
                 * @prop {number} metric length or area
                 * @prop {array} indexA vertices on shape A
                 * @prop {array} indexB vertices on shape B
                 * @prop {number} count
                 */
                function SimplexCache() {
                    this.metric = 0;
                    this.indexA = [];
                    this.indexB = [];
                    this.count = 0;
                }

                /**
                 * Compute the closest points between two shapes. Supports any combination of:
                 * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On
                 * the first call set SimplexCache.count to zero.
                 *
                 * @param {DistanceOutput} output
                 * @param {SimplexCache} cache
                 * @param {DistanceInput} input
                 */
                function Distance(output, cache, input) {
                    ++stats.gjkCalls;
                    var proxyA = input.proxyA;
                    var proxyB = input.proxyB;
                    var xfA = input.transformA;
                    var xfB = input.transformB;
                    //DEBUG && common.debug("cahce:", cache.metric, cache.count);
                    //DEBUG && common.debug("proxyA:", proxyA.m_count);
                    //DEBUG && common.debug("proxyB:", proxyB.m_count);
                    //DEBUG && common.debug("xfA:", xfA.p.x, xfA.p.y, xfA.q.c, xfA.q.s);
                    //DEBUG && common.debug("xfB:", xfB.p.x, xfB.p.y, xfB.q.c, xfB.q.s);
                    // Initialize the simplex.
                    var simplex = new Simplex();
                    simplex.readCache(cache, proxyA, xfA, proxyB, xfB);
                    //DEBUG && common.debug("cache", simplex.print());
                    // Get simplex vertices as an array.
                    var vertices = simplex.m_v;
                    // SimplexVertex
                    var k_maxIters = Settings.maxDistnceIterations;
                    // These store the vertices of the last simplex so that we
                    // can check for duplicates and prevent cycling.
                    var saveA = [];
                    var saveB = [];
                    // int[3]
                    var saveCount = 0;
                    var distanceSqr1 = Infinity;
                    var distanceSqr2 = Infinity;
                    // Main iteration loop.
                    var iter = 0;
                    while (iter < k_maxIters) {
                        // Copy simplex so we can identify duplicates.
                        saveCount = simplex.m_count;
                        for (var i = 0; i < saveCount; ++i) {
                            saveA[i] = vertices[i].indexA;
                            saveB[i] = vertices[i].indexB;
                        }
                        simplex.solve();
                        // If we have 3 points, then the origin is in the corresponding triangle.
                        if (simplex.m_count == 3) {
                            break;
                        }
                        // Compute closest point.
                        var p = simplex.getClosestPoint();
                        distanceSqr2 = p.lengthSquared();
                        // Ensure progress
                        if (distanceSqr2 >= distanceSqr1) {}
                        distanceSqr1 = distanceSqr2;
                        // Get search direction.
                        var d = simplex.getSearchDirection();
                        // Ensure the search direction is numerically fit.
                        if (d.lengthSquared() < Math.EPSILON * Math.EPSILON) {
                            // The origin is probably contained by a line segment
                            // or triangle. Thus the shapes are overlapped.
                            // We can't return zero here even though there may be overlap.
                            // In case the simplex is a point, segment, or triangle it is difficult
                            // to determine if the origin is contained in the CSO or very close to it.
                            break;
                        }
                        // Compute a tentative new simplex vertex using support points.
                        var vertex = vertices[simplex.m_count];
                        // SimplexVertex
                        vertex.indexA = proxyA.getSupport(Rot.mulT(xfA.q, Vec2.neg(d)));
                        vertex.wA = Transform.mul(xfA, proxyA.getVertex(vertex.indexA));
                        vertex.indexB = proxyB.getSupport(Rot.mulT(xfB.q, d));
                        vertex.wB = Transform.mul(xfB, proxyB.getVertex(vertex.indexB));
                        vertex.w = Vec2.sub(vertex.wB, vertex.wA);
                        // Iteration count is equated to the number of support point calls.
                        ++iter;
                        ++stats.gjkIters;
                        // Check for duplicate support points. This is the main termination
                        // criteria.
                        var duplicate = false;
                        for (var i = 0; i < saveCount; ++i) {
                            if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
                                duplicate = true;
                                break;
                            }
                        }
                        // If we found a duplicate support point we must exit to avoid cycling.
                        if (duplicate) {
                            break;
                        }
                        // New vertex is ok and needed.
                        ++simplex.m_count;
                    }
                    stats.gjkMaxIters = Math.max(stats.gjkMaxIters, iter);
                    // Prepare output.
                    simplex.getWitnessPoints(output.pointA, output.pointB);
                    output.distance = Vec2.distance(output.pointA, output.pointB);
                    output.iterations = iter;
                    //DEBUG && common.debug("Distance:", output.distance, output.pointA.x, output.pointA.y, output.pointB.x, output.pointB.y);
                    // Cache the simplex.
                    simplex.writeCache(cache);
                    // Apply radii if requested.
                    if (input.useRadii) {
                        var rA = proxyA.m_radius;
                        var rB = proxyB.m_radius;
                        if (output.distance > rA + rB && output.distance > Math.EPSILON) {
                            // Shapes are still no overlapped.
                            // Move the witness points to the outer surface.
                            output.distance -= rA + rB;
                            var normal = Vec2.sub(output.pointB, output.pointA);
                            normal.normalize();
                            output.pointA.wAdd(rA, normal);
                            output.pointB.wSub(rB, normal);
                        } else {
                            // Shapes are overlapped when radii are considered.
                            // Move the witness points to the middle.
                            var p = Vec2.mid(output.pointA, output.pointB);
                            output.pointA.set(p);
                            output.pointB.set(p);
                            output.distance = 0;
                        }
                    }
                }

                /**
                 * A distance proxy is used by the GJK algorithm. It encapsulates any shape.
                 */
                function DistanceProxy() {
                    this.m_buffer = [];
                    // Vec2[2]
                    this.m_vertices = [];
                    // Vec2[]
                    this.m_count = 0;
                    this.m_radius = 0;
                }

                /**
                 * Get the vertex count.
                 */
                DistanceProxy.prototype.getVertexCount = function () {
                    return this.m_count;
                };

                /**
                 * Get a vertex by index. Used by Distance.
                 */
                DistanceProxy.prototype.getVertex = function (index) {
                    //ASSERT && common.assert(0 <= index && index < this.m_count);
                    return this.m_vertices[index];
                };

                /**
                 * Get the supporting vertex index in the given direction.
                 */
                DistanceProxy.prototype.getSupport = function (d) {
                    var bestIndex = 0;
                    var bestValue = Vec2.dot(this.m_vertices[0], d);
                    for (var i = 0; i < this.m_count; ++i) {
                        var value = Vec2.dot(this.m_vertices[i], d);
                        if (value > bestValue) {
                            bestIndex = i;
                            bestValue = value;
                        }
                    }
                    return bestIndex;
                };

                /**
                 * Get the supporting vertex in the given direction.
                 */
                DistanceProxy.prototype.getSupportVertex = function (d) {
                    return this.m_vertices[this.getSupport(d)];
                };

                /**
                 * Initialize the proxy using the given shape. The shape must remain in scope
                 * while the proxy is in use.
                 */
                DistanceProxy.prototype.set = function (shape, index) {
                    // TODO remove, use shape instead
                    //ASSERT && common.assert(typeof shape.computeDistanceProxy === "function");
                    shape.computeDistanceProxy(this, index);
                };

                function SimplexVertex() {
                    this.indexA;
                    // wA index
                    this.indexB;
                    // wB index
                    this.wA = Vec2.zero();
                    // support point in proxyA
                    this.wB = Vec2.zero();
                    // support point in proxyB
                    this.w = Vec2.zero();
                    // wB - wA
                    this.a;
                }

                SimplexVertex.prototype.set = function (v) {
                    this.indexA = v.indexA;
                    this.indexB = v.indexB;
                    this.wA = Vec2.clone(v.wA);
                    this.wB = Vec2.clone(v.wB);
                    this.w = Vec2.clone(v.w);
                    this.a = v.a;
                };

                function Simplex() {
                    this.m_v1 = new SimplexVertex();
                    this.m_v2 = new SimplexVertex();
                    this.m_v3 = new SimplexVertex();
                    this.m_v = [this.m_v1, this.m_v2, this.m_v3];
                    this.m_count;
                }

                Simplex.prototype.print = function () {
                    if (this.m_count == 3) {
                        return ["+" + this.m_count, this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y, this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y, this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y].toString();
                    } else if (this.m_count == 2) {
                        return ["+" + this.m_count, this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y, this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y].toString();
                    } else if (this.m_count == 1) {
                        return ["+" + this.m_count, this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y].toString();
                    } else {
                        return "+" + this.m_count;
                    }
                };

                // (SimplexCache, DistanceProxy, ...)
                Simplex.prototype.readCache = function (cache, proxyA, transformA, proxyB, transformB) {
                    //ASSERT && common.assert(cache.count <= 3);
                    // Copy data from cache.
                    this.m_count = cache.count;
                    for (var i = 0; i < this.m_count; ++i) {
                        var v = this.m_v[i];
                        v.indexA = cache.indexA[i];
                        v.indexB = cache.indexB[i];
                        var wALocal = proxyA.getVertex(v.indexA);
                        var wBLocal = proxyB.getVertex(v.indexB);
                        v.wA = Transform.mul(transformA, wALocal);
                        v.wB = Transform.mul(transformB, wBLocal);
                        v.w = Vec2.sub(v.wB, v.wA);
                        v.a = 0;
                    }
                    // Compute the new simplex metric, if it is substantially different than
                    // old metric then flush the simplex.
                    if (this.m_count > 1) {
                        var metric1 = cache.metric;
                        var metric2 = this.getMetric();
                        if (metric2 < .5 * metric1 || 2 * metric1 < metric2 || metric2 < Math.EPSILON) {
                            // Reset the simplex.
                            this.m_count = 0;
                        }
                    }
                    // If the cache is empty or invalid...
                    if (this.m_count == 0) {
                        var v = this.m_v[0];
                        // SimplexVertex
                        v.indexA = 0;
                        v.indexB = 0;
                        var wALocal = proxyA.getVertex(0);
                        var wBLocal = proxyB.getVertex(0);
                        v.wA = Transform.mul(transformA, wALocal);
                        v.wB = Transform.mul(transformB, wBLocal);
                        v.w = Vec2.sub(v.wB, v.wA);
                        v.a = 1;
                        this.m_count = 1;
                    }
                };

                // (SimplexCache)
                Simplex.prototype.writeCache = function (cache) {
                    cache.metric = this.getMetric();
                    cache.count = this.m_count;
                    for (var i = 0; i < this.m_count; ++i) {
                        cache.indexA[i] = this.m_v[i].indexA;
                        cache.indexB[i] = this.m_v[i].indexB;
                    }
                };

                Simplex.prototype.getSearchDirection = function () {
                    switch (this.m_count) {
                        case 1:
                            return Vec2.neg(this.m_v1.w);

                        case 2:
                            {
                                var e12 = Vec2.sub(this.m_v2.w, this.m_v1.w);
                                var sgn = Vec2.cross(e12, Vec2.neg(this.m_v1.w));
                                if (sgn > 0) {
                                    // Origin is left of e12.
                                    return Vec2.cross(1, e12);
                                } else {
                                    // Origin is right of e12.
                                    return Vec2.cross(e12, 1);
                                }
                            }

                        default:
                            //ASSERT && common.assert(false);
                            return Vec2.zero();
                    }
                };

                Simplex.prototype.getClosestPoint = function () {
                    switch (this.m_count) {
                        case 0:
                            //ASSERT && common.assert(false);
                            return Vec2.zero();

                        case 1:
                            return Vec2.clone(this.m_v1.w);

                        case 2:
                            return Vec2.wAdd(this.m_v1.a, this.m_v1.w, this.m_v2.a, this.m_v2.w);

                        case 3:
                            return Vec2.zero();

                        default:
                            //ASSERT && common.assert(false);
                            return Vec2.zero();
                    }
                };

                Simplex.prototype.getWitnessPoints = function (pA, pB) {
                    switch (this.m_count) {
                        case 0:
                            //ASSERT && common.assert(false);
                            break;

                        case 1:
                            //DEBUG && common.debug("case1", this.print());
                            pA.set(this.m_v1.wA);
                            pB.set(this.m_v1.wB);
                            break;

                        case 2:
                            //DEBUG && common.debug("case2", this.print());
                            pA.wSet(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);
                            pB.wSet(this.m_v1.a, this.m_v1.wB, this.m_v2.a, this.m_v2.wB);
                            break;

                        case 3:
                            //DEBUG && common.debug("case3", this.print());
                            pA.wSet(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);
                            pA.wAdd(this.m_v3.a, this.m_v3.wA);
                            pB.set(pA);
                            break;

                        default:
                            //ASSERT && common.assert(false);
                            break;
                    }
                };

                Simplex.prototype.getMetric = function () {
                    switch (this.m_count) {
                        case 0:
                            //ASSERT && common.assert(false);
                            return 0;

                        case 1:
                            return 0;

                        case 2:
                            return Vec2.distance(this.m_v1.w, this.m_v2.w);

                        case 3:
                            return Vec2.cross(Vec2.sub(this.m_v2.w, this.m_v1.w), Vec2.sub(this.m_v3.w, this.m_v1.w));

                        default:
                            //ASSERT && common.assert(false);
                            return 0;
                    }
                };

                Simplex.prototype.solve = function () {
                    switch (this.m_count) {
                        case 1:
                            break;

                        case 2:
                            this.solve2();
                            break;

                        case 3:
                            this.solve3();
                            break;

                        default:
                        //ASSERT && common.assert(false);
                    }
                };

                // Solve a line segment using barycentric coordinates.
                //
                // p = a1 * w1 + a2 * w2
                // a1 + a2 = 1
                //
                // The vector from the origin to the closest point on the line is
                // perpendicular to the line.
                // e12 = w2 - w1
                // dot(p, e) = 0
                // a1 * dot(w1, e) + a2 * dot(w2, e) = 0
                //
                // 2-by-2 linear system
                // [1 1 ][a1] = [1]
                // [w1.e12 w2.e12][a2] = [0]
                //
                // Define
                // d12_1 = dot(w2, e12)
                // d12_2 = -dot(w1, e12)
                // d12 = d12_1 + d12_2
                //
                // Solution
                // a1 = d12_1 / d12
                // a2 = d12_2 / d12
                Simplex.prototype.solve2 = function () {
                    var w1 = this.m_v1.w;
                    var w2 = this.m_v2.w;
                    var e12 = Vec2.sub(w2, w1);
                    // w1 region
                    var d12_2 = -Vec2.dot(w1, e12);
                    if (d12_2 <= 0) {
                        // a2 <= 0, so we clamp it to 0
                        this.m_v1.a = 1;
                        this.m_count = 1;
                        return;
                    }
                    // w2 region
                    var d12_1 = Vec2.dot(w2, e12);
                    if (d12_1 <= 0) {
                        // a1 <= 0, so we clamp it to 0
                        this.m_v2.a = 1;
                        this.m_count = 1;
                        this.m_v1.set(this.m_v2);
                        return;
                    }
                    // Must be in e12 region.
                    var inv_d12 = 1 / (d12_1 + d12_2);
                    this.m_v1.a = d12_1 * inv_d12;
                    this.m_v2.a = d12_2 * inv_d12;
                    this.m_count = 2;
                };

                // Possible regions:
                // - points[2]
                // - edge points[0]-points[2]
                // - edge points[1]-points[2]
                // - inside the triangle
                Simplex.prototype.solve3 = function () {
                    var w1 = this.m_v1.w;
                    var w2 = this.m_v2.w;
                    var w3 = this.m_v3.w;
                    // Edge12
                    // [1 1 ][a1] = [1]
                    // [w1.e12 w2.e12][a2] = [0]
                    // a3 = 0
                    var e12 = Vec2.sub(w2, w1);
                    var w1e12 = Vec2.dot(w1, e12);
                    var w2e12 = Vec2.dot(w2, e12);
                    var d12_1 = w2e12;
                    var d12_2 = -w1e12;
                    // Edge13
                    // [1 1 ][a1] = [1]
                    // [w1.e13 w3.e13][a3] = [0]
                    // a2 = 0
                    var e13 = Vec2.sub(w3, w1);
                    var w1e13 = Vec2.dot(w1, e13);
                    var w3e13 = Vec2.dot(w3, e13);
                    var d13_1 = w3e13;
                    var d13_2 = -w1e13;
                    // Edge23
                    // [1 1 ][a2] = [1]
                    // [w2.e23 w3.e23][a3] = [0]
                    // a1 = 0
                    var e23 = Vec2.sub(w3, w2);
                    // Vec2
                    var w2e23 = Vec2.dot(w2, e23);
                    var w3e23 = Vec2.dot(w3, e23);
                    var d23_1 = w3e23;
                    var d23_2 = -w2e23;
                    // Triangle123
                    var n123 = Vec2.cross(e12, e13);
                    var d123_1 = n123 * Vec2.cross(w2, w3);
                    var d123_2 = n123 * Vec2.cross(w3, w1);
                    var d123_3 = n123 * Vec2.cross(w1, w2);
                    // w1 region
                    if (d12_2 <= 0 && d13_2 <= 0) {
                        this.m_v1.a = 1;
                        this.m_count = 1;
                        return;
                    }
                    // e12
                    if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
                        var inv_d12 = 1 / (d12_1 + d12_2);
                        this.m_v1.a = d12_1 * inv_d12;
                        this.m_v2.a = d12_2 * inv_d12;
                        this.m_count = 2;
                        return;
                    }
                    // e13
                    if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
                        var inv_d13 = 1 / (d13_1 + d13_2);
                        this.m_v1.a = d13_1 * inv_d13;
                        this.m_v3.a = d13_2 * inv_d13;
                        this.m_count = 2;
                        this.m_v2.set(this.m_v3);
                        return;
                    }
                    // w2 region
                    if (d12_1 <= 0 && d23_2 <= 0) {
                        this.m_v2.a = 1;
                        this.m_count = 1;
                        this.m_v1.set(this.m_v2);
                        return;
                    }
                    // w3 region
                    if (d13_1 <= 0 && d23_1 <= 0) {
                        this.m_v3.a = 1;
                        this.m_count = 1;
                        this.m_v1.set(this.m_v3);
                        return;
                    }
                    // e23
                    if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
                        var inv_d23 = 1 / (d23_1 + d23_2);
                        this.m_v2.a = d23_1 * inv_d23;
                        this.m_v3.a = d23_2 * inv_d23;
                        this.m_count = 2;
                        this.m_v1.set(this.m_v3);
                        return;
                    }
                    // Must be in triangle123
                    var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
                    this.m_v1.a = d123_1 * inv_d123;
                    this.m_v2.a = d123_2 * inv_d123;
                    this.m_v3.a = d123_3 * inv_d123;
                    this.m_count = 3;
                };

                /**
                 * Determine if two generic shapes overlap.
                 */
                Distance.testOverlap = function (shapeA, indexA, shapeB, indexB, xfA, xfB) {
                    var input = new DistanceInput();
                    input.proxyA.set(shapeA, indexA);
                    input.proxyB.set(shapeB, indexB);
                    input.transformA = xfA;
                    input.transformB = xfB;
                    input.useRadii = true;
                    var cache = new SimplexCache();
                    var output = new DistanceOutput();
                    Distance(output, cache, input);
                    return output.distance < 10 * Math.EPSILON;
                };
            }, { "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../common/stats": 26, "../util/Timer": 49, "../util/common": 50 }], 14: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var Settings = require("../Settings");

                var common = require("../util/common");

                var Pool = require("../util/Pool");

                var Vec2 = require("../common/Vec2");

                var Math = require("../common/Math");

                var AABB = require("./AABB");

                module.exports = DynamicTree;

                /**
                 * A node in the dynamic tree. The client does not interact with this directly.
                 * 
                 * @prop {AABB} aabb Enlarged AABB
                 * @prop {integer} height 0: leaf, -1: free node
                 */
                function TreeNode(id) {
                    this.id = id;
                    this.aabb = new AABB();
                    this.userData = null;
                    this.parent = null;
                    this.child1 = null;
                    this.child2 = null;
                    this.height = -1;
                    this.toString = function () {
                        return this.id + ": " + this.userData;
                    };
                }

                TreeNode.prototype.isLeaf = function () {
                    return this.child1 == null;
                };

                /**
                 * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A
                 * dynamic tree arranges data in a binary tree to accelerate queries such as
                 * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we
                 * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger
                 * than the client object. This allows the client object to move by small
                 * amounts without triggering a tree update.
                 * 
                 * Nodes are pooled and relocatable, so we use node indices rather than
                 * pointers.
                 */
                function DynamicTree() {
                    this.m_root = null;
                    this.m_nodes = {};
                    this.m_lastProxyId = 0;
                    this.m_pool = new Pool({
                        create: function create() {
                            return new TreeNode();
                        }
                    });
                }

                /**
                 * Get proxy user data.
                 * 
                 * @return the proxy user data or 0 if the id is invalid.
                 */
                DynamicTree.prototype.getUserData = function (id) {
                    var node = this.m_nodes[id];
                    //ASSERT && common.assert(!!node);
                    return node.userData;
                };

                /**
                 * Get the fat AABB for a node id.
                 * 
                 * @return the proxy user data or 0 if the id is invalid.
                 */
                DynamicTree.prototype.getFatAABB = function (id) {
                    var node = this.m_nodes[id];
                    //ASSERT && common.assert(!!node);
                    return node.aabb;
                };

                DynamicTree.prototype.allocateNode = function () {
                    var node = this.m_pool.allocate();
                    node.id = ++this.m_lastProxyId;
                    node.userData = null;
                    node.parent = null;
                    node.child1 = null;
                    node.child2 = null;
                    node.height = -1;
                    this.m_nodes[node.id] = node;
                    return node;
                };

                DynamicTree.prototype.freeNode = function (node) {
                    this.m_pool.release(node);
                    node.height = -1;
                    delete this.m_nodes[node.id];
                };

                /**
                 * Create a proxy in the tree as a leaf node. We return the index of the node
                 * instead of a pointer so that we can grow the node pool.
                 * 
                 * Create a proxy. Provide a tight fitting AABB and a userData pointer.
                 */
                DynamicTree.prototype.createProxy = function (aabb, userData) {
                    //ASSERT && common.assert(AABB.isValid(aabb));
                    var node = this.allocateNode();
                    node.aabb.set(aabb);
                    // Fatten the aabb.
                    AABB.extend(node.aabb, Settings.aabbExtension);
                    node.userData = userData;
                    node.height = 0;
                    this.insertLeaf(node);
                    return node.id;
                };

                /**
                 * Destroy a proxy. This asserts if the id is invalid.
                 */
                DynamicTree.prototype.destroyProxy = function (id) {
                    var node = this.m_nodes[id];
                    //ASSERT && common.assert(!!node);
                    //ASSERT && common.assert(node.isLeaf());
                    this.removeLeaf(node);
                    this.freeNode(node);
                };

                /**
                 * Move a proxy with a swepted AABB. If the proxy has moved outside of its
                 * fattened AABB, then the proxy is removed from the tree and re-inserted.
                 * Otherwise the function returns immediately.
                 * 
                 * @param id
                 * @param aabb
                 * @param {Vec2} d Displacement
                 * 
                 * @return true if the proxy was re-inserted.
                 */
                DynamicTree.prototype.moveProxy = function (id, aabb, d) {
                    //ASSERT && common.assert(AABB.isValid(aabb));
                    //ASSERT && common.assert(!d || Vec2.isValid(d));
                    var node = this.m_nodes[id];
                    //ASSERT && common.assert(!!node);
                    //ASSERT && common.assert(node.isLeaf());
                    if (node.aabb.contains(aabb)) {
                        return false;
                    }
                    this.removeLeaf(node);
                    node.aabb.set(aabb);
                    // Extend AABB.
                    aabb = node.aabb;
                    AABB.extend(aabb, Settings.aabbExtension);
                    // Predict AABB displacement.
                    // var d = Vec2.mul(Settings.aabbMultiplier, displacement);
                    if (d.x < 0) {
                        aabb.lowerBound.x += d.x * Settings.aabbMultiplier;
                    } else {
                        aabb.upperBound.x += d.x * Settings.aabbMultiplier;
                    }
                    if (d.y < 0) {
                        aabb.lowerBound.y += d.y * Settings.aabbMultiplier;
                    } else {
                        aabb.upperBound.y += d.y * Settings.aabbMultiplier;
                    }
                    this.insertLeaf(node);
                    return true;
                };

                DynamicTree.prototype.insertLeaf = function (leaf) {
                    //ASSERT && common.assert(AABB.isValid(leaf.aabb));
                    if (this.m_root == null) {
                        this.m_root = leaf;
                        this.m_root.parent = null;
                        return;
                    }
                    // Find the best sibling for this node
                    var leafAABB = leaf.aabb;
                    var index = this.m_root;
                    while (index.isLeaf() == false) {
                        var child1 = index.child1;
                        var child2 = index.child2;
                        var area = index.aabb.getPerimeter();
                        var combinedAABB = new AABB();
                        combinedAABB.combine(index.aabb, leafAABB);
                        var combinedArea = combinedAABB.getPerimeter();
                        // Cost of creating a new parent for this node and the new leaf
                        var cost = 2 * combinedArea;
                        // Minimum cost of pushing the leaf further down the tree
                        var inheritanceCost = 2 * (combinedArea - area);
                        // Cost of descending into child1
                        var cost1;
                        if (child1.isLeaf()) {
                            var aabb = new AABB();
                            aabb.combine(leafAABB, child1.aabb);
                            cost1 = aabb.getPerimeter() + inheritanceCost;
                        } else {
                            var aabb = new AABB();
                            aabb.combine(leafAABB, child1.aabb);
                            var oldArea = child1.aabb.getPerimeter();
                            var newArea = aabb.getPerimeter();
                            cost1 = newArea - oldArea + inheritanceCost;
                        }
                        // Cost of descending into child2
                        var cost2;
                        if (child2.isLeaf()) {
                            var aabb = new AABB();
                            aabb.combine(leafAABB, child2.aabb);
                            cost2 = aabb.getPerimeter() + inheritanceCost;
                        } else {
                            var aabb = new AABB();
                            aabb.combine(leafAABB, child2.aabb);
                            var oldArea = child2.aabb.getPerimeter();
                            var newArea = aabb.getPerimeter();
                            cost2 = newArea - oldArea + inheritanceCost;
                        }
                        // Descend according to the minimum cost.
                        if (cost < cost1 && cost < cost2) {
                            break;
                        }
                        // Descend
                        if (cost1 < cost2) {
                            index = child1;
                        } else {
                            index = child2;
                        }
                    }
                    var sibling = index;
                    // Create a new parent.
                    var oldParent = sibling.parent;
                    var newParent = this.allocateNode();
                    newParent.parent = oldParent;
                    newParent.userData = null;
                    newParent.aabb.combine(leafAABB, sibling.aabb);
                    newParent.height = sibling.height + 1;
                    if (oldParent != null) {
                        // The sibling was not the root.
                        if (oldParent.child1 == sibling) {
                            oldParent.child1 = newParent;
                        } else {
                            oldParent.child2 = newParent;
                        }
                        newParent.child1 = sibling;
                        newParent.child2 = leaf;
                        sibling.parent = newParent;
                        leaf.parent = newParent;
                    } else {
                        // The sibling was the root.
                        newParent.child1 = sibling;
                        newParent.child2 = leaf;
                        sibling.parent = newParent;
                        leaf.parent = newParent;
                        this.m_root = newParent;
                    }
                    // Walk back up the tree fixing heights and AABBs
                    index = leaf.parent;
                    while (index != null) {
                        index = this.balance(index);
                        var child1 = index.child1;
                        var child2 = index.child2;
                        //ASSERT && common.assert(child1 != null);
                        //ASSERT && common.assert(child2 != null);
                        index.height = 1 + Math.max(child1.height, child2.height);
                        index.aabb.combine(child1.aabb, child2.aabb);
                        index = index.parent;
                    }
                };

                DynamicTree.prototype.removeLeaf = function (leaf) {
                    if (leaf == this.m_root) {
                        this.m_root = null;
                        return;
                    }
                    var parent = leaf.parent;
                    var grandParent = parent.parent;
                    var sibling;
                    if (parent.child1 == leaf) {
                        sibling = parent.child2;
                    } else {
                        sibling = parent.child1;
                    }
                    if (grandParent != null) {
                        // Destroy parent and connect sibling to grandParent.
                        if (grandParent.child1 == parent) {
                            grandParent.child1 = sibling;
                        } else {
                            grandParent.child2 = sibling;
                        }
                        sibling.parent = grandParent;
                        this.freeNode(parent);
                        // Adjust ancestor bounds.
                        var index = grandParent;
                        while (index != null) {
                            index = this.balance(index);
                            var child1 = index.child1;
                            var child2 = index.child2;
                            index.aabb.combine(child1.aabb, child2.aabb);
                            index.height = 1 + Math.max(child1.height, child2.height);
                            index = index.parent;
                        }
                    } else {
                        this.m_root = sibling;
                        sibling.parent = null;
                        this.freeNode(parent);
                    }
                };

                /**
                 * Perform a left or right rotation if node A is imbalanced. Returns the new
                 * root index.
                 */
                DynamicTree.prototype.balance = function (iA) {
                    //ASSERT && common.assert(iA != null);
                    var A = iA;
                    if (A.isLeaf() || A.height < 2) {
                        return iA;
                    }
                    var B = A.child1;
                    var C = A.child2;
                    var balance = C.height - B.height;
                    // Rotate C up
                    if (balance > 1) {
                        var F = C.child1;
                        var G = C.child2;
                        // Swap A and C
                        C.child1 = A;
                        C.parent = A.parent;
                        A.parent = C;
                        // A's old parent should point to C
                        if (C.parent != null) {
                            if (C.parent.child1 == iA) {
                                C.parent.child1 = C;
                            } else {
                                C.parent.child2 = C;
                            }
                        } else {
                            this.m_root = C;
                        }
                        // Rotate
                        if (F.height > G.height) {
                            C.child2 = F;
                            A.child2 = G;
                            G.parent = A;
                            A.aabb.combine(B.aabb, G.aabb);
                            C.aabb.combine(A.aabb, F.aabb);
                            A.height = 1 + Math.max(B.height, G.height);
                            C.height = 1 + Math.max(A.height, F.height);
                        } else {
                            C.child2 = G;
                            A.child2 = F;
                            F.parent = A;
                            A.aabb.combine(B.aabb, F.aabb);
                            C.aabb.combine(A.aabb, G.aabb);
                            A.height = 1 + Math.max(B.height, F.height);
                            C.height = 1 + Math.max(A.height, G.height);
                        }
                        return C;
                    }
                    // Rotate B up
                    if (balance < -1) {
                        var D = B.child1;
                        var E = B.child2;
                        // Swap A and B
                        B.child1 = A;
                        B.parent = A.parent;
                        A.parent = B;
                        // A's old parent should point to B
                        if (B.parent != null) {
                            if (B.parent.child1 == A) {
                                B.parent.child1 = B;
                            } else {
                                B.parent.child2 = B;
                            }
                        } else {
                            this.m_root = B;
                        }
                        // Rotate
                        if (D.height > E.height) {
                            B.child2 = D;
                            A.child1 = E;
                            E.parent = A;
                            A.aabb.combine(C.aabb, E.aabb);
                            B.aabb.combine(A.aabb, D.aabb);
                            A.height = 1 + Math.max(C.height, E.height);
                            B.height = 1 + Math.max(A.height, D.height);
                        } else {
                            B.child2 = E;
                            A.child1 = D;
                            D.parent = A;
                            A.aabb.combine(C.aabb, D.aabb);
                            B.aabb.combine(A.aabb, E.aabb);
                            A.height = 1 + Math.max(C.height, D.height);
                            B.height = 1 + Math.max(A.height, E.height);
                        }
                        return B;
                    }
                    return A;
                };

                /**
                 * Compute the height of the binary tree in O(N) time. Should not be called
                 * often.
                 */
                DynamicTree.prototype.getHeight = function () {
                    if (this.m_root == null) {
                        return 0;
                    }
                    return this.m_root.height;
                };

                /**
                 * Get the ratio of the sum of the node areas to the root area.
                 */
                DynamicTree.prototype.getAreaRatio = function () {
                    if (this.m_root == null) {
                        return 0;
                    }
                    var root = this.m_root;
                    var rootArea = root.aabb.getPerimeter();
                    var totalArea = 0;
                    var node,
                        it = iteratorPool.allocate().preorder();
                    while (node = it.next()) {
                        if (node.height < 0) {
                            // Free node in pool
                            continue;
                        }
                        totalArea += node.aabb.getPerimeter();
                    }
                    iteratorPool.release(it);
                    return totalArea / rootArea;
                };

                /**
                 * Compute the height of a sub-tree.
                 */
                DynamicTree.prototype.computeHeight = function (id) {
                    var node;
                    if (typeof id !== "undefined") {
                        node = this.m_nodes[id];
                    } else {
                        node = this.m_root;
                    }
                    // //ASSERT && common.assert(0 <= id && id < this.m_nodeCapacity);
                    if (node.isLeaf()) {
                        return 0;
                    }
                    var height1 = ComputeHeight(node.child1);
                    var height2 = ComputeHeight(node.child2);
                    return 1 + Math.max(height1, height2);
                };

                DynamicTree.prototype.validateStructure = function (node) {
                    if (node == null) {
                        return;
                    }
                    if (node == this.m_root) {
                        //ASSERT && common.assert(node.parent == null);
                    }
                    var child1 = node.child1;
                    var child2 = node.child2;
                    if (node.isLeaf()) {
                        //ASSERT && common.assert(child1 == null);
                        //ASSERT && common.assert(child2 == null);
                        //ASSERT && common.assert(node.height == 0);
                        return;
                    }
                    // //ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);
                    // ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);
                    //ASSERT && common.assert(child1.parent == node);
                    //ASSERT && common.assert(child2.parent == node);
                    this.validateStructure(child1);
                    this.validateStructure(child2);
                };

                DynamicTree.prototype.validateMetrics = function (node) {
                    if (node == null) {
                        return;
                    }
                    var child1 = node.child1;
                    var child2 = node.child2;
                    if (node.isLeaf()) {
                        //ASSERT && common.assert(child1 == null);
                        //ASSERT && common.assert(child2 == null);
                        //ASSERT && common.assert(node.height == 0);
                        return;
                    }
                    // ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);
                    // ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);
                    var height1 = this.m_nodes[child1].height;
                    var height2 = this.m_nodes[child2].height;
                    var height = 1 + Math.max(height1, height2);
                    //ASSERT && common.assert(node.height == height);
                    var aabb = new AABB();
                    aabb.combine(child1.aabb, child2.aabb);
                    //ASSERT && common.assert(AABB.areEqual(aabb, node.aabb));
                    this.validateMetrics(child1);
                    this.validateMetrics(child2);
                };

                // Validate this tree. For testing.
                DynamicTree.prototype.validate = function () {
                    ValidateStructure(this.m_root);
                    ValidateMetrics(this.m_root);
                    //ASSERT && common.assert(this.getHeight() == this.computeHeight());
                };

                /**
                 * Get the maximum balance of an node in the tree. The balance is the difference
                 * in height of the two children of a node.
                 */
                DynamicTree.prototype.getMaxBalance = function () {
                    var maxBalance = 0;
                    var node,
                        it = iteratorPool.allocate().preorder();
                    while (node = it.next()) {
                        if (node.height <= 1) {
                            continue;
                        }
                        //ASSERT && common.assert(node.isLeaf() == false);
                        var balance = Math.abs(node.child2.height - node.child1.height);
                        maxBalance = Math.max(maxBalance, balance);
                    }
                    iteratorPool.release(it);
                    return maxBalance;
                };

                /**
                 * Build an optimal tree. Very expensive. For testing.
                 */
                DynamicTree.prototype.rebuildBottomUp = function () {
                    var nodes = [];
                    var count = 0;
                    // Build array of leaves. Free the rest.
                    var node,
                        it = iteratorPool.allocate().preorder();
                    while (node = it.next()) {
                        if (node.height < 0) {
                            // free node in pool
                            continue;
                        }
                        if (node.isLeaf()) {
                            node.parent = null;
                            nodes[count] = node;
                            ++count;
                        } else {
                            this.freeNode(node);
                        }
                    }
                    iteratorPool.release(it);
                    while (count > 1) {
                        var minCost = Infinity;
                        var iMin = -1,
                            jMin = -1;
                        for (var i = 0; i < count; ++i) {
                            var aabbi = nodes[i].aabb;
                            for (var j = i + 1; j < count; ++j) {
                                var aabbj = nodes[j].aabb;
                                var b = new AABB();
                                b.combine(aabbi, aabbj);
                                var cost = b.getPerimeter();
                                if (cost < minCost) {
                                    iMin = i;
                                    jMin = j;
                                    minCost = cost;
                                }
                            }
                        }
                        var child1 = nodes[iMin];
                        var child2 = nodes[jMin];
                        var parent = this.allocateNode();
                        parent.child1 = child1;
                        parent.child2 = child2;
                        parent.height = 1 + Math.max(child1.height, child2.height);
                        parent.aabb.combine(child1.aabb, child2.aabb);
                        parent.parent = null;
                        child1.parent = parent;
                        child2.parent = parent;
                        nodes[jMin] = nodes[count - 1];
                        nodes[iMin] = parent;
                        --count;
                    }
                    this.m_root = nodes[0];
                    this.validate();
                };

                /**
                 * Shift the world origin. Useful for large worlds. The shift formula is:
                 * position -= newOrigin
                 * 
                 * @param newOrigin The new origin with respect to the old origin
                 */
                DynamicTree.prototype.shiftOrigin = function (newOrigin) {
                    // Build array of leaves. Free the rest.
                    var node,
                        it = iteratorPool.allocate().preorder();
                    while (node = it.next()) {
                        var aabb = node.aabb;
                        aabb.lowerBound.x -= newOrigin.x;
                        aabb.lowerBound.y -= newOrigin.y;
                        aabb.lowerBound.x -= newOrigin.x;
                        aabb.lowerBound.y -= newOrigin.y;
                    }
                    iteratorPool.release(it);
                };

                /**
                 * @function {DynamicTree~queryCallback}
                 * 
                 * @param id Node id.
                 */
                /**
                 * Query an AABB for overlapping proxies. The callback class is called for each
                 * proxy that overlaps the supplied AABB.
                 * 
                 * @param {DynamicTree~queryCallback} queryCallback
                 */
                DynamicTree.prototype.query = function (aabb, queryCallback) {
                    //ASSERT && common.assert(typeof queryCallback === "function");
                    var stack = stackPool.allocate();
                    stack.push(this.m_root);
                    while (stack.length > 0) {
                        var node = stack.pop();
                        if (node == null) {
                            continue;
                        }
                        if (AABB.testOverlap(node.aabb, aabb)) {
                            if (node.isLeaf()) {
                                var proceed = queryCallback(node.id);
                                if (proceed == false) {
                                    return;
                                }
                            } else {
                                stack.push(node.child1);
                                stack.push(node.child2);
                            }
                        }
                    }
                    stackPool.release(stack);
                };

                /**
                 * Ray-cast against the proxies in the tree. This relies on the callback to
                 * perform a exact ray-cast in the case were the proxy contains a shape. The
                 * callback also performs the any collision filtering. This has performance
                 * roughly equal to k * log(n), where k is the number of collisions and n is the
                 * number of proxies in the tree.
                 * 
                 * @param input The ray-cast input data. The ray extends from p1 to p1 +
                 *          maxFraction * (p2 - p1).
                 * @param rayCastCallback A function that is called for each proxy that is hit by
                 *          the ray.
                 */
                DynamicTree.prototype.rayCast = function (input, rayCastCallback) {
                    // TODO GC
                    //ASSERT && common.assert(typeof rayCastCallback === "function");
                    var p1 = input.p1;
                    var p2 = input.p2;
                    var r = Vec2.sub(p2, p1);
                    //ASSERT && common.assert(r.lengthSquared() > 0);
                    r.normalize();
                    // v is perpendicular to the segment.
                    var v = Vec2.cross(1, r);
                    var abs_v = Vec2.abs(v);
                    // Separating axis for segment (Gino, p80).
                    // |dot(v, p1 - c)| > dot(|v|, h)
                    var maxFraction = input.maxFraction;
                    // Build a bounding box for the segment.
                    var segmentAABB = new AABB();
                    var t = Vec2.wAdd(1 - maxFraction, p1, maxFraction, p2);
                    segmentAABB.combinePoints(p1, t);
                    var stack = stackPool.allocate();
                    var subInput = inputPool.allocate();
                    stack.push(this.m_root);
                    while (stack.length > 0) {
                        var node = stack.pop();
                        if (node == null) {
                            continue;
                        }
                        if (AABB.testOverlap(node.aabb, segmentAABB) == false) {
                            continue;
                        }
                        // Separating axis for segment (Gino, p80).
                        // |dot(v, p1 - c)| > dot(|v|, h)
                        var c = node.aabb.getCenter();
                        var h = node.aabb.getExtents();
                        var separation = Math.abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);
                        if (separation > 0) {
                            continue;
                        }
                        if (node.isLeaf()) {
                            subInput.p1 = Vec2.clone(input.p1);
                            subInput.p2 = Vec2.clone(input.p2);
                            subInput.maxFraction = maxFraction;
                            var value = rayCastCallback(subInput, node.id);
                            if (value == 0) {
                                // The client has terminated the ray cast.
                                return;
                            }
                            if (value > 0) {
                                // update segment bounding box.
                                maxFraction = value;
                                t = Vec2.wAdd(1 - maxFraction, p1, maxFraction, p2);
                                segmentAABB.combinePoints(p1, t);
                            }
                        } else {
                            stack.push(node.child1);
                            stack.push(node.child2);
                        }
                    }
                    stackPool.release(stack);
                    inputPool.release(subInput);
                };

                var inputPool = new Pool({
                    create: function create() {
                        return {};
                    },
                    release: function release(stack) {}
                });

                var stackPool = new Pool({
                    create: function create() {
                        return [];
                    },
                    release: function release(stack) {
                        stack.length = 0;
                    }
                });

                var iteratorPool = new Pool({
                    create: function create() {
                        return new Iterator();
                    },
                    release: function release(iterator) {
                        iterator.close();
                    }
                });

                function Iterator() {
                    var parents = [];
                    var states = [];
                    return {
                        preorder: function preorder(root) {
                            parents.length = 0;
                            parents.push(root);
                            states.length = 0;
                            states.push(0);
                            return this;
                        },
                        next: function next() {
                            while (parents.length > 0) {
                                var i = parents.length - 1;
                                var node = parents[i];
                                if (states[i] === 0) {
                                    states[i] = 1;
                                    return node;
                                }
                                if (states[i] === 1) {
                                    states[i] = 2;
                                    if (node.child1) {
                                        parents.push(node.child1);
                                        states.push(1);
                                        return node.child1;
                                    }
                                }
                                if (states[i] === 2) {
                                    states[i] = 3;
                                    if (node.child2) {
                                        parents.push(node.child2);
                                        states.push(1);
                                        return node.child2;
                                    }
                                }
                                parents.pop();
                                states.pop();
                            }
                        },
                        close: function close() {
                            parents.length = 0;
                        }
                    };
                }
            }, { "../Settings": 7, "../common/Math": 18, "../common/Vec2": 23, "../util/Pool": 48, "../util/common": 50, "./AABB": 11 }], 15: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = TimeOfImpact;

                module.exports.Input = TOIInput;

                module.exports.Output = TOIOutput;

                var Settings = require("../Settings");

                var common = require("../util/common");

                var Timer = require("../util/Timer");

                var stats = require("../common/stats");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Distance = require("./Distance");

                var DistanceInput = Distance.Input;

                var DistanceOutput = Distance.Output;

                var DistanceProxy = Distance.Proxy;

                var SimplexCache = Distance.Cache;

                /**
                 * Input parameters for TimeOfImpact.
                 * 
                 * @prop {DistanceProxy} proxyA
                 * @prop {DistanceProxy} proxyB
                 * @prop {Sweep} sweepA
                 * @prop {Sweep} sweepB
                 * @prop tMax defines sweep interval [0, tMax]
                 */
                function TOIInput() {
                    this.proxyA = new DistanceProxy();
                    this.proxyB = new DistanceProxy();
                    this.sweepA = new Sweep();
                    this.sweepB = new Sweep();
                    this.tMax;
                }

                // TOIOutput State
                TOIOutput.e_unknown = 0;

                TOIOutput.e_failed = 1;

                TOIOutput.e_overlapped = 2;

                TOIOutput.e_touching = 3;

                TOIOutput.e_separated = 4;

                /**
                 * Output parameters for TimeOfImpact.
                 * 
                 * @prop state
                 * @prop t
                 */
                function TOIOutput() {
                    this.state;
                    this.t;
                }

                stats.toiTime = 0;

                stats.toiMaxTime = 0;

                stats.toiCalls = 0;

                stats.toiIters = 0;

                stats.toiMaxIters = 0;

                stats.toiRootIters = 0;

                stats.toiMaxRootIters = 0;

                /**
                 * Compute the upper bound on time before two shapes penetrate. Time is
                 * represented as a fraction between [0,tMax]. This uses a swept separating axis
                 * and may miss some intermediate, non-tunneling collision. If you change the
                 * time interval, you should call this function again.
                 * 
                 * Note: use Distance to compute the contact point and normal at the time of
                 * impact.
                 * 
                 * CCD via the local separating axis method. This seeks progression by computing
                 * the largest time at which separation is maintained.
                 */
                function TimeOfImpact(output, input) {
                    var timer = Timer.now();
                    ++stats.toiCalls;
                    output.state = TOIOutput.e_unknown;
                    output.t = input.tMax;
                    var proxyA = input.proxyA;
                    // DistanceProxy
                    var proxyB = input.proxyB;
                    // DistanceProxy
                    var sweepA = input.sweepA;
                    // Sweep
                    var sweepB = input.sweepB;
                    // Sweep
                    //DEBUG && common.debug("sweepA", sweepA.localCenter.x, sweepA.localCenter.y, sweepA.c.x, sweepA.c.y, sweepA.a, sweepA.alpha0, sweepA.c0.x, sweepA.c0.y, sweepA.a0);
                    //DEBUG && common.debug("sweepB", sweepB.localCenter.x, sweepB.localCenter.y, sweepB.c.x, sweepB.c.y, sweepB.a, sweepB.alpha0, sweepB.c0.x, sweepB.c0.y, sweepB.a0);
                    // Large rotations can make the root finder fail, so we normalize the
                    // sweep angles.
                    sweepA.normalize();
                    sweepB.normalize();
                    var tMax = input.tMax;
                    var totalRadius = proxyA.m_radius + proxyB.m_radius;
                    var target = Math.max(Settings.linearSlop, totalRadius - 3 * Settings.linearSlop);
                    var tolerance = .25 * Settings.linearSlop;
                    //ASSERT && common.assert(target > tolerance);
                    var t1 = 0;
                    var k_maxIterations = Settings.maxTOIIterations;
                    var iter = 0;
                    // Prepare input for distance query.
                    var cache = new SimplexCache();
                    var distanceInput = new DistanceInput();
                    distanceInput.proxyA = input.proxyA;
                    distanceInput.proxyB = input.proxyB;
                    distanceInput.useRadii = false;
                    // The outer loop progressively attempts to compute new separating axes.
                    // This loop terminates when an axis is repeated (no progress is made).
                    for (;;) {
                        var xfA = Transform.identity();
                        var xfB = Transform.identity();
                        sweepA.getTransform(xfA, t1);
                        sweepB.getTransform(xfB, t1);
                        //DEBUG && common.debug("xfA:", xfA.p.x, xfA.p.y, xfA.q.c, xfA.q.s);
                        //DEBUG && common.debug("xfB:", xfB.p.x, xfB.p.y, xfB.q.c, xfB.q.s);
                        // Get the distance between shapes. We can also use the results
                        // to get a separating axis.
                        distanceInput.transformA = xfA;
                        distanceInput.transformB = xfB;
                        var distanceOutput = new DistanceOutput();
                        Distance(distanceOutput, cache, distanceInput);
                        //DEBUG && common.debug("distance:", distanceOutput.distance);
                        // If the shapes are overlapped, we give up on continuous collision.
                        if (distanceOutput.distance <= 0) {
                            // Failure!
                            output.state = TOIOutput.e_overlapped;
                            output.t = 0;
                            break;
                        }
                        if (distanceOutput.distance < target + tolerance) {
                            // Victory!
                            output.state = TOIOutput.e_touching;
                            output.t = t1;
                            break;
                        }
                        // Initialize the separating axis.
                        var fcn = new SeparationFunction();
                        fcn.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);
                        if (false) {
                            // Dump the curve seen by the root finder
                            var N = 100;
                            var dx = 1 / N;
                            var xs = [];
                            // [ N + 1 ];
                            var fs = [];
                            // [ N + 1 ];
                            var x = 0;
                            for (var i = 0; i <= N; ++i) {
                                sweepA.getTransform(xfA, x);
                                sweepB.getTransform(xfB, x);
                                var f = fcn.evaluate(xfA, xfB) - target;
                                printf("%g %g\n", x, f);
                                xs[i] = x;
                                fs[i] = f;
                                x += dx;
                            }
                        }
                        // Compute the TOI on the separating axis. We do this by successively
                        // resolving the deepest point. This loop is bounded by the number of
                        // vertices.
                        var done = false;
                        var t2 = tMax;
                        var pushBackIter = 0;
                        for (;;) {
                            // Find the deepest point at t2. Store the witness point indices.
                            var s2 = fcn.findMinSeparation(t2);
                            var indexA = fcn.indexA;
                            var indexB = fcn.indexB;
                            // Is the final configuration separated?
                            if (s2 > target + tolerance) {
                                // Victory!
                                output.state = TOIOutput.e_separated;
                                output.t = tMax;
                                done = true;
                                break;
                            }
                            // Has the separation reached tolerance?
                            if (s2 > target - tolerance) {
                                // Advance the sweeps
                                t1 = t2;
                                break;
                            }
                            // Compute the initial separation of the witness points.
                            var s1 = fcn.evaluate(t1);
                            var indexA = fcn.indexA;
                            var indexB = fcn.indexB;
                            //DEBUG && common.debug("s1:", s1, target, tolerance, t1);
                            // Check for initial overlap. This might happen if the root finder
                            // runs out of iterations.
                            if (s1 < target - tolerance) {
                                output.state = TOIOutput.e_failed;
                                output.t = t1;
                                done = true;
                                break;
                            }
                            // Check for touching
                            if (s1 <= target + tolerance) {
                                // Victory! t1 should hold the TOI (could be 0.0).
                                output.state = TOIOutput.e_touching;
                                output.t = t1;
                                done = true;
                                break;
                            }
                            // Compute 1D root of: f(x) - target = 0
                            var rootIterCount = 0;
                            var a1 = t1,
                                a2 = t2;
                            for (;;) {
                                // Use a mix of the secant rule and bisection.
                                var t;
                                if (rootIterCount & 1) {
                                    // Secant rule to improve convergence.
                                    t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
                                } else {
                                    // Bisection to guarantee progress.
                                    t = .5 * (a1 + a2);
                                }
                                ++rootIterCount;
                                ++stats.toiRootIters;
                                var s = fcn.evaluate(t);
                                var indexA = fcn.indexA;
                                var indexB = fcn.indexB;
                                if (Math.abs(s - target) < tolerance) {
                                    // t2 holds a tentative value for t1
                                    t2 = t;
                                    break;
                                }
                                // Ensure we continue to bracket the root.
                                if (s > target) {
                                    a1 = t;
                                    s1 = s;
                                } else {
                                    a2 = t;
                                    s2 = s;
                                }
                                if (rootIterCount == 50) {
                                    break;
                                }
                            }
                            stats.toiMaxRootIters = Math.max(stats.toiMaxRootIters, rootIterCount);
                            ++pushBackIter;
                            if (pushBackIter == Settings.maxPolygonVertices) {
                                break;
                            }
                        }
                        ++iter;
                        ++stats.toiIters;
                        if (done) {
                            break;
                        }
                        if (iter == k_maxIterations) {
                            // Root finder got stuck. Semi-victory.
                            output.state = TOIOutput.e_failed;
                            output.t = t1;
                            break;
                        }
                    }
                    stats.toiMaxIters = Math.max(stats.toiMaxIters, iter);
                    var time = Timer.diff(timer);
                    stats.toiMaxTime = Math.max(stats.toiMaxTime, time);
                    stats.toiTime += time;
                }

                // SeparationFunction Type
                var e_points = 1;

                var e_faceA = 2;

                var e_faceB = 3;

                function SeparationFunction() {
                    this.m_proxyA = new DistanceProxy();
                    this.m_proxyB = new DistanceProxy();
                    this.m_sweepA;
                    // Sweep
                    this.m_sweepB;
                    // Sweep
                    this.m_type;
                    this.m_localPoint = Vec2.zero();
                    this.m_axis = Vec2.zero();
                }

                // TODO_ERIN might not need to return the separation
                /**
                 * @param {SimplexCache} cache
                 * @param {DistanceProxy} proxyA
                 * @param {Sweep} sweepA
                 * @param {DistanceProxy} proxyB
                 * @param {Sweep} sweepB
                 * @param {float} t1
                 */
                SeparationFunction.prototype.initialize = function (cache, proxyA, sweepA, proxyB, sweepB, t1) {
                    this.m_proxyA = proxyA;
                    this.m_proxyB = proxyB;
                    var count = cache.count;
                    //ASSERT && common.assert(0 < count && count < 3);
                    this.m_sweepA = sweepA;
                    this.m_sweepB = sweepB;
                    var xfA = Transform.identity();
                    var xfB = Transform.identity();
                    this.m_sweepA.getTransform(xfA, t1);
                    this.m_sweepB.getTransform(xfB, t1);
                    if (count == 1) {
                        this.m_type = e_points;
                        var localPointA = this.m_proxyA.getVertex(cache.indexA[0]);
                        var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);
                        var pointA = Transform.mul(xfA, localPointA);
                        var pointB = Transform.mul(xfB, localPointB);
                        this.m_axis.wSet(1, pointB, -1, pointA);
                        var s = this.m_axis.normalize();
                        return s;
                    } else if (cache.indexA[0] == cache.indexA[1]) {
                        // Two points on B and one on A.
                        this.m_type = e_faceB;
                        var localPointB1 = proxyB.getVertex(cache.indexB[0]);
                        var localPointB2 = proxyB.getVertex(cache.indexB[1]);
                        this.m_axis = Vec2.cross(Vec2.sub(localPointB2, localPointB1), 1);
                        this.m_axis.normalize();
                        var normal = Rot.mul(xfB.q, this.m_axis);
                        this.m_localPoint = Vec2.mid(localPointB1, localPointB2);
                        var pointB = Transform.mul(xfB, this.m_localPoint);
                        var localPointA = proxyA.getVertex(cache.indexA[0]);
                        var pointA = Transform.mul(xfA, localPointA);
                        var s = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);
                        if (s < 0) {
                            this.m_axis = Vec2.neg(this.m_axis);
                            s = -s;
                        }
                        return s;
                    } else {
                        // Two points on A and one or two points on B.
                        this.m_type = e_faceA;
                        var localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);
                        var localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);
                        this.m_axis = Vec2.cross(Vec2.sub(localPointA2, localPointA1), 1);
                        this.m_axis.normalize();
                        var normal = Rot.mul(xfA.q, this.m_axis);
                        this.m_localPoint = Vec2.mid(localPointA1, localPointA2);
                        var pointA = Transform.mul(xfA, this.m_localPoint);
                        var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);
                        var pointB = Transform.mul(xfB, localPointB);
                        var s = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);
                        if (s < 0) {
                            this.m_axis = Vec2.neg(this.m_axis);
                            s = -s;
                        }
                        return s;
                    }
                };

                SeparationFunction.prototype.compute = function (find, t) {
                    // It was findMinSeparation and evaluate
                    var xfA = Transform.identity();
                    var xfB = Transform.identity();
                    this.m_sweepA.getTransform(xfA, t);
                    this.m_sweepB.getTransform(xfB, t);
                    // DEBUG && common.debug('xfB', t, this.m_sweepB.localCenter.x,
                    // this.m_sweepB.localCenter.y, this.m_sweepB.c.x, this.m_sweepB.c.y,
                    // this.m_sweepB.a, this.m_sweepB.alpha0, this.m_sweepB.c0.x,
                    // this.m_sweepB.c0.y, this.m_sweepB.a0, xfB.p.x, xfB.p.y, xfB.q.c, xfB.q.s);
                    switch (this.m_type) {
                        case e_points:
                            {
                                if (find) {
                                    var axisA = Rot.mulT(xfA.q, this.m_axis);
                                    var axisB = Rot.mulT(xfB.q, Vec2.neg(this.m_axis));
                                    this.indexA = this.m_proxyA.getSupport(axisA);
                                    this.indexB = this.m_proxyB.getSupport(axisB);
                                }
                                var localPointA = this.m_proxyA.getVertex(this.indexA);
                                var localPointB = this.m_proxyB.getVertex(this.indexB);
                                var pointA = Transform.mul(xfA, localPointA);
                                var pointB = Transform.mul(xfB, localPointB);
                                var sep = Vec2.dot(pointB, this.m_axis) - Vec2.dot(pointA, this.m_axis);
                                return sep;
                            }

                        case e_faceA:
                            {
                                var normal = Rot.mul(xfA.q, this.m_axis);
                                var pointA = Transform.mul(xfA, this.m_localPoint);
                                if (find) {
                                    var axisB = Rot.mulT(xfB.q, Vec2.neg(normal));
                                    this.indexA = -1;
                                    this.indexB = this.m_proxyB.getSupport(axisB);
                                }
                                var localPointB = this.m_proxyB.getVertex(this.indexB);
                                var pointB = Transform.mul(xfB, localPointB);
                                var sep = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);
                                return sep;
                            }

                        case e_faceB:
                            {
                                var normal = Rot.mul(xfB.q, this.m_axis);
                                var pointB = Transform.mul(xfB, this.m_localPoint);
                                if (find) {
                                    var axisA = Rot.mulT(xfA.q, Vec2.neg(normal));
                                    this.indexB = -1;
                                    this.indexA = this.m_proxyA.getSupport(axisA);
                                }
                                var localPointA = this.m_proxyA.getVertex(this.indexA);
                                var pointA = Transform.mul(xfA, localPointA);
                                var sep = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);
                                return sep;
                            }

                        default:
                            //ASSERT && common.assert(false);
                            if (find) {
                                this.indexA = -1;
                                this.indexB = -1;
                            }
                            return 0;
                    }
                };

                SeparationFunction.prototype.findMinSeparation = function (t) {
                    return this.compute(true, t);
                };

                SeparationFunction.prototype.evaluate = function (t) {
                    return this.compute(false, t);
                };
            }, { "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../common/stats": 26, "../util/Timer": 49, "../util/common": 50, "./Distance": 13 }], 16: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Mat22;

                var common = require("../util/common");

                var Math = require("./Math");

                var Vec2 = require("./Vec2");

                /**
                 * A 2-by-2 matrix. Stored in column-major order.
                 */
                function Mat22(a, b, c, d) {
                    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === "object" && a !== null) {
                        this.ex = Vec2.clone(a);
                        this.ey = Vec2.clone(b);
                    } else if (typeof a === "number") {
                        this.ex = Vec2.neo(a, c);
                        this.ey = Vec2.neo(b, d);
                    } else {
                        this.ex = Vec2.zero();
                        this.ey = Vec2.zero();
                    }
                }

                Mat22.prototype.toString = function () {
                    return JSON.stringify(this);
                };

                Mat22.isValid = function (o) {
                    return o && Vec2.isValid(o.ex) && Vec2.isValid(o.ey);
                };

                Mat22.assert = function (o) {
                    //if (!ASSERT) return;
                    if (!Mat22.isValid(o)) {
                        //DEBUG && common.debug(o);
                        throw new Error("Invalid Mat22!");
                    }
                };

                Mat22.prototype.set = function (a, b, c, d) {
                    if (typeof a === "number" && typeof b === "number" && typeof c === "number" && typeof d === "number") {
                        this.ex.set(a, c);
                        this.ey.set(b, d);
                    } else if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === "object" && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === "object") {
                        this.ex.set(a);
                        this.ey.set(b);
                    } else if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === "object") {
                        //ASSERT && Mat22.assert(a);
                        this.ex.set(a.ex);
                        this.ey.set(a.ey);
                    } else {
                        //ASSERT && common.assert(false);
                    }
                };

                Mat22.prototype.setIdentity = function () {
                    this.ex.x = 1;
                    this.ey.x = 0;
                    this.ex.y = 0;
                    this.ey.y = 1;
                };

                Mat22.prototype.setZero = function () {
                    this.ex.x = 0;
                    this.ey.x = 0;
                    this.ex.y = 0;
                    this.ey.y = 0;
                };

                Mat22.prototype.getInverse = function () {
                    var a = this.ex.x;
                    var b = this.ey.x;
                    var c = this.ex.y;
                    var d = this.ey.y;
                    var det = a * d - b * c;
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var imx = new Mat22();
                    imx.ex.x = det * d;
                    imx.ey.x = -det * b;
                    imx.ex.y = -det * c;
                    imx.ey.y = det * a;
                    return imx;
                };

                /**
                 * Solve A * x = b, where b is a column vector. This is more efficient than
                 * computing the inverse in one-shot cases.
                 */
                Mat22.prototype.solve = function (v) {
                    //ASSERT && Vec2.assert(v);
                    var a = this.ex.x;
                    var b = this.ey.x;
                    var c = this.ex.y;
                    var d = this.ey.y;
                    var det = a * d - b * c;
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var w = Vec2.zero();
                    w.x = det * (d * v.x - b * v.y);
                    w.y = det * (a * v.y - c * v.x);
                    return w;
                };

                /**
                 * Multiply a matrix times a vector. If a rotation matrix is provided, then this
                 * transforms the vector from one frame to another.
                 */
                Mat22.mul = function (mx, v) {
                    if (v && "x" in v && "y" in v) {
                        // Vec2
                        //ASSERT && Vec2.assert(v);
                        var x = mx.ex.x * v.x + mx.ey.x * v.y;
                        var y = mx.ex.y * v.x + mx.ey.y * v.y;
                        return Vec2.neo(x, y);
                    } else if (v && "ex" in v && "ey" in v) {
                        // Mat22
                        //ASSERT && Mat22.assert(v);
                        return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));
                    }
                    //ASSERT && common.assert(false);
                };

                /**
                 * 
                 * Multiply a matrix transpose times a vector. If a rotation matrix is provided,
                 * then this transforms the vector from one frame to another (inverse
                 * transform).
                 */
                Mat22.mulT = function (mx, v) {
                    if (v && "x" in v && "y" in v) {
                        // Vec2
                        //ASSERT && Vec2.assert(v);
                        return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));
                    } else if (v && "ex" in v && "ey" in v) {
                        // Mat22
                        //ASSERT && Mat22.assert(v);
                        var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));
                        var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));
                        return new Mat22(c1, c2);
                    }
                    //ASSERT && common.assert(false);
                };

                Mat22.abs = function (mx) {
                    //ASSERT && Mat22.assert(mx);
                    return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));
                };

                Mat22.add = function (mx1, mx2) {
                    //ASSERT && Mat22.assert(mx1);
                    //ASSERT && Mat22.assert(mx2);
                    return new Mat22(Vec2.add(mx1.ex + mx2.ex), Vec2.add(mx1.ey + mx2.ey));
                };
            }, { "../util/common": 50, "./Math": 18, "./Vec2": 23 }], 17: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Mat33;

                var common = require("../util/common");

                var Math = require("./Math");

                var Vec2 = require("./Vec2");

                var Vec3 = require("./Vec3");

                /**
                 * A 3-by-3 matrix. Stored in column-major order.
                 */
                function Mat33(a, b, c) {
                    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === "object" && a !== null) {
                        this.ex = Vec3.clone(a);
                        this.ey = Vec3.clone(b);
                        this.ez = Vec3.clone(c);
                    } else {
                        this.ex = Vec3();
                        this.ey = Vec3();
                        this.ez = Vec3();
                    }
                }

                Mat33.prototype.toString = function () {
                    return JSON.stringify(this);
                };

                Mat33.isValid = function (o) {
                    return o && Vec3.isValid(o.ex) && Vec3.isValid(o.ey) && Vec3.isValid(o.ez);
                };

                Mat33.assert = function (o) {
                    //if (!ASSERT) return;
                    if (!Mat33.isValid(o)) {
                        //DEBUG && common.debug(o);
                        throw new Error("Invalid Mat33!");
                    }
                };

                /**
                 * Set this matrix to all zeros.
                 */
                Mat33.prototype.setZero = function () {
                    this.ex.setZero();
                    this.ey.setZero();
                    this.ez.setZero();
                    return this;
                };

                /**
                 * Solve A * x = b, where b is a column vector. This is more efficient than
                 * computing the inverse in one-shot cases.
                 * 
                 * @param {Vec3} v
                 * @returns {Vec3}
                 */
                Mat33.prototype.solve33 = function (v) {
                    var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var r = new Vec3();
                    r.x = det * Vec3.dot(v, Vec3.cross(this.ey, this.ez));
                    r.y = det * Vec3.dot(this.ex, Vec3.cross(v, this.ez));
                    r.z = det * Vec3.dot(this.ex, Vec3.cross(this.ey, v));
                    return r;
                };

                /**
                 * Solve A * x = b, where b is a column vector. This is more efficient than
                 * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix
                 * equation.
                 * 
                 * @param {Vec2} v
                 * 
                 * @returns {Vec2}
                 */
                Mat33.prototype.solve22 = function (v) {
                    var a11 = this.ex.x;
                    var a12 = this.ey.x;
                    var a21 = this.ex.y;
                    var a22 = this.ey.y;
                    var det = a11 * a22 - a12 * a21;
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var r = Vec2.zero();
                    r.x = det * (a22 * v.x - a12 * v.y);
                    r.y = det * (a11 * v.y - a21 * v.x);
                    return r;
                };

                /**
                 * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if
                 * singular.
                 * 
                 * @param {Mat33} M
                 */
                Mat33.prototype.getInverse22 = function (M) {
                    var a = this.ex.x;
                    var b = this.ey.x;
                    var c = this.ex.y;
                    var d = this.ey.y;
                    var det = a * d - b * c;
                    if (det != 0) {
                        det = 1 / det;
                    }
                    M.ex.x = det * d;
                    M.ey.x = -det * b;
                    M.ex.z = 0;
                    M.ex.y = -det * c;
                    M.ey.y = det * a;
                    M.ey.z = 0;
                    M.ez.x = 0;
                    M.ez.y = 0;
                    M.ez.z = 0;
                };

                /**
                 * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix
                 * if singular.
                 * 
                 * @param {Mat33} M
                 */
                Mat33.prototype.getSymInverse33 = function (M) {
                    var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));
                    if (det != 0) {
                        det = 1 / det;
                    }
                    var a11 = this.ex.x;
                    var a12 = this.ey.x;
                    var a13 = this.ez.x;
                    var a22 = this.ey.y;
                    var a23 = this.ez.y;
                    var a33 = this.ez.z;
                    M.ex.x = det * (a22 * a33 - a23 * a23);
                    M.ex.y = det * (a13 * a23 - a12 * a33);
                    M.ex.z = det * (a12 * a23 - a13 * a22);
                    M.ey.x = M.ex.y;
                    M.ey.y = det * (a11 * a33 - a13 * a13);
                    M.ey.z = det * (a13 * a12 - a11 * a23);
                    M.ez.x = M.ex.z;
                    M.ez.y = M.ey.z;
                    M.ez.z = det * (a11 * a22 - a12 * a12);
                };

                /**
                 * Multiply a matrix times a vector.
                 * 
                 * @param {Mat33} a
                 * @param {Vec3|Vec2} b
                 * 
                 * @returns {Vec3|Vec2}
                 */
                Mat33.mul = function (a, b) {
                    //ASSERT && Mat33.assert(a);
                    if (b && "z" in b && "y" in b && "x" in b) {
                        //ASSERT && Vec3.assert(b);
                        var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;
                        var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;
                        var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;
                        return new Vec3(x, y, z);
                    } else if (b && "y" in b && "x" in b) {
                        //ASSERT && Vec2.assert(b);
                        var x = a.ex.x * b.x + a.ey.x * b.y;
                        var y = a.ex.y * b.x + a.ey.y * b.y;
                        return Vec2.neo(x, y);
                    }
                    //ASSERT && common.assert(false);
                };

                Mat33.add = function (a, b) {
                    //ASSERT && Mat33.assert(a);
                    //ASSERT && Mat33.assert(b);
                    return new Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
                };
            }, { "../util/common": 50, "./Math": 18, "./Vec2": 23, "./Vec3": 24 }], 18: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var common = require("../util/common");

                var create = require("../util/create");

                var native = Math;

                var math = module.exports = create(native);

                math.EPSILON = 1e-9;

                // TODO
                /**
                 * This function is used to ensure that a floating point number is not a NaN or
                 * infinity.
                 */
                math.isFinite = function (x) {
                    return typeof x === "number" && isFinite(x) && !isNaN(x);
                };

                math.assert = function (x) {
                    //if (!ASSERT) return;
                    if (!math.isFinite(x)) {
                        //DEBUG && common.debug(x);
                        throw new Error("Invalid Number!");
                    }
                };

                /**
                 * TODO: This is a approximate yet fast inverse square-root.
                 */
                math.invSqrt = function (x) {
                    // TODO
                    return 1 / native.sqrt(x);
                };

                /**
                 * Next Largest Power of 2 Given a binary integer value x, the next largest
                 * power of 2 can be computed by a SWAR algorithm that recursively "folds" the
                 * upper bits into the lower bits. This process yields a bit vector with the
                 * same most significant 1 as x, but all 1's below it. Adding 1 to that value
                 * yields the next largest power of 2. For a 32-bit value:
                 */
                math.nextPowerOfTwo = function (x) {
                    // TODO
                    x |= x >> 1;
                    x |= x >> 2;
                    x |= x >> 4;
                    x |= x >> 8;
                    x |= x >> 16;
                    return x + 1;
                };

                math.isPowerOfTwo = function (x) {
                    return x > 0 && (x & x - 1) == 0;
                };

                math.mod = function (num, min, max) {
                    if (typeof min === "undefined") {
                        max = 1, min = 0;
                    } else if (typeof max === "undefined") {
                        max = min, min = 0;
                    }
                    if (max > min) {
                        num = (num - min) % (max - min);
                        return num + (num < 0 ? max : min);
                    } else {
                        num = (num - max) % (min - max);
                        return num + (num <= 0 ? min : max);
                    }
                };

                math.clamp = function (num, min, max) {
                    if (num < min) {
                        return min;
                    } else if (num > max) {
                        return max;
                    } else {
                        return num;
                    }
                };

                math.random = function (min, max) {
                    if (typeof min === "undefined") {
                        max = 1;
                        min = 0;
                    } else if (typeof max === "undefined") {
                        max = min;
                        min = 0;
                    }
                    return min == max ? min : native.random() * (max - min) + min;
                };
            }, { "../util/common": 50, "../util/create": 51 }], 19: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Position;

                var Vec2 = require("./Vec2");

                var Rot = require("./Rot");

                /**
                 * @prop {Vec2} c location
                 * @prop {float} a angle
                 */
                function Position() {
                    this.c = Vec2.zero();
                    this.a = 0;
                }

                Position.prototype.getTransform = function (xf, p) {
                    xf.q.set(this.a);
                    xf.p.set(Vec2.sub(this.c, Rot.mul(xf.q, p)));
                    return xf;
                };
            }, { "./Rot": 20, "./Vec2": 23 }], 20: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Rot;

                var common = require("../util/common");

                var Vec2 = require("./Vec2");

                var Math = require("./Math");

                // TODO merge with Transform
                /**
                 * Initialize from an angle in radians.
                 */
                function Rot(angle) {
                    if (!(this instanceof Rot)) {
                        return new Rot(angle);
                    }
                    if (typeof angle === "number") {
                        this.setAngle(angle);
                    } else if ((typeof angle === 'undefined' ? 'undefined' : _typeof(angle)) === "object") {
                        this.set(angle);
                    } else {
                        this.setIdentity();
                    }
                }

                Rot.neo = function (angle) {
                    var obj = Object.create(Rot.prototype);
                    obj.setAngle(angle);
                    return obj;
                };

                Rot.clone = function (rot) {
                    //ASSERT && Rot.assert(rot);
                    var obj = Object.create(Rot.prototype);
                    ojb.s = rot.s;
                    ojb.c = rot.c;
                    return ojb;
                };

                Rot.identity = function (rot) {
                    //ASSERT && Rot.assert(rot);
                    var obj = Object.create(Rot.prototype);
                    obj.s = 0;
                    obj.c = 1;
                    return obj;
                };

                Rot.isValid = function (o) {
                    return o && Math.isFinite(o.s) && Math.isFinite(o.c);
                };

                Rot.assert = function (o) {
                    //if (!ASSERT) return;
                    if (!Rot.isValid(o)) {
                        //DEBUG && common.debug(o);
                        throw new Error("Invalid Rot!");
                    }
                };

                /**
                 * Set to the identity rotation.
                 */
                Rot.prototype.setIdentity = function () {
                    this.s = 0;
                    this.c = 1;
                };

                Rot.prototype.set = function (angle) {
                    if ((typeof angle === 'undefined' ? 'undefined' : _typeof(angle)) === "object") {
                        //ASSERT && Rot.assert(angle);
                        this.s = angle.s;
                        this.c = angle.c;
                    } else {
                        //ASSERT && Math.assert(angle);
                        // TODO_ERIN optimize
                        this.s = Math.sin(angle);
                        this.c = Math.cos(angle);
                    }
                };

                /**
                 * Set using an angle in radians.
                 */
                Rot.prototype.setAngle = function (angle) {
                    //ASSERT && Math.assert(angle);
                    // TODO_ERIN optimize
                    this.s = Math.sin(angle);
                    this.c = Math.cos(angle);
                };

                /**
                 * Get the angle in radians.
                 */
                Rot.prototype.getAngle = function () {
                    return Math.atan2(this.s, this.c);
                };

                /**
                 * Get the x-axis.
                 */
                Rot.prototype.getXAxis = function () {
                    return Vec2.neo(this.c, this.s);
                };

                /**
                 * Get the u-axis.
                 */
                Rot.prototype.getYAxis = function () {
                    return Vec2.neo(-this.s, this.c);
                };

                /**
                 * Multiply two rotations: q * r
                 * 
                 * @returns Rot
                 * 
                 * Rotate a vector
                 * 
                 * @returns Vec2
                 */
                Rot.mul = function (rot, m) {
                    //ASSERT && Rot.assert(rot);
                    if ("c" in m && "s" in m) {
                        //ASSERT && Rot.assert(m);
                        // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
                        // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]
                        // s = qs * rc + qc * rs
                        // c = qc * rc - qs * rs
                        var qr = Rot.identity();
                        qr.s = rot.s * m.c + rot.c * m.s;
                        qr.c = rot.c * m.c - rot.s * m.s;
                        return qr;
                    } else if ("x" in m && "y" in m) {
                        //ASSERT && Vec2.assert(m);
                        return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
                    }
                };

                Rot.mulSub = function (rot, v, w) {
                    var x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);
                    var y = rot.s * (v.x - w.y) + rot.c * (v.y - w.y);
                    return Vec2.neo(x, y);
                };

                /**
                 * Transpose multiply two rotations: qT * r
                 * 
                 * @returns Rot
                 * 
                 * Inverse rotate a vector
                 * 
                 * @returns Vec2
                 */
                Rot.mulT = function (rot, m) {
                    if ("c" in m && "s" in m) {
                        //ASSERT && Rot.assert(m);
                        // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
                        // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
                        // s = qc * rs - qs * rc
                        // c = qc * rc + qs * rs
                        var qr = Rot.identity();
                        qr.s = rot.c * m.s - rot.s * m.c;
                        qr.c = rot.c * m.c + rot.s * m.s;
                        return qr;
                    } else if ("x" in m && "y" in m) {
                        //ASSERT && Vec2.assert(m);
                        return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
                    }
                };
            }, { "../util/common": 50, "./Math": 18, "./Vec2": 23 }], 21: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Sweep;

                var common = require("../util/common");

                var Math = require("./Math");

                var Vec2 = require("./Vec2");

                var Rot = require("./Rot");

                var Transform = require("./Transform");

                /**
                 * This describes the motion of a body/shape for TOI computation. Shapes are
                 * defined with respect to the body origin, which may not coincide with the
                 * center of mass. However, to support dynamics we must interpolate the center
                 * of mass position.
                 * 
                 * @prop {Vec2} localCenter Local center of mass position
                 * @prop {Vec2} c World center position
                 * @prop {float} a World angle
                 * @prop {float} alpha0 Fraction of the current time step in the range [0,1], c0
                 *       and a0 are c and a at alpha0.
                 */
                function Sweep(c, a) {
                    //ASSERT && common.assert(typeof c === "undefined");
                    //ASSERT && common.assert(typeof a === "undefined");
                    this.localCenter = Vec2.zero();
                    this.c = Vec2.zero();
                    this.a = 0;
                    this.alpha0 = 0;
                    this.c0 = Vec2.zero();
                    this.a0 = 0;
                }

                Sweep.prototype.setTransform = function (xf) {
                    var c = Transform.mul(xf, this.localCenter);
                    this.c.set(c);
                    this.c0.set(c);
                    this.a = xf.q.getAngle();
                    this.a0 = xf.q.getAngle();
                };

                Sweep.prototype.setLocalCenter = function (localCenter, xf) {
                    this.localCenter.set(localCenter);
                    var c = Transform.mul(xf, this.localCenter);
                    this.c.set(c);
                    this.c0.set(c);
                };

                /**
                 * Get the interpolated transform at a specific time.
                 * 
                 * @param xf
                 * @param beta A factor in [0,1], where 0 indicates alpha0
                 */
                Sweep.prototype.getTransform = function (xf, beta) {
                    beta = typeof beta === "undefined" ? 0 : beta;
                    xf.q.setAngle((1 - beta) * this.a0 + beta * this.a);
                    xf.p.wSet(1 - beta, this.c0, beta, this.c);
                    // shift to origin
                    xf.p.sub(Rot.mul(xf.q, this.localCenter));
                };

                /**
                 * Advance the sweep forward, yielding a new initial state.
                 * 
                 * @param {float} alpha The new initial time
                 */
                Sweep.prototype.advance = function (alpha) {
                    //ASSERT && common.assert(this.alpha0 < 1);
                    var beta = (alpha - this.alpha0) / (1 - this.alpha0);
                    this.c0.wSet(beta, this.c, 1 - beta, this.c0);
                    this.a0 = beta * this.a + (1 - beta) * this.a0;
                    this.alpha0 = alpha;
                };

                Sweep.prototype.forward = function () {
                    this.a0 = this.a;
                    this.c0.set(this.c);
                };

                /**
                 * normalize the angles in radians to be between -pi and pi.
                 */
                Sweep.prototype.normalize = function () {
                    var a0 = Math.mod(this.a0, -Math.PI, +Math.PI);
                    this.a -= this.a0 - a0;
                    this.a0 = a0;
                };

                Sweep.prototype.clone = function () {
                    var clone = new Sweep();
                    clone.localCenter.set(this.localCenter);
                    clone.alpha0 = this.alpha0;
                    clone.a0 = this.a0;
                    clone.a = this.a;
                    clone.c0.set(this.c0);
                    clone.c.set(this.c);
                    return clone;
                };

                Sweep.prototype.set = function (that) {
                    this.localCenter.set(that.localCenter);
                    this.alpha0 = that.alpha0;
                    this.a0 = that.a0;
                    this.a = that.a;
                    this.c0.set(that.c0);
                    this.c.set(that.c);
                };
            }, { "../util/common": 50, "./Math": 18, "./Rot": 20, "./Transform": 22, "./Vec2": 23 }], 22: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Transform;

                var common = require("../util/common");

                var Vec2 = require("./Vec2");

                var Rot = require("./Rot");

                // TODO merge with Rot
                /**
                 * A transform contains translation and rotation. It is used to represent the
                 * position and orientation of rigid frames. Initialize using a position vector
                 * and a rotation.
                 * 
                 * @prop {Vec2} position
                 * @prop {Rot} rotation
                 */
                function Transform(position, rotation) {
                    if (!(this instanceof Transform)) {
                        return new Transform(position, rotation);
                    }
                    this.p = Vec2.zero();
                    this.q = Rot.identity();
                    if (typeof position !== "undefined") {
                        this.p.set(position);
                    }
                    if (typeof rotation !== "undefined") {
                        this.q.set(rotation);
                    }
                }

                Transform.clone = function (xf) {
                    var obj = Object.create(Transform.prototype);
                    obj.p = Vec2.clone(xf.p);
                    obj.q = Rot.clone(xf.q);
                    return obj;
                };

                Transform.neo = function (position, rotation) {
                    var obj = Object.create(Transform.prototype);
                    obj.p = Vec2.clone(position);
                    obj.q = Rot.clone(rotation);
                    return obj;
                };

                Transform.identity = function () {
                    var obj = Object.create(Transform.prototype);
                    obj.p = Vec2.zero();
                    obj.q = Rot.identity();
                    return obj;
                };

                /**
                 * Set this to the identity transform.
                 */
                Transform.prototype.setIdentity = function () {
                    this.p.setZero();
                    this.q.setIdentity();
                };

                /**
                 * Set this based on the position and angle.
                 */
                Transform.prototype.set = function (a, b) {
                    if (Transform.isValid(a)) {
                        this.p.set(a.p);
                        this.q.set(a.q);
                    } else {
                        this.p.set(a);
                        this.q.set(b);
                    }
                };

                Transform.isValid = function (o) {
                    return o && Vec2.isValid(o.p) && Rot.isValid(o.q);
                };

                Transform.assert = function (o) {
                    //if (!ASSERT) return;
                    if (!Transform.isValid(o)) {
                        //DEBUG && common.debug(o);
                        throw new Error("Invalid Transform!");
                    }
                };

                /**
                 * @param {Transform} a
                 * @param {Vec2} b
                 * @returns {Vec2}
                 * 
                 * @param {Transform} a
                 * @param {Transform} b
                 * @returns {Transform}
                 */
                Transform.mul = function (a, b) {
                    //ASSERT && Transform.assert(a);
                    if (Array.isArray(b)) {
                        var arr = [];
                        for (var i = 0; i < b.length; i++) {
                            arr[i] = Transform.mul(a, b[i]);
                        }
                        return arr;
                    } else if ("x" in b && "y" in b) {
                        //ASSERT && Vec2.assert(b);
                        var x = a.q.c * b.x - a.q.s * b.y + a.p.x;
                        var y = a.q.s * b.x + a.q.c * b.y + a.p.y;
                        return Vec2.neo(x, y);
                    } else if ("p" in b && "q" in b) {
                        //ASSERT && Transform.assert(b);
                        // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
                        // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
                        var xf = Transform.identity();
                        xf.q = Rot.mul(a.q, b.q);
                        xf.p = Vec2.add(Rot.mul(a.q, b.p), a.p);
                        return xf;
                    }
                };

                /**
                 * @param {Transform} a
                 * @param {Vec2} b
                 * @returns {Vec2}
                 * 
                 * @param {Transform} a
                 * @param {Transform} b
                 * @returns {Transform}
                 */
                Transform.mulT = function (a, b) {
                    //ASSERT && Transform.assert(a);
                    if ("x" in b && "y" in b) {
                        //ASSERT && Vec2.assert(b);
                        var px = b.x - a.p.x;
                        var py = b.y - a.p.y;
                        var x = a.q.c * px + a.q.s * py;
                        var y = -a.q.s * px + a.q.c * py;
                        return Vec2.neo(x, y);
                    } else if ("p" in b && "q" in b) {
                        //ASSERT && Transform.assert(b);
                        // v2 = A.q' * (B.q * v1 + B.p - A.p)
                        // = A.q' * B.q * v1 + A.q' * (B.p - A.p)
                        var xf = Transform.identity();
                        xf.q.set(Rot.mulT(a.q, b.q));
                        xf.p.set(Rot.mulT(a.q, Vec2.sub(b.p, a.p)));
                        return xf;
                    }
                };
            }, { "../util/common": 50, "./Rot": 20, "./Vec2": 23 }], 23: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Vec2;

                var common = require("../util/common");

                var Math = require("./Math");

                function Vec2(x, y) {
                    if (!(this instanceof Vec2)) {
                        return new Vec2(x, y);
                    }
                    if (typeof x === "undefined") {
                        this.x = 0, this.y = 0;
                    } else if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === "object") {
                        this.x = x.x, this.y = x.y;
                    } else {
                        this.x = x, this.y = y;
                    }
                    //ASSERT && Vec2.assert(this);
                }

                Vec2.zero = function () {
                    var obj = Object.create(Vec2.prototype);
                    obj.x = 0;
                    obj.y = 0;
                    return obj;
                };

                Vec2.neo = function (x, y) {
                    var obj = Object.create(Vec2.prototype);
                    obj.x = x;
                    obj.y = y;
                    return obj;
                };

                Vec2.clone = function (v, depricated) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && common.assert(!depricated);
                    return Vec2.neo(v.x, v.y);
                };

                Vec2.prototype.toString = function () {
                    return JSON.stringify(this);
                };

                /**
                 * Does this vector contain finite coordinates?
                 */
                Vec2.isValid = function (v) {
                    return v && Math.isFinite(v.x) && Math.isFinite(v.y);
                };

                Vec2.assert = function (o) {
                    //if (!ASSERT) return;
                    if (!Vec2.isValid(o)) {
                        //DEBUG && common.debug(o);
                        throw new Error("Invalid Vec2!");
                    }
                };

                Vec2.prototype.clone = function (depricated) {
                    return Vec2.clone(this, depricated);
                };

                /**
                 * Set this vector to all zeros.
                 * 
                 * @returns this
                 */
                Vec2.prototype.setZero = function () {
                    this.x = 0;
                    this.y = 0;
                    return this;
                };

                /**
                 * Set this vector to some specified coordinates.
                 * 
                 * @returns this
                 */
                Vec2.prototype.set = function (x, y) {
                    if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === "object") {
                        //ASSERT && Vec2.assert(x);
                        this.x = x.x;
                        this.y = x.y;
                    } else {
                        //ASSERT && Math.assert(x);
                        //ASSERT && Math.assert(y);
                        this.x = x;
                        this.y = y;
                    }
                    return this;
                };

                Vec2.prototype.wSet = function (a, v, b, w) {
                    //ASSERT && Math.assert(a);
                    //ASSERT && Vec2.assert(v);
                    var x = a * v.x;
                    var y = a * v.y;
                    if (typeof b !== "undefined" || typeof w !== "undefined") {
                        //ASSERT && Math.assert(b);
                        //ASSERT && Vec2.assert(w);
                        x += b * w.x;
                        y += b * w.y;
                    }
                    // `this` may be `w`
                    this.x = x;
                    this.y = y;
                    return this;
                };

                /**
                 * Add a vector to this vector.
                 * 
                 * @returns this
                 */
                Vec2.prototype.add = function (w) {
                    //ASSERT && Vec2.assert(w);
                    this.x += w.x;
                    this.y += w.y;
                    return this;
                };

                Vec2.prototype.wAdd = function (a, v, b, w) {
                    //ASSERT && Math.assert(a);
                    //ASSERT && Vec2.assert(v);
                    var x = a * v.x;
                    var y = a * v.y;
                    if (typeof b !== "undefined" || typeof w !== "undefined") {
                        //ASSERT && Math.assert(b);
                        //ASSERT && Vec2.assert(w);
                        x += b * w.x;
                        y += b * w.y;
                    }
                    // `this` may be `w`
                    this.x += x;
                    this.y += y;
                    return this;
                };

                Vec2.prototype.wSub = function (a, v, b, w) {
                    //ASSERT && Math.assert(a);
                    //ASSERT && Vec2.assert(v);
                    var x = a * v.x;
                    var y = a * v.y;
                    if (typeof b !== "undefined" || typeof w !== "undefined") {
                        //ASSERT && Math.assert(b);
                        //ASSERT && Vec2.assert(w);
                        x += b * w.x;
                        y += b * w.y;
                    }
                    // `this` may be `w`
                    this.x -= x;
                    this.y -= y;
                    return this;
                };

                /**
                 * Subtract a vector from this vector
                 * 
                 * @returns this
                 */
                Vec2.prototype.sub = function (w) {
                    //ASSERT && Vec2.assert(w);
                    this.x -= w.x;
                    this.y -= w.y;
                    return this;
                };

                /**
                 * Multiply this vector by a scalar.
                 * 
                 * @returns this
                 */
                Vec2.prototype.mul = function (m) {
                    //ASSERT && Math.assert(m);
                    this.x *= m;
                    this.y *= m;
                    return this;
                };

                /**
                 * Get the length of this vector (the norm).
                 * 
                 * For performance, use this instead of lengthSquared (if possible).
                 */
                Vec2.prototype.length = function () {
                    return Vec2.lengthOf(this);
                };

                /**
                 * Get the length squared.
                 */
                Vec2.prototype.lengthSquared = function () {
                    return Vec2.lengthSquared(this);
                };

                /**
                 * Convert this vector into a unit vector.
                 * 
                 * @returns old length
                 */
                Vec2.prototype.normalize = function () {
                    var length = this.length();
                    if (length < Math.EPSILON) {
                        return 0;
                    }
                    var invLength = 1 / length;
                    this.x *= invLength;
                    this.y *= invLength;
                    return length;
                };

                /**
                 * Get the length of this vector (the norm).
                 *
                 * For performance, use this instead of lengthSquared (if possible).
                 */
                Vec2.lengthOf = function (v) {
                    //ASSERT && Vec2.assert(v);
                    return Math.sqrt(v.x * v.x + v.y * v.y);
                };

                /**
                 * Get the length squared.
                 */
                Vec2.lengthSquared = function (v) {
                    //ASSERT && Vec2.assert(v);
                    return v.x * v.x + v.y * v.y;
                };

                Vec2.distance = function (v, w) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && Vec2.assert(w);
                    var dx = v.x - w.x,
                        dy = v.y - w.y;
                    return Math.sqrt(dx * dx + dy * dy);
                };

                Vec2.distanceSquared = function (v, w) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && Vec2.assert(w);
                    var dx = v.x - w.x,
                        dy = v.y - w.y;
                    return dx * dx + dy * dy;
                };

                Vec2.areEqual = function (v, w) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && Vec2.assert(w);
                    return v == w || (typeof w === 'undefined' ? 'undefined' : _typeof(w)) === "object" && w !== null && v.x == w.x && v.y == w.y;
                };

                /**
                 * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
                 */
                Vec2.skew = function (v) {
                    //ASSERT && Vec2.assert(v);
                    return Vec2.neo(-v.y, v.x);
                };

                /**
                 * Perform the dot product on two vectors.
                 */
                Vec2.dot = function (v, w) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && Vec2.assert(w);
                    return v.x * w.x + v.y * w.y;
                };

                /**
                 * Perform the cross product on two vectors. In 2D this produces a scalar.
                 * 
                 * Perform the cross product on a vector and a scalar. In 2D this produces a
                 * vector.
                 */
                Vec2.cross = function (v, w) {
                    if (typeof w === "number") {
                        //ASSERT && Vec2.assert(v);
                        //ASSERT && Math.assert(w);
                        return Vec2.neo(w * v.y, -w * v.x);
                    } else if (typeof v === "number") {
                        //ASSERT && Math.assert(v);
                        //ASSERT && Vec2.assert(w);
                        return Vec2.neo(-v * w.y, v * w.x);
                    } else {
                        //ASSERT && Vec2.assert(v);
                        //ASSERT && Vec2.assert(w);
                        return v.x * w.y - v.y * w.x;
                    }
                };

                Vec2.addCross = function (a, v, w) {
                    if (typeof w === "number") {
                        //ASSERT && Vec2.assert(v);
                        //ASSERT && Math.assert(w);
                        return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);
                    } else if (typeof v === "number") {
                        //ASSERT && Math.assert(v);
                        //ASSERT && Vec2.assert(w);
                        return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);
                    }
                    //ASSERT && common.assert(false);
                };

                Vec2.add = function (v, w) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && Vec2.assert(w);
                    return Vec2.neo(v.x + w.x, v.y + w.y);
                };

                Vec2.wAdd = function (a, v, b, w) {
                    var r = Vec2.zero();
                    r.wAdd(a, v, b, w);
                    return r;
                };

                Vec2.sub = function (v, w) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && Vec2.assert(w);
                    return Vec2.neo(v.x - w.x, v.y - w.y);
                };

                Vec2.mul = function (a, b) {
                    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === "object") {
                        //ASSERT && Vec2.assert(a);
                        //ASSERT && Math.assert(b);
                        return Vec2.neo(a.x * b, a.y * b);
                    } else if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) === "object") {
                        //ASSERT && Math.assert(a);
                        //ASSERT && Vec2.assert(b);
                        return Vec2.neo(a * b.x, a * b.y);
                    }
                };

                Vec2.prototype.neg = function () {
                    this.x = -this.x;
                    this.y = -this.y;
                    return this;
                };

                Vec2.neg = function (v) {
                    //ASSERT && Vec2.assert(v);
                    return Vec2.neo(-v.x, -v.y);
                };

                Vec2.abs = function (v) {
                    //ASSERT && Vec2.assert(v);
                    return Vec2.neo(Math.abs(v.x), Math.abs(v.y));
                };

                Vec2.mid = function (v, w) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && Vec2.assert(w);
                    return Vec2.neo((v.x + w.x) * .5, (v.y + w.y) * .5);
                };

                Vec2.upper = function (v, w) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && Vec2.assert(w);
                    return Vec2.neo(Math.max(v.x, w.x), Math.max(v.y, w.y));
                };

                Vec2.lower = function (v, w) {
                    //ASSERT && Vec2.assert(v);
                    //ASSERT && Vec2.assert(w);
                    return Vec2.neo(Math.min(v.x, w.x), Math.min(v.y, w.y));
                };

                Vec2.prototype.clamp = function (max) {
                    var lengthSqr = this.x * this.x + this.y * this.y;
                    if (lengthSqr > max * max) {
                        var invLength = Math.invSqrt(lengthSqr);
                        this.x *= invLength * max;
                        this.y *= invLength * max;
                    }
                    return this;
                };

                Vec2.clamp = function (v, max) {
                    v = Vec2.neo(v.x, v.y);
                    v.clamp(max);
                    return v;
                };
            }, { "../util/common": 50, "./Math": 18 }], 24: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Vec3;

                var common = require("../util/common");

                var Math = require("./Math");

                function Vec3(x, y, z) {
                    if (!(this instanceof Vec3)) {
                        return new Vec3(x, y, z);
                    }
                    if (typeof x === "undefined") {
                        this.x = 0, this.y = 0, this.z = 0;
                    } else if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === "object") {
                        this.x = x.x, this.y = x.y, this.z = x.z;
                    } else {
                        this.x = x, this.y = y, this.z = z;
                    }
                    //ASSERT && Vec3.assert(this);
                }

                Vec3.prototype.toString = function () {
                    return JSON.stringify(this);
                };

                /**
                 * Does this vector contain finite coordinates?
                 */
                Vec3.isValid = function (v) {
                    return v && Math.isFinite(v.x) && Math.isFinite(v.y) && Math.isFinite(v.z);
                };

                Vec3.assert = function (o) {
                    //if (!ASSERT) return;
                    if (!Vec3.isValid(o)) {
                        //DEBUG && common.debug(o);
                        throw new Error("Invalid Vec3!");
                    }
                };

                Vec3.prototype.setZero = function () {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                    return this;
                };

                Vec3.prototype.set = function (x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                };

                Vec3.prototype.add = function (w) {
                    this.x += w.x;
                    this.y += w.y;
                    this.z += w.z;
                    return this;
                };

                Vec3.prototype.sub = function (w) {
                    this.x -= w.x;
                    this.y -= w.y;
                    this.z -= w.z;
                    return this;
                };

                Vec3.prototype.mul = function (m) {
                    this.x *= m;
                    this.y *= m;
                    this.z *= m;
                    return this;
                };

                Vec3.areEqual = function (v, w) {
                    return v == w || (typeof w === 'undefined' ? 'undefined' : _typeof(w)) === "object" && w !== null && v.x == w.x && v.y == w.y && v.z == w.z;
                };

                // Perform the dot product on two vectors.
                Vec3.dot = function (v, w) {
                    return v.x * w.x + v.y * w.y + v.z * w.z;
                };

                // Perform the cross product on two vectors. In 2D this produces a scalar.
                Vec3.cross = function (v, w) {
                    return new Vec3(v.y * w.z - v.z * w.y, v.z * w.x - v.x * w.z, v.x * w.y - v.y * w.x);
                };

                Vec3.add = function (v, w) {
                    return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);
                };

                Vec3.sub = function (v, w) {
                    return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);
                };

                Vec3.mul = function (v, m) {
                    return new Vec3(m * v.x, m * v.y, m * v.z);
                };

                Vec3.prototype.neg = function (m) {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    return this;
                };

                Vec3.neg = function (v) {
                    return new Vec3(-v.x, -v.y, -v.z);
                };
            }, { "../util/common": 50, "./Math": 18 }], 25: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Velocity;

                var Vec2 = require("./Vec2");

                /**
                 * @prop {Vec2} v linear
                 * @prop {float} w angular
                 */
                function Velocity() {
                    this.v = Vec2.zero();
                    this.w = 0;
                }
            }, { "./Vec2": 23 }], 26: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                exports.toString = function (newline) {
                    newline = typeof newline === "string" ? newline : "\n";
                    var string = "";
                    for (var name in this) {
                        if (typeof this[name] !== "function" && _typeof(this[name]) !== "object") {
                            string += name + ": " + this[name] + newline;
                        }
                    }
                    return string;
                };
            }, {}], 27: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = DistanceJoint;

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                DistanceJoint.TYPE = "distance-joint";

                DistanceJoint._super = Joint;

                DistanceJoint.prototype = create(DistanceJoint._super.prototype);

                /**
                 * @typedef {Object} DistanceJointDef
                 *
                 * Distance joint definition. This requires defining an anchor point on both
                 * bodies and the non-zero length of the distance joint. The definition uses
                 * local anchor points so that the initial configuration can violate the
                 * constraint slightly. This helps when saving and loading a game. Warning: Do
                 * not use a zero or short length.
                 * 
                 * @prop {float} frequencyHz The mass-spring-damper frequency in Hertz. A value
                 *       of 0 disables softness.
                 * @prop {float} dampingRatio The damping ratio. 0 = no damping, 1 = critical
                 *       damping.
                 */
                var DistanceJointDef = {
                    frequencyHz: 0,
                    dampingRatio: 0
                };

                /**
                 * A distance joint constrains two points on two bodies to remain at a fixed
                 * distance from each other. You can view this as a massless, rigid rod.
                 * 
                 * @param {Vec2} def.localAnchorA The local anchor point relative to bodyA's origin.
                 * @param {Vec2} def.localAnchorB The local anchor point relative to bodyB's origin.
                 */
                function DistanceJoint(def, bodyA, anchorA, bodyB, anchorB) {
                    if (!(this instanceof DistanceJoint)) {
                        return new DistanceJoint(def, bodyA, anchorA, bodyB, anchorB);
                    }
                    def = options(def, DistanceJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = DistanceJoint.TYPE;
                    // Solver shared
                    this.m_localAnchorA = def.localAnchorA || bodyA.getLocalPoint(anchorA);
                    this.m_localAnchorB = def.localAnchorB || bodyB.getLocalPoint(anchorB);
                    this.m_length = Vec2.distance(anchorB, anchorA);
                    this.m_frequencyHz = def.frequencyHz;
                    this.m_dampingRatio = def.dampingRatio;
                    this.m_impulse = 0;
                    this.m_gamma = 0;
                    this.m_bias = 0;
                    // Solver temp
                    this.m_u;
                    // Vec2
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    this.m_invMassB;
                    this.m_invIA;
                    this.m_invIB;
                    this.m_mass;
                }

                /**
                 * The local anchor point relative to bodyA's origin.
                 */
                DistanceJoint.prototype.getLocalAnchorA = function () {
                    return this.m_localAnchorA;
                };

                /**
                 * The local anchor point relative to bodyB's origin.
                 */
                DistanceJoint.prototype.getLocalAnchorB = function () {
                    return this.m_localAnchorB;
                };

                /**
                 * Set/get the natural length. Manipulating the length can lead to non-physical
                 * behavior when the frequency is zero.
                 */
                DistanceJoint.prototype.setLength = function (length) {
                    this.m_length = length;
                };

                DistanceJoint.prototype.getLength = function () {
                    return this.m_length;
                };

                DistanceJoint.prototype.setFrequency = function (hz) {
                    this.m_frequencyHz = hz;
                };

                DistanceJoint.prototype.getFrequency = function () {
                    return this.m_frequencyHz;
                };

                DistanceJoint.prototype.setDampingRatio = function (ratio) {
                    this.m_dampingRatio = ratio;
                };

                DistanceJoint.prototype.getDampingRatio = function () {
                    return this.m_dampingRatio;
                };

                DistanceJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };

                DistanceJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                DistanceJoint.prototype.getReactionForce = function (inv_dt) {
                    var F = Vec2.mul(inv_dt * this.m_impulse, this.m_u);
                    return F;
                };

                DistanceJoint.prototype.getReactionTorque = function (inv_dt) {
                    return 0;
                };

                DistanceJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    this.m_rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));
                    // Handle singularity.
                    var length = this.m_u.length();
                    if (length > Settings.linearSlop) {
                        this.m_u.mul(1 / length);
                    } else {
                        this.m_u.set(0, 0);
                    }
                    var crAu = Vec2.cross(this.m_rA, this.m_u);
                    var crBu = Vec2.cross(this.m_rB, this.m_u);
                    var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;
                    // Compute the effective mass matrix.
                    this.m_mass = invMass != 0 ? 1 / invMass : 0;
                    if (this.m_frequencyHz > 0) {
                        var C = length - this.m_length;
                        // Frequency
                        var omega = 2 * Math.PI * this.m_frequencyHz;
                        // Damping coefficient
                        var d = 2 * this.m_mass * this.m_dampingRatio * omega;
                        // Spring stiffness
                        var k = this.m_mass * omega * omega;
                        // magic formulas
                        var h = step.dt;
                        this.m_gamma = h * (d + h * k);
                        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
                        this.m_bias = C * h * k * this.m_gamma;
                        invMass += this.m_gamma;
                        this.m_mass = invMass != 0 ? 1 / invMass : 0;
                    } else {
                        this.m_gamma = 0;
                        this.m_bias = 0;
                    }
                    if (step.warmStarting) {
                        // Scale the impulse to support a variable time step.
                        this.m_impulse *= step.dtRatio;
                        var P = Vec2.mul(this.m_impulse, this.m_u);
                        vA.wSub(this.m_invMassA, P);
                        wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
                        vB.wAdd(this.m_invMassB, P);
                        wB += this.m_invIB * Vec2.cross(this.m_rB, P);
                    } else {
                        this.m_impulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };

                DistanceJoint.prototype.solveVelocityConstraints = function (step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    // Cdot = dot(u, v + cross(w, r))
                    var vpA = Vec2.add(vA, Vec2.cross(wA, this.m_rA));
                    var vpB = Vec2.add(vB, Vec2.cross(wB, this.m_rB));
                    var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);
                    var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
                    this.m_impulse += impulse;
                    var P = Vec2.mul(impulse, this.m_u);
                    vA.wSub(this.m_invMassA, P);
                    wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
                    vB.wAdd(this.m_invMassB, P);
                    wB += this.m_invIB * Vec2.cross(this.m_rB, P);
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };

                DistanceJoint.prototype.solvePositionConstraints = function (step) {
                    if (this.m_frequencyHz > 0) {
                        // There is no position correction for soft distance constraints.
                        return true;
                    }
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
                    var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
                    var u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));
                    var length = u.normalize();
                    var C = length - this.m_length;
                    C = Math.clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);
                    var impulse = -this.m_mass * C;
                    var P = Vec2.mul(impulse, u);
                    cA.wSub(this.m_invMassA, P);
                    aA -= this.m_invIA * Vec2.cross(rA, P);
                    cB.wAdd(this.m_invMassB, P);
                    aB += this.m_invIB * Vec2.cross(rB, P);
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    return Math.abs(C) < Settings.linearSlop;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/create": 51, "../util/options": 52 }], 28: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = FrictionJoint;

                var common = require("../util/common");

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                FrictionJoint.TYPE = "friction-joint";

                FrictionJoint._super = Joint;

                FrictionJoint.prototype = create(FrictionJoint._super.prototype);

                /**
                 * @typedef {Object} FrictionJointDef
                 *
                 * Friction joint definition.
                 * 
                 * @prop {float} maxForce The maximum friction force in N.
                 * @prop {float} maxTorque The maximum friction torque in N-m.
                 */
                var FrictionJointDef = {
                    maxForce: 0,
                    maxTorque: 0
                };

                /**
                 * Friction joint. This is used for top-down friction. It provides 2D
                 * translational friction and angular friction.
                 * 
                 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
                 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
                 */
                function FrictionJoint(def, bodyA, bodyB, anchor) {
                    if (!(this instanceof FrictionJoint)) {
                        return new FrictionJoint(def, bodyA, bodyB, anchor);
                    }
                    def = options(def, FrictionJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = FrictionJoint.TYPE;
                    if (anchor) {
                        this.m_localAnchorA = bodyA.getLocalPoint(anchor);
                        this.m_localAnchorB = bodyB.getLocalPoint(anchor);
                    } else {
                        this.m_localAnchorA = Vec2.zero();
                        this.m_localAnchorB = Vec2.zero();
                    }
                    // Solver shared
                    this.m_linearImpulse = Vec2.zero();
                    this.m_angularImpulse = 0;
                    this.m_maxForce = def.maxForce;
                    this.m_maxTorque = def.maxTorque;
                    // Solver temp
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_linearMass;
                    // Mat22
                    this.m_angularMass;
                }

                /**
                 * The local anchor point relative to bodyA's origin.
                 */
                FrictionJoint.prototype.getLocalAnchorA = function () {
                    return this.m_localAnchorA;
                };

                /**
                 * The local anchor point relative to bodyB's origin.
                 */
                FrictionJoint.prototype.getLocalAnchorB = function () {
                    return this.m_localAnchorB;
                };

                /**
                 * Set the maximum friction force in N.
                 */
                FrictionJoint.prototype.setMaxForce = function (force) {
                    //ASSERT && common.assert(IsValid(force) && force >= 0);
                    this.m_maxForce = force;
                };

                /**
                 * Get the maximum friction force in N.
                 */
                FrictionJoint.prototype.getMaxForce = function () {
                    return this.m_maxForce;
                };

                /**
                 * Set the maximum friction torque in N*m.
                 */
                FrictionJoint.prototype.setMaxTorque = function (torque) {
                    //ASSERT && common.assert(IsValid(torque) && torque >= 0);
                    this.m_maxTorque = torque;
                };

                /**
                 * Get the maximum friction torque in N*m.
                 */
                FrictionJoint.prototype.getMaxTorque = function () {
                    return this.m_maxTorque;
                };

                FrictionJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };

                FrictionJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                FrictionJoint.prototype.getReactionForce = function (inv_dt) {
                    return inv_dt * this.m_linearImpulse;
                };

                FrictionJoint.prototype.getReactionTorque = function (inv_dt) {
                    return inv_dt * this.m_angularImpulse;
                };

                FrictionJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA),
                        qB = Rot.neo(aB);
                    // Compute the effective mass matrix.
                    this.m_rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // J = [-I -r1_skew I r2_skew]
                    // [ 0 -1 0 1]
                    // r_skew = [-ry; rx]
                    // Matlab
                    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
                    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
                    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
                    var mA = this.m_invMassA,
                        mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA,
                        iB = this.m_invIB;
                    // float
                    var K = new Mat22();
                    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
                    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
                    this.m_linearMass = K.getInverse();
                    this.m_angularMass = iA + iB;
                    if (this.m_angularMass > 0) {
                        this.m_angularMass = 1 / this.m_angularMass;
                    }
                    if (step.warmStarting) {
                        // Scale impulses to support a variable time step.
                        this.m_linearImpulse.mul(step.dtRatio);
                        this.m_angularImpulse *= step.dtRatio;
                        var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);
                        vA.wSub(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_angularImpulse);
                        vB.wAdd(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + this.m_angularImpulse);
                    } else {
                        this.m_linearImpulse.setZero();
                        this.m_angularImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                FrictionJoint.prototype.solveVelocityConstraints = function (step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA,
                        mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA,
                        iB = this.m_invIB;
                    // float
                    var h = step.dt;
                    // float
                    // Solve angular friction
                    {
                        var Cdot = wB - wA;
                        // float
                        var impulse = -this.m_angularMass * Cdot;
                        // float
                        var oldImpulse = this.m_angularImpulse;
                        // float
                        var maxImpulse = h * this.m_maxTorque;
                        // float
                        this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_angularImpulse - oldImpulse;
                        wA -= iA * impulse;
                        wB += iB * impulse;
                    }
                    // Solve linear friction
                    {
                        var Cdot = Vec2.sub(Vec2.add(vB, Vec2.cross(wB, this.m_rB)), Vec2.add(vA, Vec2.cross(wA, this.m_rA)));
                        // Vec2
                        var impulse = Vec2.neg(Mat22.mul(this.m_linearMass, Cdot));
                        // Vec2
                        var oldImpulse = this.m_linearImpulse;
                        // Vec2
                        this.m_linearImpulse.add(impulse);
                        var maxImpulse = h * this.m_maxForce;
                        // float
                        if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {
                            this.m_linearImpulse.normalize();
                            this.m_linearImpulse.mul(maxImpulse);
                        }
                        impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);
                        vA.wSub(mA, impulse);
                        wA -= iA * Vec2.cross(this.m_rA, impulse);
                        vB.wAdd(mB, impulse);
                        wB += iB * Vec2.cross(this.m_rB, impulse);
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                FrictionJoint.prototype.solvePositionConstraints = function (step) {
                    return true;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/common": 50, "../util/create": 51, "../util/options": 52 }], 29: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = GearJoint;

                var common = require("../util/common");

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                var RevoluteJoint = require("./RevoluteJoint");

                var PrismaticJoint = require("./PrismaticJoint");

                GearJoint.TYPE = "gear-joint";

                GearJoint._super = Joint;

                GearJoint.prototype = create(GearJoint._super.prototype);

                /**
                 * @typedef {Object} GearJointDef
                 *
                 * Gear joint definition.
                 * 
                 * @prop {float} ratio The gear ratio. See GearJoint for explanation.
                 */
                var GearJointDef = {
                    ratio: 1
                };

                /**
                 * A gear joint is used to connect two joints together. Either joint can be a
                 * revolute or prismatic joint. You specify a gear ratio to bind the motions
                 * together: coordinate1 + ratio * coordinate2 = constant
                 * 
                 * The ratio can be negative or positive. If one joint is a revolute joint and
                 * the other joint is a prismatic joint, then the ratio will have units of
                 * length or units of 1/length. Warning: You have to manually destroy the gear
                 * joint if joint1 or joint2 is destroyed.
                 * 
                 * This definition requires two existing revolute or prismatic joints (any
                 * combination will work).
                 * 
                 * @param {RevoluteJoint|PrismaticJoint} joint1 The first revolute/prismatic
                 *          joint attached to the gear joint.
                 * @param {PrismaticJoint|RevoluteJoint} joint2 The second prismatic/revolute
                 *          joint attached to the gear joint.
                 */
                function GearJoint(def, bodyA, bodyB, joint1, joint2, ratio) {
                    if (!(this instanceof GearJoint)) {
                        return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);
                    }
                    def = options(def, GearJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = GearJoint.TYPE;
                    //ASSERT && common.assert(joint1.m_type == RevoluteJoint.TYPE || joint1.m_type == PrismaticJoint.TYPE);
                    //ASSERT && common.assert(joint2.m_type == RevoluteJoint.TYPE || joint2.m_type == PrismaticJoint.TYPE);
                    this.m_joint1 = joint1;
                    this.m_joint2 = joint2;
                    this.m_type1 = this.m_joint1.getType();
                    this.m_type2 = this.m_joint2.getType();
                    // joint1 connects body A to body C
                    // joint2 connects body B to body D
                    var coordinateA, coordinateB;
                    // float
                    // TODO_ERIN there might be some problem with the joint edges in Joint.
                    this.m_bodyC = this.m_joint1.getBodyA();
                    this.m_bodyA = this.m_joint1.getBodyB();
                    // Get geometry of joint1
                    var xfA = this.m_bodyA.m_xf;
                    var aA = this.m_bodyA.m_sweep.a;
                    var xfC = this.m_bodyC.m_xf;
                    var aC = this.m_bodyC.m_sweep.a;
                    if (this.m_type1 == RevoluteJoint.TYPE) {
                        var revolute = joint1;
                        // RevoluteJoint
                        this.m_localAnchorC = revolute.m_localAnchorA;
                        this.m_localAnchorA = revolute.m_localAnchorB;
                        this.m_referenceAngleA = revolute.m_referenceAngle;
                        this.m_localAxisC = Vec2.zero();
                        coordinateA = aA - aC - this.m_referenceAngleA;
                    } else {
                        var prismatic = joint1;
                        // PrismaticJoint
                        this.m_localAnchorC = prismatic.m_localAnchorA;
                        this.m_localAnchorA = prismatic.m_localAnchorB;
                        this.m_referenceAngleA = prismatic.m_referenceAngle;
                        this.m_localAxisC = prismatic.m_localXAxisA;
                        var pC = this.m_localAnchorC;
                        var pA = Rot.mulT(xfC.q, Vec2.add(Rot.mul(xfA.q, this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));
                        coordinateA = Vec2.dot(pA, this.m_localAxisC) - Vec2.dot(pC, this.m_localAxisC);
                    }
                    this.m_bodyD = this.m_joint2.getBodyA();
                    this.m_bodyB = this.m_joint2.getBodyB();
                    // Get geometry of joint2
                    var xfB = this.m_bodyB.m_xf;
                    var aB = this.m_bodyB.m_sweep.a;
                    var xfD = this.m_bodyD.m_xf;
                    var aD = this.m_bodyD.m_sweep.a;
                    if (this.m_type2 == RevoluteJoint.TYPE) {
                        var revolute = joint2;
                        // RevoluteJoint
                        this.m_localAnchorD = revolute.m_localAnchorA;
                        this.m_localAnchorB = revolute.m_localAnchorB;
                        this.m_referenceAngleB = revolute.m_referenceAngle;
                        this.m_localAxisD = Vec2.zero();
                        coordinateB = aB - aD - this.m_referenceAngleB;
                    } else {
                        var prismatic = joint2;
                        // PrismaticJoint
                        this.m_localAnchorD = prismatic.m_localAnchorA;
                        this.m_localAnchorB = prismatic.m_localAnchorB;
                        this.m_referenceAngleB = prismatic.m_referenceAngle;
                        this.m_localAxisD = prismatic.m_localXAxisA;
                        var pD = this.m_localAnchorD;
                        var pB = Rot.mulT(xfD.q, Vec2.add(Rot.mul(xfB.q, this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));
                        coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);
                    }
                    this.m_ratio = ratio || def.ratio;
                    this.m_constant = coordinateA + this.m_ratio * coordinateB;
                    this.m_impulse = 0;
                    // Solver temp
                    this.m_lcA, this.m_lcB, this.m_lcC, this.m_lcD;
                    // Vec2
                    this.m_mA, this.m_mB, this.m_mC, this.m_mD;
                    // float
                    this.m_iA, this.m_iB, this.m_iC, this.m_iD;
                    // float
                    this.m_JvAC, this.m_JvBD;
                    // Vec2
                    this.m_JwA, this.m_JwB, this.m_JwC, this.m_JwD;
                    // float
                    this.m_mass;
                }

                /**
                 * Get the first joint.
                 */
                GearJoint.prototype.getJoint1 = function () {
                    return this.m_joint1;
                };

                /**
                 * Get the second joint.
                 */
                GearJoint.prototype.getJoint2 = function () {
                    return this.m_joint2;
                };

                /**
                 * Set/Get the gear ratio.
                 */
                GearJoint.prototype.setRatio = function (ratio) {
                    //ASSERT && common.assert(IsValid(ratio));
                    this.m_ratio = ratio;
                };

                GearJoint.prototype.setRatio = function () {
                    return this.m_ratio;
                };

                GearJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };

                GearJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                GearJoint.prototype.getReactionForce = function (inv_dt) {
                    var P = this.m_impulse * this.m_JvAC;
                    // Vec2
                    return inv_dt * P;
                };

                GearJoint.prototype.getReactionTorque = function (inv_dt) {
                    var L = this.m_impulse * this.m_JwA;
                    // float
                    return inv_dt * L;
                };

                GearJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_lcA = this.m_bodyA.m_sweep.localCenter;
                    this.m_lcB = this.m_bodyB.m_sweep.localCenter;
                    this.m_lcC = this.m_bodyC.m_sweep.localCenter;
                    this.m_lcD = this.m_bodyD.m_sweep.localCenter;
                    this.m_mA = this.m_bodyA.m_invMass;
                    this.m_mB = this.m_bodyB.m_invMass;
                    this.m_mC = this.m_bodyC.m_invMass;
                    this.m_mD = this.m_bodyD.m_invMass;
                    this.m_iA = this.m_bodyA.m_invI;
                    this.m_iB = this.m_bodyB.m_invI;
                    this.m_iC = this.m_bodyC.m_invI;
                    this.m_iD = this.m_bodyD.m_invI;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var aC = this.m_bodyC.c_position.a;
                    var vC = this.m_bodyC.c_velocity.v;
                    var wC = this.m_bodyC.c_velocity.w;
                    var aD = this.m_bodyD.c_position.a;
                    var vD = this.m_bodyD.c_velocity.v;
                    var wD = this.m_bodyD.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var qC = Rot.neo(aC);
                    var qD = Rot.neo(aD);
                    this.m_mass = 0;
                    if (this.m_type1 == RevoluteJoint.TYPE) {
                        this.m_JvAC = Vec2.zero();
                        this.m_JwA = 1;
                        this.m_JwC = 1;
                        this.m_mass += this.m_iA + this.m_iC;
                    } else {
                        var u = Rot.mul(qC, this.m_localAxisC);
                        // Vec2
                        var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);
                        // Vec2
                        var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);
                        // Vec2
                        this.m_JvAC = u;
                        this.m_JwC = Vec2.cross(rC, u);
                        this.m_JwA = Vec2.cross(rA, u);
                        this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
                    }
                    if (this.m_type2 == RevoluteJoint.TYPE) {
                        this.m_JvBD = Vec2.zero();
                        this.m_JwB = this.m_ratio;
                        this.m_JwD = this.m_ratio;
                        this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
                    } else {
                        var u = Rot.mul(qD, this.m_localAxisD);
                        // Vec2
                        var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);
                        // Vec2
                        var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);
                        // Vec2
                        this.m_JvBD = Vec2.mul(this.m_ratio, u);
                        this.m_JwD = this.m_ratio * Vec2.cross(rD, u);
                        this.m_JwB = this.m_ratio * Vec2.cross(rB, u);
                        this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
                    }
                    // Compute effective mass.
                    this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;
                    if (step.warmStarting) {
                        vA.wAdd(this.m_mA * this.m_impulse, this.m_JvAC);
                        wA += this.m_iA * this.m_impulse * this.m_JwA;
                        vB.wAdd(this.m_mB * this.m_impulse, this.m_JvBD);
                        wB += this.m_iB * this.m_impulse * this.m_JwB;
                        vC.wSub(this.m_mC * this.m_impulse, this.m_JvAC);
                        wC -= this.m_iC * this.m_impulse * this.m_JwC;
                        vD.wSub(this.m_mD * this.m_impulse, this.m_JvBD);
                        wD -= this.m_iD * this.m_impulse * this.m_JwD;
                    } else {
                        this.m_impulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                    this.m_bodyC.c_velocity.v.set(vC);
                    this.m_bodyC.c_velocity.w = wC;
                    this.m_bodyD.c_velocity.v.set(vD);
                    this.m_bodyD.c_velocity.w = wD;
                };

                GearJoint.prototype.solveVelocityConstraints = function (step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var vC = this.m_bodyC.c_velocity.v;
                    var wC = this.m_bodyC.c_velocity.w;
                    var vD = this.m_bodyD.c_velocity.v;
                    var wD = this.m_bodyD.c_velocity.w;
                    var Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC) + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD);
                    // float
                    Cdot += this.m_JwA * wA - this.m_JwC * wC + (this.m_JwB * wB - this.m_JwD * wD);
                    var impulse = -this.m_mass * Cdot;
                    // float
                    this.m_impulse += impulse;
                    vA.wAdd(this.m_mA * impulse, this.m_JvAC);
                    wA += this.m_iA * impulse * this.m_JwA;
                    vB.wAdd(this.m_mB * impulse, this.m_JvBD);
                    wB += this.m_iB * impulse * this.m_JwB;
                    vC.wSub(this.m_mC * impulse, this.m_JvAC);
                    wC -= this.m_iC * impulse * this.m_JwC;
                    vD.wSub(this.m_mD * impulse, this.m_JvBD);
                    wD -= this.m_iD * impulse * this.m_JwD;
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                    this.m_bodyC.c_velocity.v.set(vC);
                    this.m_bodyC.c_velocity.w = wC;
                    this.m_bodyD.c_velocity.v.set(vD);
                    this.m_bodyD.c_velocity.w = wD;
                };

                GearJoint.prototype.solvePositionConstraints = function (step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var cC = this.m_bodyC.c_position.c;
                    var aC = this.m_bodyC.c_position.a;
                    var cD = this.m_bodyD.c_position.c;
                    var aD = this.m_bodyD.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var qC = Rot.neo(aC);
                    var qD = Rot.neo(aD);
                    var linearError = 0;
                    // float
                    var coordinateA, coordinateB;
                    // float
                    var JvAC, JvBD;
                    // Vec2
                    var JwA, JwB, JwC, JwD;
                    // float
                    var mass = 0;
                    // float
                    if (this.m_type1 == RevoluteJoint.TYPE) {
                        JvAC = Vec2.zero();
                        JwA = 1;
                        JwC = 1;
                        mass += this.m_iA + this.m_iC;
                        coordinateA = aA - aC - this.m_referenceAngleA;
                    } else {
                        var u = Rot.mul(qC, this.m_localAxisC);
                        // Vec2
                        var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);
                        // Vec2
                        var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);
                        // Vec2
                        JvAC = u;
                        JwC = Vec2.cross(rC, u);
                        JwA = Vec2.cross(rA, u);
                        mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;
                        var pC = this.m_localAnchorC - this.m_lcC;
                        // Vec2
                        var pA = Rot.mulT(qC, Vec2.add(rA, Vec2.sub(cA, cC)));
                        // Vec2
                        coordinateA = Dot(pA - pC, this.m_localAxisC);
                    }
                    if (this.m_type2 == RevoluteJoint.TYPE) {
                        JvBD = Vec2.zero();
                        JwB = this.m_ratio;
                        JwD = this.m_ratio;
                        mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
                        coordinateB = aB - aD - this.m_referenceAngleB;
                    } else {
                        var u = Rot.mul(qD, this.m_localAxisD);
                        var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);
                        var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);
                        JvBD = Vec2.mul(this.m_ratio, u);
                        JwD = this.m_ratio * Vec2.cross(rD, u);
                        JwB = this.m_ratio * Vec2.cross(rB, u);
                        mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;
                        var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD);
                        // Vec2
                        var pB = Rot.mulT(qD, Vec2.add(rB, Vec2.sub(cB, cD)));
                        // Vec2
                        coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);
                    }
                    var C = coordinateA + this.m_ratio * coordinateB - this.m_constant;
                    // float
                    var impulse = 0;
                    // float
                    if (mass > 0) {
                        impulse = -C / mass;
                    }
                    cA.wAdd(this.m_mA * impulse, JvAC);
                    aA += this.m_iA * impulse * JwA;
                    cB.wAdd(this.m_mB * impulse, JvBD);
                    aB += this.m_iB * impulse * JwB;
                    cC.wAdd(this.m_mC * impulse, JvAC);
                    aC -= this.m_iC * impulse * JwC;
                    cD.wAdd(this.m_mD * impulse, JvBD);
                    aD -= this.m_iD * impulse * JwD;
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    this.m_bodyC.c_position.c.set(cC);
                    this.m_bodyC.c_position.a = aC;
                    this.m_bodyD.c_position.c.set(cD);
                    this.m_bodyD.c_position.a = aD;
                    // TODO_ERIN not implemented
                    return linearError < Settings.linearSlop;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/common": 50, "../util/create": 51, "../util/options": 52, "./PrismaticJoint": 32, "./RevoluteJoint": 34 }], 30: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = MotorJoint;

                var common = require("../util/common");

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                MotorJoint.TYPE = "motor-joint";

                MotorJoint._super = Joint;

                MotorJoint.prototype = create(MotorJoint._super.prototype);

                /**
                 * @typedef {Object} MotorJointDef
                 *
                 * Motor joint definition.
                 * 
                 * @prop {float} angularOffset The bodyB angle minus bodyA angle in radians.
                 * @prop {float} maxForce The maximum motor force in N.
                 * @prop {float} maxTorque The maximum motor torque in N-m.
                 * @prop {float} correctionFactor Position correction factor in the range [0,1].
                 */
                var MotorJointDef = {
                    maxForce: 1,
                    maxTorque: 1,
                    correctionFactor: .3
                };

                /**
                 * A motor joint is used to control the relative motion between two bodies. A
                 * typical usage is to control the movement of a dynamic body with respect to
                 * the ground.
                 * 
                 * @prop {Vec2} linearOffset Position of bodyB minus the position of bodyA, in
                 *       bodyA's frame, in meters.
                 */
                function MotorJoint(def, bodyA, bodyB) {
                    if (!(this instanceof MotorJoint)) {
                        return new MotorJoint(def, bodyA, bodyB);
                    }
                    def = options(def, MotorJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = MotorJoint.TYPE;
                    var xB = bodyB.getPosition();
                    this.m_linearOffset = bodyA.getLocalPoint(xB);
                    var angleA = bodyA.getAngle();
                    var angleB = bodyB.getAngle();
                    this.m_angularOffset = angleB - angleA;
                    this.m_linearImpulse = Vec2.zero();
                    this.m_angularImpulse = 0;
                    this.m_maxForce = def.maxForce;
                    this.m_maxTorque = def.maxTorque;
                    this.m_correctionFactor = def.correctionFactor;
                    // Solver temp
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_linearError;
                    // Vec2
                    this.m_angularError;
                    // float
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_linearMass;
                    // Mat22
                    this.m_angularMass;
                }

                /**
                 * Set the maximum friction force in N.
                 */
                MotorJoint.prototype.setMaxForce = function (force) {
                    //ASSERT && common.assert(IsValid(force) && force >= 0);
                    this.m_maxForce = force;
                };

                /**
                 * Get the maximum friction force in N.
                 */
                MotorJoint.prototype.getMaxForce = function () {
                    return this.m_maxForce;
                };

                /**
                 * Set the maximum friction torque in N*m.
                 */
                MotorJoint.prototype.setMaxTorque = function (torque) {
                    //ASSERT && common.assert(IsValid(torque) && torque >= 0);
                    this.m_maxTorque = torque;
                };

                /**
                 * Get the maximum friction torque in N*m.
                 */
                MotorJoint.prototype.getMaxTorque = function () {
                    return this.m_maxTorque;
                };

                /**
                 * Set the position correction factor in the range [0,1].
                 */
                MotorJoint.prototype.setCorrectionFactor = function (factor) {
                    //ASSERT && common.assert(IsValid(factor) && 0 <= factor && factor <= 1);
                    this.m_correctionFactor = factor;
                };

                /**
                 * Get the position correction factor in the range [0,1].
                 */
                MotorJoint.prototype.getCorrectionFactor = function () {
                    return this.m_correctionFactor;
                };

                /**
                 * Set/get the target linear offset, in frame A, in meters.
                 */
                MotorJoint.prototype.setLinearOffset = function ( /* Vec2& */linearOffset) {
                    if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_linearOffset = linearOffset;
                    }
                };

                MotorJoint.prototype.getLinearOffset = function () {
                    return this.m_linearOffset;
                };

                /**
                 * Set/get the target angular offset, in radians.
                 */
                MotorJoint.prototype.setAngularOffset = function (angularOffset) {
                    if (angularOffset != this.m_angularOffset) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_angularOffset = angularOffset;
                    }
                };

                MotorJoint.prototype.getAngularOffset = function () {
                    return this.m_angularOffset;
                };

                MotorJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getPosition();
                };

                MotorJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getPosition();
                };

                MotorJoint.prototype.getReactionForce = function (inv_dt) {
                    return inv_dt * this.m_linearImpulse;
                };

                MotorJoint.prototype.getReactionTorque = function (inv_dt) {
                    return inv_dt * this.m_angularImpulse;
                };

                MotorJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA),
                        qB = Rot.neo(aB);
                    // Compute the effective mass matrix.
                    this.m_rA = Rot.mul(qA, Vec2.neg(this.m_localCenterA));
                    this.m_rB = Rot.mul(qB, Vec2.neg(this.m_localCenterB));
                    // J = [-I -r1_skew I r2_skew]
                    // [ 0 -1 0 1]
                    // r_skew = [-ry; rx]
                    // Matlab
                    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
                    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
                    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    var K = new Mat22();
                    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
                    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
                    this.m_linearMass = K.getInverse();
                    this.m_angularMass = iA + iB;
                    if (this.m_angularMass > 0) {
                        this.m_angularMass = 1 / this.m_angularMass;
                    }
                    this.m_linearError = Vec2.zero();
                    this.m_linearError.wAdd(1, cB, 1, this.m_rB);
                    this.m_linearError.wSub(1, cA, 1, this.m_rA);
                    this.m_linearError.sub(Rot.mul(qA, this.m_linearOffset));
                    this.m_angularError = aB - aA - this.m_angularOffset;
                    if (step.warmStarting) {
                        // Scale impulses to support a variable time step.
                        this.m_linearImpulse.mul(step.dtRatio);
                        this.m_angularImpulse *= step.dtRatio;
                        var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);
                        vA.wSub(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_angularImpulse);
                        vB.wAdd(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + this.m_angularImpulse);
                    } else {
                        this.m_linearImpulse.setZero();
                        this.m_angularImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                MotorJoint.prototype.solveVelocityConstraints = function (step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA,
                        mB = this.m_invMassB;
                    var iA = this.m_invIA,
                        iB = this.m_invIB;
                    var h = step.dt;
                    var inv_h = step.inv_dt;
                    // Solve angular friction
                    {
                        var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
                        var impulse = -this.m_angularMass * Cdot;
                        var oldImpulse = this.m_angularImpulse;
                        var maxImpulse = h * this.m_maxTorque;
                        this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_angularImpulse - oldImpulse;
                        wA -= iA * impulse;
                        wB += iB * impulse;
                    }
                    // Solve linear friction
                    {
                        var Cdot = Vec2.zero();
                        Cdot.wAdd(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot.wSub(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        Cdot.wAdd(inv_h * this.m_correctionFactor, this.m_linearError);
                        var impulse = Vec2.neg(Mat22.mul(this.m_linearMass, Cdot));
                        var oldImpulse = Vec2.clone(this.m_linearImpulse);
                        this.m_linearImpulse.add(impulse);
                        var maxImpulse = h * this.m_maxForce;
                        this.m_linearImpulse.clamp(maxImpulse);
                        impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);
                        vA.wSub(mA, impulse);
                        wA -= iA * Vec2.cross(this.m_rA, impulse);
                        vB.wAdd(mB, impulse);
                        wB += iB * Vec2.cross(this.m_rB, impulse);
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                MotorJoint.prototype.solvePositionConstraints = function (step) {
                    return true;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/common": 50, "../util/create": 51, "../util/options": 52 }], 31: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = MouseJoint;

                var common = require("../util/common");

                var options = require("../util/options");

                var create = require("../util/create");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                MouseJoint.TYPE = "mouse-joint";

                MouseJoint._super = Joint;

                MouseJoint.prototype = create(MouseJoint._super.prototype);

                /**
                 * @typedef {Object} MouseJointDef
                 *
                 * Mouse joint definition. This requires a world target point, tuning
                 * parameters, and the time step.
                 * 
                 * @prop [maxForce = 0.0] The maximum constraint force that can be exerted to
                 *       move the candidate body. Usually you will express as some multiple of
                 *       the weight (multiplier * mass * gravity).
                 * @prop [frequencyHz = 5.0] The response speed.
                 * @prop [dampingRatio = 0.7] The damping ratio. 0 = no damping, 1 = critical
                 *       damping.
                 */
                var MouseJointDef = {
                    maxForce: 0,
                    frequencyHz: 5,
                    dampingRatio: .7
                };

                /**
                 * A mouse joint is used to make a point on a body track a specified world
                 * point. This a soft constraint with a maximum force. This allows the
                 * constraint to stretch and without applying huge forces.
                 * 
                 * NOTE: this joint is not documented in the manual because it was developed to
                 * be used in the testbed. If you want to learn how to use the mouse joint, look
                 * at the testbed.
                 * 
                 * @prop {Vec2} target The initial world target point. This is assumed to
                 *       coincide with the body anchor initially.
                 */
                function MouseJoint(def, bodyA, bodyB, target) {
                    if (!(this instanceof MouseJoint)) {
                        return new MouseJoint(def, bodyA, bodyB, target);
                    }
                    def = options(def, MouseJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = MouseJoint.TYPE;
                    //ASSERT && common.assert(Math.isFinite(def.maxForce) && def.maxForce >= 0);
                    //ASSERT && common.assert(Math.isFinite(def.frequencyHz) && def.frequencyHz >= 0);
                    //ASSERT && common.assert(Math.isFinite(def.dampingRatio) && def.dampingRatio >= 0);
                    this.m_targetA = Vec2.clone(target);
                    this.m_localAnchorB = Transform.mulT(this.m_bodyB.getTransform(), this.m_targetA);
                    this.m_maxForce = def.maxForce;
                    this.m_impulse = Vec2.zero();
                    this.m_frequencyHz = def.frequencyHz;
                    this.m_dampingRatio = def.dampingRatio;
                    this.m_beta = 0;
                    this.m_gamma = 0;
                    // Solver temp
                    this.m_rB = Vec2.zero();
                    this.m_localCenterB = Vec2.zero();
                    this.m_invMassB = 0;
                    this.m_invIB = 0;
                    this.mass = new Mat22();
                    this.m_C = Vec2.zero();
                }

                /**
                 * Use this to update the target point.
                 */
                MouseJoint.prototype.setTarget = function (target) {
                    if (this.m_bodyB.isAwake() == false) {
                        this.m_bodyB.setAwake(true);
                    }
                    this.m_targetA = Vec2.clone(target);
                };

                MouseJoint.prototype.getTarget = function () {
                    return this.m_targetA;
                };

                /**
                 * Set/get the maximum force in Newtons.
                 */
                MouseJoint.prototype.setMaxForce = function (force) {
                    this.m_maxForce = force;
                };

                MouseJoint.getMaxForce = function () {
                    return this.m_maxForce;
                };

                /**
                 * Set/get the frequency in Hertz.
                 */
                MouseJoint.prototype.setFrequency = function (hz) {
                    this.m_frequencyHz = hz;
                };

                MouseJoint.prototype.getFrequency = function () {
                    return this.m_frequencyHz;
                };

                /**
                 * Set/get the damping ratio (dimensionless).
                 */
                MouseJoint.prototype.setDampingRatio = function (ratio) {
                    this.m_dampingRatio = ratio;
                };

                MouseJoint.prototype.getDampingRatio = function () {
                    return this.m_dampingRatio;
                };

                MouseJoint.prototype.getAnchorA = function () {
                    return Vec2.clone(this.m_targetA);
                };

                MouseJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                MouseJoint.prototype.getReactionForce = function (inv_dt) {
                    return Vec2.mul(inv_dt, this.m_impulse);
                };

                MouseJoint.prototype.getReactionTorque = function (inv_dt) {
                    return inv_dt * 0;
                };

                MouseJoint.prototype.shiftOrigin = function (newOrigin) {
                    this.m_targetA.sub(newOrigin);
                };

                MouseJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var position = this.m_bodyB.c_position;
                    var velocity = this.m_bodyB.c_velocity;
                    var cB = position.c;
                    var aB = position.a;
                    var vB = velocity.v;
                    var wB = velocity.w;
                    var qB = Rot.neo(aB);
                    var mass = this.m_bodyB.getMass();
                    // Frequency
                    var omega = 2 * Math.PI * this.m_frequencyHz;
                    // Damping coefficient
                    var d = 2 * mass * this.m_dampingRatio * omega;
                    // Spring stiffness
                    var k = mass * (omega * omega);
                    // magic formulas
                    // gamma has units of inverse mass.
                    // beta has units of inverse time.
                    var h = step.dt;
                    //ASSERT && common.assert(d + h * k > Math.EPSILON);
                    this.m_gamma = h * (d + h * k);
                    if (this.m_gamma != 0) {
                        this.m_gamma = 1 / this.m_gamma;
                    }
                    this.m_beta = h * k * this.m_gamma;
                    // Compute the effective mass matrix.
                    this.m_rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *
                    // invI2 * skew(r2)]
                    // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y
                    // -r1.x*r1.y]
                    // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]
                    var K = new Mat22();
                    K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
                    K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
                    this.m_mass = K.getInverse();
                    this.m_C.set(cB);
                    this.m_C.wAdd(1, this.m_rB, -1, this.m_targetA);
                    this.m_C.mul(this.m_beta);
                    // Cheat with some damping
                    wB *= .98;
                    if (step.warmStarting) {
                        this.m_impulse.mul(step.dtRatio);
                        vB.wAdd(this.m_invMassB, this.m_impulse);
                        wB += this.m_invIB * Vec2.cross(this.m_rB, this.m_impulse);
                    } else {
                        this.m_impulse.setZero();
                    }
                    velocity.v.set(vB);
                    velocity.w = wB;
                };

                MouseJoint.prototype.solveVelocityConstraints = function (step) {
                    var velocity = this.m_bodyB.c_velocity;
                    var vB = Vec2.clone(velocity.v);
                    var wB = velocity.w;
                    // Cdot = v + cross(w, r)
                    var Cdot = Vec2.cross(wB, this.m_rB);
                    Cdot.add(vB);
                    Cdot.wAdd(1, this.m_C, this.m_gamma, this.m_impulse);
                    Cdot.neg();
                    var impulse = Mat22.mul(this.m_mass, Cdot);
                    var oldImpulse = Vec2.clone(this.m_impulse);
                    this.m_impulse.add(impulse);
                    var maxImpulse = step.dt * this.m_maxForce;
                    this.m_impulse.clamp(maxImpulse);
                    impulse = Vec2.sub(this.m_impulse, oldImpulse);
                    vB.wAdd(this.m_invMassB, impulse);
                    wB += this.m_invIB * Vec2.cross(this.m_rB, impulse);
                    velocity.v.set(vB);
                    velocity.w = wB;
                };

                MouseJoint.prototype.solvePositionConstraints = function (step) {
                    return true;
                };
            }, { "../Joint": 5, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/common": 50, "../util/create": 51, "../util/options": 52 }], 32: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = PrismaticJoint;

                var common = require("../util/common");

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                var inactiveLimit = 0;

                var atLowerLimit = 1;

                var atUpperLimit = 2;

                var equalLimits = 3;

                PrismaticJoint.TYPE = "prismatic-joint";

                PrismaticJoint._super = Joint;

                PrismaticJoint.prototype = create(PrismaticJoint._super.prototype);

                /**
                 * @typedef {Object} PrismaticJointDef
                 *
                 * Prismatic joint definition. This requires defining a line of motion using an
                 * axis and an anchor point. The definition uses local anchor points and a local
                 * axis so that the initial configuration can violate the constraint slightly.
                 * The joint translation is zero when the local anchor points coincide in world
                 * space. Using local anchors and a local axis helps when saving and loading a
                 * game.
                 * 
                 * @prop {boolean} enableLimit Enable/disable the joint limit.
                 * @prop {float} lowerTranslation The lower translation limit, usually in
                 *       meters.
                 * @prop {float} upperTranslation The upper translation limit, usually in
                 *       meters.
                 * @prop {boolean} enableMotor Enable/disable the joint motor.
                 * @prop {float} maxMotorForce The maximum motor torque, usually in N-m.
                 * @prop {float} motorSpeed The desired motor speed in radians per second.
                 */
                var PrismaticJointDef = {
                    enableLimit: false,
                    lowerTranslation: 0,
                    upperTranslation: 0,
                    enableMotor: false,
                    maxMotorForce: 0,
                    motorSpeed: 0
                };

                /**
                 * A prismatic joint. This joint provides one degree of freedom: translation
                 * along an axis fixed in bodyA. Relative rotation is prevented. You can use a
                 * joint limit to restrict the range of motion and a joint motor to drive the
                 * motion or to model joint friction.
                 * 
                 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
                 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
                 * @prop {Vec2} localAxisA The local translation unit axis in bodyA.
                 * @prop {float} referenceAngle The constrained angle between the bodies:
                 *       bodyB_angle - bodyA_angle.
                 */
                function PrismaticJoint(def, bodyA, bodyB, anchor, axis) {
                    if (!(this instanceof PrismaticJoint)) {
                        return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);
                    }
                    def = options(def, PrismaticJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = PrismaticJoint.TYPE;
                    this.m_localAnchorA = def.localAnchorA || bodyA.getLocalPoint(anchor);
                    this.m_localAnchorB = def.localAnchorB || bodyB.getLocalPoint(anchor);
                    this.m_localXAxisA = def.localAxisA || bodyA.getLocalVector(axis);
                    this.m_localXAxisA.normalize();
                    this.m_localYAxisA = Vec2.cross(1, this.m_localXAxisA);
                    this.m_referenceAngle = bodyB.getAngle() - bodyA.getAngle();
                    this.m_impulse = Vec3();
                    this.m_motorMass = 0;
                    this.m_motorImpulse = 0;
                    this.m_lowerTranslation = def.lowerTranslation;
                    this.m_upperTranslation = def.upperTranslation;
                    this.m_maxMotorForce = def.maxMotorForce;
                    this.m_motorSpeed = def.motorSpeed;
                    this.m_enableLimit = def.enableLimit;
                    this.m_enableMotor = def.enableMotor;
                    this.m_limitState = inactiveLimit;
                    this.m_axis = Vec2.zero();
                    this.m_perp = Vec2.zero();
                    // Solver temp
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_axis, this.m_perp;
                    // Vec2
                    this.m_s1, this.m_s2;
                    // float
                    this.m_a1, this.m_a2;
                    // float
                    this.m_K = new Mat33();
                    this.m_motorMass;
                }

                /**
                 * The local anchor point relative to bodyA's origin.
                 */
                PrismaticJoint.prototype.getLocalAnchorA = function () {
                    return this.m_localAnchorA;
                };

                /**
                 * The local anchor point relative to bodyB's origin.
                 */
                PrismaticJoint.prototype.getLocalAnchorB = function () {
                    return this.m_localAnchorB;
                };

                /**
                 * The local joint axis relative to bodyA.
                 */
                PrismaticJoint.prototype.getLocalAxisA = function () {
                    return this.m_localXAxisA;
                };

                /**
                 * Get the reference angle.
                 */
                PrismaticJoint.prototype.getReferenceAngle = function () {
                    return this.m_referenceAngle;
                };

                /**
                 * Get the current joint translation, usually in meters.
                 */
                PrismaticJoint.prototype.getJointTranslation = function () {
                    var pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                    var pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                    var d = Vec2.sub(pB, pA);
                    var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);
                    var translation = Vec2.dot(d, axis);
                    return translation;
                };

                /**
                 * Get the current joint translation speed, usually in meters per second.
                 */
                PrismaticJoint.prototype.getJointSpeed = function () {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    var rA = Mul(bA.m_xf.q, this.m_localAnchorA - bA.m_sweep.localCenter);
                    // Vec2
                    var rB = Mul(bB.m_xf.q, this.m_localAnchorB - bB.m_sweep.localCenter);
                    // Vec2
                    var p1 = bA.m_sweep.c + rA;
                    // Vec2
                    var p2 = bB.m_sweep.c + rB;
                    // Vec2
                    var d = p2 - p1;
                    // Vec2
                    var axis = Mul(bA.m_xf.q, this.m_localXAxisA);
                    // Vec2
                    var vA = bA.m_linearVelocity;
                    // Vec2
                    var vB = bB.m_linearVelocity;
                    // Vec2
                    var wA = bA.m_angularVelocity;
                    // float
                    var wB = bB.m_angularVelocity;
                    // float
                    var speed = Dot(d, Cross(wA, axis)) + Dot(axis, vB + Cross(wB, rB) - vA - Cross(wA, rA));
                    // float
                    return speed;
                };

                /**
                 * Is the joint limit enabled?
                 */
                PrismaticJoint.prototype.isLimitEnabled = function () {
                    return this.m_enableLimit;
                };

                /**
                 * Enable/disable the joint limit.
                 */
                PrismaticJoint.prototype.enableLimit = function (flag) {
                    if (flag != this.m_enableLimit) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_enableLimit = flag;
                        this.m_impulse.z = 0;
                    }
                };

                /**
                 * Get the lower joint limit, usually in meters.
                 */
                PrismaticJoint.prototype.getLowerLimit = function () {
                    return this.m_lowerTranslation;
                };

                /**
                 * Get the upper joint limit, usually in meters.
                 */
                PrismaticJoint.prototype.getUpperLimit = function () {
                    return this.m_upperTranslation;
                };

                /**
                 * Set the joint limits, usually in meters.
                 */
                PrismaticJoint.prototype.setLimits = function (lower, upper) {
                    //ASSERT && common.assert(lower <= upper);
                    if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_lowerTranslation = lower;
                        this.m_upperTranslation = upper;
                        this.m_impulse.z = 0;
                    }
                };

                /**
                 * Is the joint motor enabled?
                 */
                PrismaticJoint.prototype.isMotorEnabled = function () {
                    return this.m_enableMotor;
                };

                /**
                 * Enable/disable the joint motor.
                 */
                PrismaticJoint.prototype.enableMotor = function (flag) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_enableMotor = flag;
                };

                /**
                 * Set the motor speed, usually in meters per second.
                 */
                PrismaticJoint.prototype.setMotorSpeed = function (speed) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_motorSpeed = speed;
                };

                /**
                 * Set the maximum motor force, usually in N.
                 */
                PrismaticJoint.prototype.setMaxMotorForce = function (force) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_maxMotorForce = force;
                };

                /**
                 * Get the motor speed, usually in meters per second.
                 */
                PrismaticJoint.prototype.getMotorSpeed = function () {
                    return this.m_motorSpeed;
                };

                /**
                 * Get the current motor force given the inverse time step, usually in N.
                 */
                PrismaticJoint.prototype.getMotorForce = function (inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                };

                PrismaticJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };

                PrismaticJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                PrismaticJoint.prototype.getReactionForce = function (inv_dt) {
                    return inv_dt * (this.m_impulse.x * this.m_perp + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis);
                };

                PrismaticJoint.prototype.getReactionTorque = function (inv_dt) {
                    return inv_dt * this.m_impulse.y;
                };

                PrismaticJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    // Compute the effective masses.
                    var rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    var rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    var d = Vec2.zero();
                    d.wAdd(1, cB, 1, rB);
                    d.wSub(1, cA, 1, rA);
                    var mA = this.m_invMassA,
                        mB = this.m_invMassB;
                    var iA = this.m_invIA,
                        iB = this.m_invIB;
                    // Compute motor Jacobian and effective mass.
                    {
                        this.m_axis = Rot.mul(qA, this.m_localXAxisA);
                        this.m_a1 = Vec2.cross(Vec2.add(d, rA), this.m_axis);
                        this.m_a2 = Vec2.cross(rB, this.m_axis);
                        this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
                        if (this.m_motorMass > 0) {
                            this.m_motorMass = 1 / this.m_motorMass;
                        }
                    }
                    // Prismatic constraint.
                    {
                        this.m_perp = Rot.mul(qA, this.m_localYAxisA);
                        this.m_s1 = Vec2.cross(Vec2.add(d, rA), this.m_perp);
                        this.m_s2 = Vec2.cross(rB, this.m_perp);
                        var s1test = Vec2.cross(rA, this.m_perp);
                        var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
                        var k12 = iA * this.m_s1 + iB * this.m_s2;
                        var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
                        var k22 = iA + iB;
                        if (k22 == 0) {
                            // For bodies with fixed rotation.
                            k22 = 1;
                        }
                        var k23 = iA * this.m_a1 + iB * this.m_a2;
                        var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
                        this.m_K.ex.set(k11, k12, k13);
                        this.m_K.ey.set(k12, k22, k23);
                        this.m_K.ez.set(k13, k23, k33);
                    }
                    // Compute motor and limit terms.
                    if (this.m_enableLimit) {
                        var jointTranslation = Vec2.dot(this.m_axis, d);
                        // float
                        if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * Settings.linearSlop) {
                            this.m_limitState = equalLimits;
                        } else if (jointTranslation <= this.m_lowerTranslation) {
                            if (this.m_limitState != atLowerLimit) {
                                this.m_limitState = atLowerLimit;
                                this.m_impulse.z = 0;
                            }
                        } else if (jointTranslation >= this.m_upperTranslation) {
                            if (this.m_limitState != atUpperLimit) {
                                this.m_limitState = atUpperLimit;
                                this.m_impulse.z = 0;
                            }
                        } else {
                            this.m_limitState = inactiveLimit;
                            this.m_impulse.z = 0;
                        }
                    } else {
                        this.m_limitState = inactiveLimit;
                        this.m_impulse.z = 0;
                    }
                    if (this.m_enableMotor == false) {
                        this.m_motorImpulse = 0;
                    }
                    if (step.warmStarting) {
                        // Account for variable time step.
                        this.m_impulse.mul(step.dtRatio);
                        this.m_motorImpulse *= step.dtRatio;
                        var P = Vec2.wAdd(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis);
                        var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
                        var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
                        vA.wSub(mA, P);
                        wA -= iA * LA;
                        vB.wAdd(mB, P);
                        wB += iB * LB;
                    } else {
                        this.m_impulse.setZero();
                        this.m_motorImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };

                PrismaticJoint.prototype.solveVelocityConstraints = function (step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // Solve linear motor constraint.
                    if (this.m_enableMotor && this.m_limitState != equalLimits) {
                        var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB - this.m_a1 * wA;
                        var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
                        var oldImpulse = this.m_motorImpulse;
                        var maxImpulse = step.dt * this.m_maxMotorForce;
                        this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_motorImpulse - oldImpulse;
                        var P = Vec2.zero().wSet(impulse, this.m_axis);
                        var LA = impulse * this.m_a1;
                        var LB = impulse * this.m_a2;
                        vA.wSub(mA, P);
                        wA -= iA * LA;
                        vB.wAdd(mB, P);
                        wB += iB * LB;
                    }
                    var Cdot1 = Vec2.zero();
                    Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;
                    Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;
                    Cdot1.y = wB - wA;
                    if (this.m_enableLimit && this.m_limitState != inactiveLimit) {
                        // Solve prismatic and limit constraint in block form.
                        var Cdot2 = 0;
                        Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;
                        Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;
                        var Cdot = Vec3(Cdot1.x, Cdot1.y, Cdot2);
                        var f1 = Vec3(this.m_impulse);
                        var df = this.m_K.solve33(Vec3.neg(Cdot));
                        // Vec3
                        this.m_impulse.add(df);
                        if (this.m_limitState == atLowerLimit) {
                            this.m_impulse.z = Math.max(this.m_impulse.z, 0);
                        } else if (this.m_limitState == atUpperLimit) {
                            this.m_impulse.z = Math.min(this.m_impulse.z, 0);
                        }
                        // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +
                        // f1(1:2)
                        var b = Vec2.wAdd(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y));
                        // Vec2
                        var f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y));
                        // Vec2
                        this.m_impulse.x = f2r.x;
                        this.m_impulse.y = f2r.y;
                        df = Vec3.sub(this.m_impulse, f1);
                        var P = Vec2.wAdd(df.x, this.m_perp, df.z, this.m_axis);
                        // Vec2
                        var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;
                        // float
                        var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;
                        // float
                        vA.wSub(mA, P);
                        wA -= iA * LA;
                        vB.wAdd(mB, P);
                        wB += iB * LB;
                    } else {
                        // Limit is inactive, just solve the prismatic constraint in block form.
                        var df = this.m_K.solve22(Vec2.neg(Cdot1));
                        // Vec2
                        this.m_impulse.x += df.x;
                        this.m_impulse.y += df.y;
                        var P = Vec2.zero().wAdd(df.x, this.m_perp);
                        // Vec2
                        var LA = df.x * this.m_s1 + df.y;
                        // float
                        var LB = df.x * this.m_s2 + df.y;
                        // float
                        vA.wSub(mA, P);
                        wA -= iA * LA;
                        vB.wAdd(mB, P);
                        wB += iB * LB;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                PrismaticJoint.prototype.solvePositionConstraints = function (step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // Compute fresh Jacobians
                    var rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    // Vec2
                    var rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // Vec2
                    var d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));
                    // Vec2
                    var axis = Rot.mul(qA, this.m_localXAxisA);
                    // Vec2
                    var a1 = Vec2.cross(Vec2.add(d, rA), axis);
                    // float
                    var a2 = Vec2.cross(rB, axis);
                    // float
                    var perp = Rot.mul(qA, this.m_localYAxisA);
                    // Vec2
                    var s1 = Vec2.cross(Vec2.add(d, rA), perp);
                    // float
                    var s2 = Vec2.cross(rB, perp);
                    // float
                    var impulse = Vec3();
                    var C1 = Vec2.zero();
                    // Vec2
                    C1.x = Vec2.dot(perp, d);
                    C1.y = aB - aA - this.m_referenceAngle;
                    var linearError = Math.abs(C1.x);
                    // float
                    var angularError = Math.abs(C1.y);
                    // float
                    var linearSlop = Settings.linearSlop;
                    var maxLinearCorrection = Settings.maxLinearCorrection;
                    var active = false;
                    // bool
                    var C2 = 0;
                    // float
                    if (this.m_enableLimit) {
                        var translation = Vec2.dot(axis, d);
                        // float
                        if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * linearSlop) {
                            // Prevent large angular corrections
                            C2 = Math.clamp(translation, -maxLinearCorrection, maxLinearCorrection);
                            linearError = Math.max(linearError, Math.abs(translation));
                            active = true;
                        } else if (translation <= this.m_lowerTranslation) {
                            // Prevent large linear corrections and allow some slop.
                            C2 = Math.clamp(translation - this.m_lowerTranslation + linearSlop, -maxLinearCorrection, 0);
                            linearError = Math.max(linearError, this.m_lowerTranslation - translation);
                            active = true;
                        } else if (translation >= this.m_upperTranslation) {
                            // Prevent large linear corrections and allow some slop.
                            C2 = Math.clamp(translation - this.m_upperTranslation - linearSlop, 0, maxLinearCorrection);
                            linearError = Math.max(linearError, translation - this.m_upperTranslation);
                            active = true;
                        }
                    }
                    if (active) {
                        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
                        // float
                        var k12 = iA * s1 + iB * s2;
                        // float
                        var k13 = iA * s1 * a1 + iB * s2 * a2;
                        // float
                        var k22 = iA + iB;
                        // float
                        if (k22 == 0) {
                            // For fixed rotation
                            k22 = 1;
                        }
                        var k23 = iA * a1 + iB * a2;
                        // float
                        var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
                        // float
                        var K = new Mat33();
                        K.ex.set(k11, k12, k13);
                        K.ey.set(k12, k22, k23);
                        K.ez.set(k13, k23, k33);
                        var C = Vec3();
                        C.x = C1.x;
                        C.y = C1.y;
                        C.z = C2;
                        impulse = K.solve33(Vec3.neg(C));
                    } else {
                        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
                        // float
                        var k12 = iA * s1 + iB * s2;
                        // float
                        var k22 = iA + iB;
                        // float
                        if (k22 == 0) {
                            k22 = 1;
                        }
                        var K = new Mat22();
                        K.ex.set(k11, k12);
                        K.ey.set(k12, k22);
                        var impulse1 = K.solve(Vec2.neg(C1));
                        // Vec2
                        impulse.x = impulse1.x;
                        impulse.y = impulse1.y;
                        impulse.z = 0;
                    }
                    var P = Vec2.wAdd(impulse.x, perp, impulse.z, axis);
                    // Vec2
                    var LA = impulse.x * s1 + impulse.y + impulse.z * a1;
                    // float
                    var LB = impulse.x * s2 + impulse.y + impulse.z * a2;
                    // float
                    cA.wSub(mA, P);
                    aA -= iA * LA;
                    cB.wAdd(mB, P);
                    aB += iB * LB;
                    this.m_bodyA.c_position.c = cA;
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c = cB;
                    this.m_bodyB.c_position.a = aB;
                    return linearError <= Settings.linearSlop && angularError <= Settings.angularSlop;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/common": 50, "../util/create": 51, "../util/options": 52 }], 33: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = PulleyJoint;

                var common = require("../util/common");

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                PulleyJoint.TYPE = "pulley-joint";

                PulleyJoint.MIN_PULLEY_LENGTH = 2;

                // minPulleyLength
                PulleyJoint._super = Joint;

                PulleyJoint.prototype = create(PulleyJoint._super.prototype);

                /**
                 * @typedef {Object} PulleyJointDef
                 *
                 * Pulley joint definition. This requires two ground anchors, two dynamic body
                 * anchor points, and a pulley ratio.
                 */
                var PulleyJointDef = {
                    collideConnected: true
                };

                /**
                 * The pulley joint is connected to two bodies and two fixed ground points. The
                 * pulley supports a ratio such that: length1 + ratio * length2 <= constant
                 * 
                 * Yes, the force transmitted is scaled by the ratio.
                 * 
                 * Warning: the pulley joint can get a bit squirrelly by itself. They often work
                 * better when combined with prismatic joints. You should also cover the the
                 * anchor points with static shapes to prevent one side from going to zero
                 * length.
                 * 
                 * @param {Vec2} groundAnchorA The first ground anchor in world coordinates.
                 *          This point never moves.
                 * @param {Vec2} groundAnchorB The second ground anchor in world coordinates.
                 *          This point never moves.
                 * @param {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
                 * @param {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
                 * @param {float} ratio The pulley ratio, used to simulate a block-and-tackle.
                 * 
                 * @prop {float} lengthA The reference length for the segment attached to bodyA.
                 * @prop {float} lengthB The reference length for the segment attached to bodyB.
                 */
                function PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {
                    if (!(this instanceof PulleyJoint)) {
                        return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);
                    }
                    def = options(def, PulleyJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = PulleyJoint.TYPE;
                    this.m_groundAnchorA = groundA;
                    this.m_groundAnchorB = groundB;
                    this.m_localAnchorA = bodyA.getLocalPoint(anchorA);
                    this.m_localAnchorB = bodyB.getLocalPoint(anchorB);
                    this.m_lengthA = Vec2.distance(anchorA, groundA);
                    this.m_lengthB = Vec2.distance(anchorB, groundB);
                    this.m_ratio = def.ratio || ratio;
                    //ASSERT && common.assert(ratio > Math.EPSILON);
                    this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB;
                    this.m_impulse = 0;
                    // Solver temp
                    this.m_uA;
                    // Vec2
                    this.m_uB;
                    // Vec2
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_mass;
                }

                /**
                 * Get the first ground anchor.
                 */
                PulleyJoint.prototype.getGroundAnchorA = function () {
                    return this.m_groundAnchorA;
                };

                /**
                 * Get the second ground anchor.
                 */
                PulleyJoint.prototype.getGroundAnchorB = function () {
                    return this.m_groundAnchorB;
                };

                /**
                 * Get the current length of the segment attached to bodyA.
                 */
                PulleyJoint.prototype.getLengthA = function () {
                    return this.m_lengthA;
                };

                /**
                 * Get the current length of the segment attached to bodyB.
                 */
                PulleyJoint.prototype.getLengthB = function () {
                    return this.m_lengthB;
                };

                /**
                 * Get the pulley ratio.
                 */
                PulleyJoint.prototype.setRatio = function () {
                    return this.m_ratio;
                };

                /**
                 * Get the current length of the segment attached to bodyA.
                 */
                PulleyJoint.prototype.getCurrentLengthA = function () {
                    var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                    var s = this.m_groundAnchorA;
                    return Vec2.distance(p, s);
                };

                /**
                 * Get the current length of the segment attached to bodyB.
                 */
                PulleyJoint.prototype.getCurrentLengthB = function () {
                    var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                    var s = this.m_groundAnchorB;
                    return Vec2.distance(p, s);
                };

                PulleyJoint.prototype.shiftOrigin = function (newOrigin) {
                    this.m_groundAnchorA -= newOrigin;
                    this.m_groundAnchorB -= newOrigin;
                };

                PulleyJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };

                PulleyJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                PulleyJoint.prototype.getReactionForce = function (inv_dt) {
                    return Vec3.mul(inv_dt * this.m_impulse, this.m_uB);
                };

                PulleyJoint.prototype.getReactionTorque = function (inv_dt) {
                    return 0;
                };

                PulleyJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    this.m_rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // Get the pulley axes.
                    this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);
                    this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);
                    var lengthA = this.m_uA.length();
                    var lengthB = this.m_uB.length();
                    if (lengthA > 10 * Settings.linearSlop) {
                        this.m_uA.mul(1 / lengthA);
                    } else {
                        this.m_uA.setZero();
                    }
                    if (lengthB > 10 * Settings.linearSlop) {
                        this.m_uB.mul(1 / lengthB);
                    } else {
                        this.m_uB.setZero();
                    }
                    // Compute effective mass.
                    var ruA = Vec2.cross(this.m_rA, this.m_uA);
                    // float
                    var ruB = Vec2.cross(this.m_rB, this.m_uB);
                    // float
                    var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
                    // float
                    var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
                    // float
                    this.m_mass = mA + this.m_ratio * this.m_ratio * mB;
                    if (this.m_mass > 0) {
                        this.m_mass = 1 / this.m_mass;
                    }
                    if (step.warmStarting) {
                        // Scale impulses to support variable time steps.
                        this.m_impulse *= step.dtRatio;
                        // Warm starting.
                        var PA = Vec2.mul(-this.m_impulse, this.m_uA);
                        var PB = Vec2.mul(-this.m_ratio * this.m_impulse, this.m_uB);
                        vA.wAdd(this.m_invMassA, PA);
                        wA += this.m_invIA * Vec2.cross(this.m_rA, PA);
                        vB.wAdd(this.m_invMassB, PB);
                        wB += this.m_invIB * Vec2.cross(this.m_rB, PB);
                    } else {
                        this.m_impulse = 0;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                PulleyJoint.prototype.solveVelocityConstraints = function (step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var vpA = Vec2.add(vA, Vec2.cross(wA, this.m_rA));
                    var vpB = Vec2.add(vB, Vec2.cross(wB, this.m_rB));
                    var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio * Vec2.dot(this.m_uB, vpB);
                    // float
                    var impulse = -this.m_mass * Cdot;
                    // float
                    this.m_impulse += impulse;
                    var PA = Vec2.zero().wSet(-impulse, this.m_uA);
                    // Vec2
                    var PB = Vec2.zero().wSet(-this.m_ratio * impulse, this.m_uB);
                    // Vec2
                    vA.wAdd(this.m_invMassA, PA);
                    wA += this.m_invIA * Vec2.cross(this.m_rA, PA);
                    vB.wAdd(this.m_invMassB, PB);
                    wB += this.m_invIB * Vec2.cross(this.m_rB, PB);
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                PulleyJoint.prototype.solvePositionConstraints = function (step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA),
                        qB = Rot.neo(aB);
                    var rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    var rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // Get the pulley axes.
                    var uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);
                    var uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);
                    var lengthA = uA.length();
                    var lengthB = uB.length();
                    if (lengthA > 10 * Settings.linearSlop) {
                        uA.mul(1 / lengthA);
                    } else {
                        uA.setZero();
                    }
                    if (lengthB > 10 * Settings.linearSlop) {
                        uB.mul(1 / lengthB);
                    } else {
                        uB.setZero();
                    }
                    // Compute effective mass.
                    var ruA = Vec2.cross(rA, uA);
                    var ruB = Vec2.cross(rB, uB);
                    var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
                    // float
                    var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
                    // float
                    var mass = mA + this.m_ratio * this.m_ratio * mB;
                    // float
                    if (mass > 0) {
                        mass = 1 / mass;
                    }
                    var C = this.m_constant - lengthA - this.m_ratio * lengthB;
                    // float
                    var linearError = Math.abs(C);
                    // float
                    var impulse = -mass * C;
                    // float
                    var PA = Vec2.zero().wSet(-impulse, uA);
                    // Vec2
                    var PB = Vec2.zero().wSet(-this.m_ratio * impulse, uB);
                    // Vec2
                    cA.wAdd(this.m_invMassA, PA);
                    aA += this.m_invIA * Vec2.cross(rA, PA);
                    cB.wAdd(this.m_invMassB, PB);
                    aB += this.m_invIB * Vec2.cross(rB, PB);
                    this.m_bodyA.c_position.c = cA;
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c = cB;
                    this.m_bodyB.c_position.a = aB;
                    return linearError < Settings.linearSlop;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/common": 50, "../util/create": 51, "../util/options": 52 }], 34: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = RevoluteJoint;

                var common = require("../util/common");

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                var inactiveLimit = 0;

                var atLowerLimit = 1;

                var atUpperLimit = 2;

                var equalLimits = 3;

                RevoluteJoint.TYPE = "revolute-joint";

                RevoluteJoint._super = Joint;

                RevoluteJoint.prototype = create(RevoluteJoint._super.prototype);

                /**
                 * @typedef {Object} RevoluteJointDef
                 *
                 * Revolute joint definition. This requires defining an anchor point where the
                 * bodies are joined. The definition uses local anchor points so that the
                 * initial configuration can violate the constraint slightly. You also need to
                 * specify the initial relative angle for joint limits. This helps when saving
                 * and loading a game.
                 * 
                 * The local anchor points are measured from the body's origin rather than the
                 * center of mass because: 1. you might not know where the center of mass will
                 * be. 2. if you add/remove shapes from a body and recompute the mass, the
                 * joints will be broken.
                 * 
                 * @prop {bool} enableLimit A flag to enable joint limits.
                 * @prop {bool} enableMotor A flag to enable the joint motor.
                 * @prop {float} lowerAngle The lower angle for the joint limit (radians).
                 * @prop {float} upperAngle The upper angle for the joint limit (radians).
                 * @prop {float} motorSpeed The desired motor speed. Usually in radians per
                 *       second.
                 * @prop {float} maxMotorTorque The maximum motor torque used to achieve the
                 *       desired motor speed. Usually in N-m.
                 */
                var RevoluteJointDef = {
                    lowerAngle: 0,
                    upperAngle: 0,
                    maxMotorTorque: 0,
                    motorSpeed: 0,
                    enableLimit: false,
                    enableMotor: false
                };

                /**
                 * A revolute joint constrains two bodies to share a common point while they are
                 * free to rotate about the point. The relative rotation about the shared point
                 * is the joint angle. You can limit the relative rotation with a joint limit
                 * that specifies a lower and upper angle. You can use a motor to drive the
                 * relative rotation about the shared point. A maximum motor torque is provided
                 * so that infinite forces are not generated.
                 * 
                 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
                 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
                 * @prop {float} referenceAngle The bodyB angle minus bodyA angle in the
                 *       reference state (radians).
                 */
                function RevoluteJoint(def, bodyA, bodyB, anchor) {
                    if (!(this instanceof RevoluteJoint)) {
                        return new RevoluteJoint(def, bodyA, bodyB, anchor);
                    }
                    def = options(def, RevoluteJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = RevoluteJoint.TYPE;
                    this.m_localAnchorA = def.localAnchorA || bodyA.getLocalPoint(anchor);
                    this.m_localAnchorB = def.localAnchorB || bodyB.getLocalPoint(anchor);
                    this.m_referenceAngle = bodyB.getAngle() - bodyA.getAngle();
                    this.m_impulse = Vec3();
                    this.m_motorImpulse = 0;
                    this.m_lowerAngle = def.lowerAngle;
                    this.m_upperAngle = def.upperAngle;
                    this.m_maxMotorTorque = def.maxMotorTorque;
                    this.m_motorSpeed = def.motorSpeed;
                    this.m_enableLimit = def.enableLimit;
                    this.m_enableMotor = def.enableMotor;
                    // Solver temp
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    // effective mass for point-to-point constraint.
                    this.m_mass = new Mat33();
                    // effective mass for motor/limit angular constraint.
                    this.m_motorMass;
                    // float
                    this.m_limitState = inactiveLimit;
                }

                /**
                 * The local anchor point relative to bodyA's origin.
                 */
                RevoluteJoint.prototype.getLocalAnchorA = function () {
                    return this.m_localAnchorA;
                };

                /**
                 * The local anchor point relative to bodyB's origin.
                 */
                RevoluteJoint.prototype.getLocalAnchorB = function () {
                    return this.m_localAnchorB;
                };

                /**
                 * Get the reference angle.
                 */
                RevoluteJoint.prototype.getReferenceAngle = function () {
                    return this.m_referenceAngle;
                };

                /**
                 * Get the current joint angle in radians.
                 */
                RevoluteJoint.prototype.getJointAngle = function () {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
                };

                /**
                 * Get the current joint angle speed in radians per second.
                 */
                RevoluteJoint.prototype.getJointSpeed = function () {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    return bB.m_angularVelocity - bA.m_angularVelocity;
                };

                /**
                 * Is the joint motor enabled?
                 */
                RevoluteJoint.prototype.isMotorEnabled = function () {
                    return this.m_enableMotor;
                };

                /**
                 * Enable/disable the joint motor.
                 */
                RevoluteJoint.prototype.enableMotor = function (flag) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_enableMotor = flag;
                };

                /**
                 * Get the current motor torque given the inverse time step. Unit is N*m.
                 */
                RevoluteJoint.prototype.getMotorTorque = function (inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                };

                /**
                 * Set the motor speed in radians per second.
                 */
                RevoluteJoint.prototype.setMotorSpeed = function (speed) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_motorSpeed = speed;
                };

                /**
                 * Get the motor speed in radians per second.
                 */
                RevoluteJoint.prototype.getMotorSpeed = function () {
                    return this.m_motorSpeed;
                };

                /**
                 * Set the maximum motor torque, usually in N-m.
                 */
                RevoluteJoint.prototype.setMaxMotorTorque = function (torque) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_maxMotorTorque = torque;
                };

                /**
                 * Is the joint limit enabled?
                 */
                RevoluteJoint.prototype.isLimitEnabled = function () {
                    return this.m_enableLimit;
                };

                /**
                 * Enable/disable the joint limit.
                 */
                RevoluteJoint.prototype.enableLimit = function (flag) {
                    if (flag != this.m_enableLimit) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_enableLimit = flag;
                        this.m_impulse.z = 0;
                    }
                };

                /**
                 * Get the lower joint limit in radians.
                 */
                RevoluteJoint.prototype.getLowerLimit = function () {
                    return this.m_lowerAngle;
                };

                /**
                 * Get the upper joint limit in radians.
                 */
                RevoluteJoint.prototype.getUpperLimit = function () {
                    return this.m_upperAngle;
                };

                /**
                 * Set the joint limits in radians.
                 */
                RevoluteJoint.prototype.setLimits = function (lower, upper) {
                    //ASSERT && common.assert(lower <= upper);
                    if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {
                        this.m_bodyA.setAwake(true);
                        this.m_bodyB.setAwake(true);
                        this.m_impulse.z = 0;
                        this.m_lowerAngle = lower;
                        this.m_upperAngle = upper;
                    }
                };

                RevoluteJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };

                RevoluteJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                /**
                 * Get the reaction force given the inverse time step. Unit is N.
                 */
                RevoluteJoint.prototype.getReactionForce = function (inv_dt) {
                    var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
                    return inv_dt * P;
                };

                /**
                 * Get the reaction torque due to the joint limit given the inverse time step.
                 * Unit is N*m.
                 */
                RevoluteJoint.prototype.getReactionTorque = function (inv_dt) {
                    return inv_dt * this.m_impulse.z;
                };

                RevoluteJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    this.m_rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // J = [-I -r1_skew I r2_skew]
                    // [ 0 -1 0 1]
                    // r_skew = [-ry; rx]
                    // Matlab
                    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
                    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
                    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var fixedRotation = iA + iB == 0;
                    // bool
                    this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
                    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
                    this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
                    this.m_mass.ex.y = this.m_mass.ey.x;
                    this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
                    this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
                    this.m_mass.ex.z = this.m_mass.ez.x;
                    this.m_mass.ey.z = this.m_mass.ez.y;
                    this.m_mass.ez.z = iA + iB;
                    this.m_motorMass = iA + iB;
                    if (this.m_motorMass > 0) {
                        this.m_motorMass = 1 / this.m_motorMass;
                    }
                    if (this.m_enableMotor == false || fixedRotation) {
                        this.m_motorImpulse = 0;
                    }
                    if (this.m_enableLimit && fixedRotation == false) {
                        var jointAngle = aB - aA - this.m_referenceAngle;
                        // float
                        if (Math.abs(this.m_upperAngle - this.m_lowerAngle) < 2 * Settings.angularSlop) {
                            this.m_limitState = equalLimits;
                        } else if (jointAngle <= this.m_lowerAngle) {
                            if (this.m_limitState != atLowerLimit) {
                                this.m_impulse.z = 0;
                            }
                            this.m_limitState = atLowerLimit;
                        } else if (jointAngle >= this.m_upperAngle) {
                            if (this.m_limitState != atUpperLimit) {
                                this.m_impulse.z = 0;
                            }
                            this.m_limitState = atUpperLimit;
                        } else {
                            this.m_limitState = inactiveLimit;
                            this.m_impulse.z = 0;
                        }
                    } else {
                        this.m_limitState = inactiveLimit;
                    }
                    if (step.warmStarting) {
                        // Scale impulses to support a variable time step.
                        this.m_impulse.mul(step.dtRatio);
                        this.m_motorImpulse *= step.dtRatio;
                        var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
                        vA.wSub(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);
                        vB.wAdd(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);
                    } else {
                        this.m_impulse.setZero();
                        this.m_motorImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                RevoluteJoint.prototype.solveVelocityConstraints = function (step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var fixedRotation = iA + iB == 0;
                    // bool
                    // Solve motor constraint.
                    if (this.m_enableMotor && this.m_limitState != equalLimits && fixedRotation == false) {
                        var Cdot = wB - wA - this.m_motorSpeed;
                        // float
                        var impulse = -this.m_motorMass * Cdot;
                        // float
                        var oldImpulse = this.m_motorImpulse;
                        // float
                        var maxImpulse = step.dt * this.m_maxMotorTorque;
                        // float
                        this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_motorImpulse - oldImpulse;
                        wA -= iA * impulse;
                        wB += iB * impulse;
                    }
                    // Solve limit constraint.
                    if (this.m_enableLimit && this.m_limitState != inactiveLimit && fixedRotation == false) {
                        var Cdot1 = Vec2.zero();
                        Cdot1.wAdd(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot1.wSub(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        var Cdot2 = wB - wA;
                        // float
                        var Cdot = Vec3(Cdot1.x, Cdot1.y, Cdot2);
                        var impulse = Vec3.neg(this.m_mass.solve33(Cdot));
                        // Vec3
                        if (this.m_limitState == equalLimits) {
                            this.m_impulse.add(impulse);
                        } else if (this.m_limitState == atLowerLimit) {
                            var newImpulse = this.m_impulse.z + impulse.z;
                            // float
                            if (newImpulse < 0) {
                                var rhs = Vec2.wAdd(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));
                                // Vec2
                                var reduced = this.m_mass.solve22(rhs);
                                // Vec2
                                impulse.x = reduced.x;
                                impulse.y = reduced.y;
                                impulse.z = -this.m_impulse.z;
                                this.m_impulse.x += reduced.x;
                                this.m_impulse.y += reduced.y;
                                this.m_impulse.z = 0;
                            } else {
                                this.m_impulse.add(impulse);
                            }
                        } else if (this.m_limitState == atUpperLimit) {
                            var newImpulse = this.m_impulse.z + impulse.z;
                            // float
                            if (newImpulse > 0) {
                                var rhs = Vec2.wAdd(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));
                                // Vec2
                                var reduced = this.m_mass.solve22(rhs);
                                // Vec2
                                impulse.x = reduced.x;
                                impulse.y = reduced.y;
                                impulse.z = -this.m_impulse.z;
                                this.m_impulse.x += reduced.x;
                                this.m_impulse.y += reduced.y;
                                this.m_impulse.z = 0;
                            } else {
                                this.m_impulse.add(impulse);
                            }
                        }
                        var P = Vec2.neo(impulse.x, impulse.y);
                        vA.wSub(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + impulse.z);
                        vB.wAdd(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + impulse.z);
                    } else {
                        // Solve point-to-point constraint
                        var Cdot = Vec2.zero();
                        Cdot.wAdd(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot.wSub(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        var impulse = this.m_mass.solve22(Vec2.neg(Cdot));
                        // Vec2
                        this.m_impulse.x += impulse.x;
                        this.m_impulse.y += impulse.y;
                        vA.wSub(mA, impulse);
                        wA -= iA * Vec2.cross(this.m_rA, impulse);
                        vB.wAdd(mB, impulse);
                        wB += iB * Vec2.cross(this.m_rB, impulse);
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                RevoluteJoint.prototype.solvePositionConstraints = function (step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var angularError = 0;
                    // float
                    var positionError = 0;
                    // float
                    var fixedRotation = this.m_invIA + this.m_invIB == 0;
                    // bool
                    // Solve angular limit constraint.
                    if (this.m_enableLimit && this.m_limitState != inactiveLimit && fixedRotation == false) {
                        var angle = aB - aA - this.m_referenceAngle;
                        // float
                        var limitImpulse = 0;
                        // float
                        if (this.m_limitState == equalLimits) {
                            // Prevent large angular corrections
                            var C = Math.clamp(angle - this.m_lowerAngle, -Settings.maxAngularCorrection, Settings.maxAngularCorrection);
                            // float
                            limitImpulse = -this.m_motorMass * C;
                            angularError = Math.abs(C);
                        } else if (this.m_limitState == atLowerLimit) {
                            var C = angle - this.m_lowerAngle;
                            // float
                            angularError = -C;
                            // Prevent large angular corrections and allow some slop.
                            C = Math.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection, 0);
                            limitImpulse = -this.m_motorMass * C;
                        } else if (this.m_limitState == atUpperLimit) {
                            var C = angle - this.m_upperAngle;
                            // float
                            angularError = C;
                            // Prevent large angular corrections and allow some slop.
                            C = Math.clamp(C - Settings.angularSlop, 0, Settings.maxAngularCorrection);
                            limitImpulse = -this.m_motorMass * C;
                        }
                        aA -= this.m_invIA * limitImpulse;
                        aB += this.m_invIB * limitImpulse;
                    }
                    // Solve point-to-point constraint.
                    {
                        qA.set(aA);
                        qB.set(aB);
                        var rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                        // Vec2
                        var rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                        // Vec2
                        var C = Vec2.zero();
                        C.wAdd(1, cB, 1, rB);
                        C.wSub(1, cA, 1, rA);
                        positionError = C.length();
                        var mA = this.m_invMassA;
                        var mB = this.m_invMassB;
                        // float
                        var iA = this.m_invIA;
                        var iB = this.m_invIB;
                        // float
                        var K = new Mat22();
                        K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
                        K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
                        K.ey.x = K.ex.y;
                        K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
                        var impulse = Vec2.neg(K.solve(C));
                        // Vec2
                        cA.wSub(mA, impulse);
                        aA -= iA * Vec2.cross(rA, impulse);
                        cB.wAdd(mB, impulse);
                        aB += iB * Vec2.cross(rB, impulse);
                    }
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/common": 50, "../util/create": 51, "../util/options": 52 }], 35: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = RopeJoint;

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                var inactiveLimit = 0;

                var atLowerLimit = 1;

                var atUpperLimit = 2;

                var equalLimits = 3;

                RopeJoint.TYPE = "rope-joint";

                RopeJoint._super = Joint;

                RopeJoint.prototype = create(RopeJoint._super.prototype);

                /**
                 * @typedef {Object} RopeJointDef
                 *
                 * Rope joint definition. This requires two body anchor points and a maximum
                 * lengths. Note: by default the connected objects will not collide. see
                 * collideConnected in JointDef.
                 * 
                 * @prop {float} maxLength The maximum length of the rope. Warning: this must be
                 *       larger than linearSlop or the joint will have no effect.
                 */
                var RopeJointDef = {
                    maxLength: 0
                };

                /**
                 * A rope joint enforces a maximum distance between two points on two bodies. It
                 * has no other effect.
                 * 
                 * Warning: if you attempt to change the maximum length during the simulation
                 * you will get some non-physical behavior.
                 * 
                 * A model that would allow you to dynamically modify the length would have some
                 * sponginess, so I chose not to implement it that way. See DistanceJoint if you
                 * want to dynamically control length.
                 * 
                 * @prop {Vec2} def.localAnchorA The local anchor point relative to bodyA's origin.
                 * @prop {Vec2} def.localAnchorB The local anchor point relative to bodyB's origin.
                 */
                function RopeJoint(def, bodyA, bodyB, anchor) {
                    if (!(this instanceof RopeJoint)) {
                        return new RopeJoint(def, bodyA, bodyB, anchor);
                    }
                    def = options(def, RopeJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = RopeJoint.TYPE;
                    this.m_localAnchorA = def.localAnchorA || bodyA.getLocalPoint(anchor);
                    this.m_localAnchorB = def.localAnchorB || bodyB.getLocalPoint(anchor);
                    this.m_maxLength = def.maxLength;
                    this.m_mass = 0;
                    this.m_impulse = 0;
                    this.m_length = 0;
                    this.m_state = inactiveLimit;
                    // Solver temp
                    this.m_u;
                    // Vec2
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_mass;
                }

                /**
                 * The local anchor point relative to bodyA's origin.
                 */
                RopeJoint.prototype.getLocalAnchorA = function () {
                    return this.m_localAnchorA;
                };

                /**
                 * The local anchor point relative to bodyB's origin.
                 */
                RopeJoint.prototype.getLocalAnchorB = function () {
                    return this.m_localAnchorB;
                };

                /**
                 * Set/Get the maximum length of the rope.
                 */
                RopeJoint.prototype.setMaxLength = function (length) {
                    this.m_maxLength = length;
                };

                RopeJoint.prototype.getMaxLength = function () {
                    return this.m_maxLength;
                };

                RopeJoint.prototype.getLimitState = function () {
                    // TODO LimitState
                    return this.m_state;
                };

                RopeJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };

                RopeJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                RopeJoint.prototype.getReactionForce = function (inv_dt) {
                    var F = inv_dt * this.m_impulse * this.m_u;
                    // Vec2
                    return F;
                };

                RopeJoint.prototype.getReactionTorque = function (inv_dt) {
                    return 0;
                };

                RopeJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
                    this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
                    this.m_u = Vec2.zero();
                    this.m_u.wAdd(1, cB, 1, this.m_rB);
                    this.m_u.wSub(1, cA, 1, this.m_rA);
                    // Vec2
                    this.m_length = this.m_u.length();
                    var C = this.m_length - this.m_maxLength;
                    // float
                    if (C > 0) {
                        this.m_state = atUpperLimit;
                    } else {
                        this.m_state = inactiveLimit;
                    }
                    if (this.m_length > Settings.linearSlop) {
                        this.m_u.mul(1 / this.m_length);
                    } else {
                        this.m_u.setZero();
                        this.m_mass = 0;
                        this.m_impulse = 0;
                        return;
                    }
                    // Compute effective mass.
                    var crA = Vec2.cross(this.m_rA, this.m_u);
                    // float
                    var crB = Vec2.cross(this.m_rB, this.m_u);
                    // float
                    var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;
                    // float
                    this.m_mass = invMass != 0 ? 1 / invMass : 0;
                    if (step.warmStarting) {
                        // Scale the impulse to support a variable time step.
                        this.m_impulse *= step.dtRatio;
                        var P = Vec2.mul(this.m_impulse, this.m_u);
                        vA.wSub(this.m_invMassA, P);
                        wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
                        vB.wAdd(this.m_invMassB, P);
                        wB += this.m_invIB * Vec2.cross(this.m_rB, P);
                    } else {
                        this.m_impulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };

                RopeJoint.prototype.solveVelocityConstraints = function (step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    // Cdot = dot(u, v + cross(w, r))
                    var vpA = Vec2.addCross(vA, wA, this.m_rA);
                    // Vec2
                    var vpB = Vec2.addCross(vB, wB, this.m_rB);
                    // Vec2
                    var C = this.m_length - this.m_maxLength;
                    // float
                    var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA));
                    // float
                    // Predictive constraint.
                    if (C < 0) {
                        Cdot += step.inv_dt * C;
                    }
                    var impulse = -this.m_mass * Cdot;
                    // float
                    var oldImpulse = this.m_impulse;
                    // float
                    this.m_impulse = Math.min(0, this.m_impulse + impulse);
                    impulse = this.m_impulse - oldImpulse;
                    var P = Vec2.mul(impulse, this.m_u);
                    // Vec2
                    vA.wSub(this.m_invMassA, P);
                    wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
                    vB.wAdd(this.m_invMassB, P);
                    wB += this.m_invIB * Vec2.cross(this.m_rB, P);
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                RopeJoint.prototype.solvePositionConstraints = function (step) {
                    var cA = this.m_bodyA.c_position.c;
                    // Vec2
                    var aA = this.m_bodyA.c_position.a;
                    // float
                    var cB = this.m_bodyB.c_position.c;
                    // Vec2
                    var aB = this.m_bodyB.c_position.a;
                    // float
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
                    var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
                    var u = Vec2.zero();
                    u.wAdd(1, cB, 1, rB);
                    u.wSub(1, cA, 1, rA);
                    // Vec2
                    var length = u.normalize();
                    // float
                    var C = length - this.m_maxLength;
                    // float
                    C = Math.clamp(C, 0, Settings.maxLinearCorrection);
                    var impulse = -this.m_mass * C;
                    // float
                    var P = Vec2.mul(impulse, u);
                    // Vec2
                    cA.wSub(this.m_invMassA, P);
                    aA -= this.m_invIA * Vec2.cross(rA, P);
                    cB.wAdd(this.m_invMassB, P);
                    aB += this.m_invIB * Vec2.cross(rB, P);
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    return length - this.m_maxLength < Settings.linearSlop;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/create": 51, "../util/options": 52 }], 36: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = WeldJoint;

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                WeldJoint.TYPE = "weld-joint";

                WeldJoint._super = Joint;

                WeldJoint.prototype = create(WeldJoint._super.prototype);

                /**
                 * @typedef {Object} WeldJointDef
                 *
                 * Weld joint definition. You need to specify local anchor points where they are
                 * attached and the relative body angle. The position of the anchor points is
                 * important for computing the reaction torque.
                 * 
                 * @prop {float} frequencyHz The mass-spring-damper frequency in Hertz. Rotation
                 *       only. Disable softness with a value of 0.
                 * @prop {float} dampingRatio The damping ratio. 0 = no damping, 1 = critical
                 *       damping.
                 */
                var WeldJointDef = {
                    frequencyHz: 0,
                    dampingRatio: 0
                };

                /**
                 * A weld joint essentially glues two bodies together. A weld joint may distort
                 * somewhat because the island constraint solver is approximate.
                 * 
                 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
                 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
                 * @prop {float} referenceAngle The bodyB angle minus bodyA angle in the
                 *       reference state (radians).
                 */
                function WeldJoint(def, bodyA, bodyB, anchor) {
                    if (!(this instanceof WeldJoint)) {
                        return new WeldJoint(def, bodyA, bodyB, anchor);
                    }
                    def = options(def, WeldJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = WeldJoint.TYPE;
                    this.m_localAnchorA = bodyA.getLocalPoint(anchor);
                    this.m_localAnchorB = bodyB.getLocalPoint(anchor);
                    this.m_referenceAngle = bodyB.getAngle() - bodyA.getAngle();
                    this.m_frequencyHz = def.frequencyHz;
                    this.m_dampingRatio = def.dampingRatio;
                    this.m_impulse = Vec3();
                    this.m_bias = 0;
                    this.m_gamma = 0;
                    // Solver temp
                    this.m_rA;
                    // Vec2
                    this.m_rB;
                    // Vec2
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_mass = new Mat33();
                }

                /**
                 * The local anchor point relative to bodyA's origin.
                 */
                WeldJoint.prototype.getLocalAnchorA = function () {
                    return this.m_localAnchorA;
                };

                /**
                 * The local anchor point relative to bodyB's origin.
                 */
                WeldJoint.prototype.getLocalAnchorB = function () {
                    return this.m_localAnchorB;
                };

                /**
                 * Get the reference angle.
                 */
                WeldJoint.prototype.getReferenceAngle = function () {
                    return this.m_referenceAngle;
                };

                /**
                 * Set/get frequency in Hz.
                 */
                WeldJoint.prototype.setFrequency = function (hz) {
                    this.m_frequencyHz = hz;
                };

                WeldJoint.prototype.getFrequency = function () {
                    return this.m_frequencyHz;
                };

                /**
                 * Set/get damping ratio.
                 */
                WeldJoint.prototype.setDampingRatio = function (ratio) {
                    this.m_dampingRatio = ratio;
                };

                WeldJoint.prototype.getDampingRatio = function () {
                    return this.m_dampingRatio;
                };

                WeldJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };

                WeldJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                WeldJoint.prototype.getReactionForce = function (inv_dt) {
                    var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
                    return inv_dt * P;
                };

                WeldJoint.prototype.getReactionTorque = function (inv_dt) {
                    return inv_dt * this.m_impulse.z;
                };

                WeldJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA),
                        qB = Rot.neo(aB);
                    this.m_rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // J = [-I -r1_skew I r2_skew]
                    // [ 0 -1 0 1]
                    // r_skew = [-ry; rx]
                    // Matlab
                    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
                    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
                    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var K = new Mat33();
                    K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
                    K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
                    K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
                    K.ex.y = K.ey.x;
                    K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
                    K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
                    K.ex.z = K.ez.x;
                    K.ey.z = K.ez.y;
                    K.ez.z = iA + iB;
                    if (this.m_frequencyHz > 0) {
                        K.getInverse22(this.m_mass);
                        var invM = iA + iB;
                        // float
                        var m = invM > 0 ? 1 / invM : 0;
                        // float
                        var C = aB - aA - this.m_referenceAngle;
                        // float
                        // Frequency
                        var omega = 2 * Math.PI * this.m_frequencyHz;
                        // float
                        // Damping coefficient
                        var d = 2 * m * this.m_dampingRatio * omega;
                        // float
                        // Spring stiffness
                        var k = m * omega * omega;
                        // float
                        // magic formulas
                        var h = step.dt;
                        // float
                        this.m_gamma = h * (d + h * k);
                        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
                        this.m_bias = C * h * k * this.m_gamma;
                        invM += this.m_gamma;
                        this.m_mass.ez.z = invM != 0 ? 1 / invM : 0;
                    } else if (K.ez.z == 0) {
                        K.getInverse22(this.m_mass);
                        this.m_gamma = 0;
                        this.m_bias = 0;
                    } else {
                        K.getSymInverse33(this.m_mass);
                        this.m_gamma = 0;
                        this.m_bias = 0;
                    }
                    if (step.warmStarting) {
                        // Scale impulses to support a variable time step.
                        this.m_impulse.mul(step.dtRatio);
                        var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
                        vA.wSub(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_impulse.z);
                        vB.wAdd(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + this.m_impulse.z);
                    } else {
                        this.m_impulse.setZero();
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                WeldJoint.prototype.solveVelocityConstraints = function (step) {
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    if (this.m_frequencyHz > 0) {
                        var Cdot2 = wB - wA;
                        // float
                        var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);
                        // float
                        this.m_impulse.z += impulse2;
                        wA -= iA * impulse2;
                        wB += iB * impulse2;
                        var Cdot1 = Vec2.zero();
                        Cdot1.wAdd(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot1.wSub(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        // Vec2
                        var impulse1 = Vec2.neg(Mat33.mul(this.m_mass, Cdot1));
                        // Vec2
                        this.m_impulse.x += impulse1.x;
                        this.m_impulse.y += impulse1.y;
                        var P = Vec2.clone(impulse1);
                        // Vec2
                        vA.wSub(mA, P);
                        wA -= iA * Vec2.cross(this.m_rA, P);
                        vB.wAdd(mB, P);
                        wB += iB * Vec2.cross(this.m_rB, P);
                    } else {
                        var Cdot1 = Vec2.zero();
                        Cdot1.wAdd(1, vB, 1, Vec2.cross(wB, this.m_rB));
                        Cdot1.wSub(1, vA, 1, Vec2.cross(wA, this.m_rA));
                        // Vec2
                        var Cdot2 = wB - wA;
                        // float
                        var Cdot = Vec3(Cdot1.x, Cdot1.y, Cdot2);
                        // Vec3
                        var impulse = Vec3.neg(Mat33.mul(this.m_mass, Cdot));
                        // Vec3
                        this.m_impulse.add(impulse);
                        var P = Vec2.neo(impulse.x, impulse.y);
                        vA.wSub(mA, P);
                        wA -= iA * (Vec2.cross(this.m_rA, P) + impulse.z);
                        vB.wAdd(mB, P);
                        wB += iB * (Vec2.cross(this.m_rB, P) + impulse.z);
                    }
                    this.m_bodyA.c_velocity.v = vA;
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v = vB;
                    this.m_bodyB.c_velocity.w = wB;
                };

                WeldJoint.prototype.solvePositionConstraints = function (step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA),
                        qB = Rot.neo(aB);
                    var mA = this.m_invMassA,
                        mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA,
                        iB = this.m_invIB;
                    // float
                    var rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    var rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    var positionError, angularError;
                    // float
                    var K = new Mat33();
                    K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
                    K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
                    K.ez.x = -rA.y * iA - rB.y * iB;
                    K.ex.y = K.ey.x;
                    K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
                    K.ez.y = rA.x * iA + rB.x * iB;
                    K.ex.z = K.ez.x;
                    K.ey.z = K.ez.y;
                    K.ez.z = iA + iB;
                    if (this.m_frequencyHz > 0) {
                        var C1 = Vec2.zero();
                        C1.wAdd(1, cB, 1, rB);
                        C1.wSub(1, cA, 1, rA);
                        // Vec2
                        positionError = C1.length();
                        angularError = 0;
                        var P = Vec2.neg(K.solve22(C1));
                        // Vec2
                        cA.wSub(mA, P);
                        aA -= iA * Vec2.cross(rA, P);
                        cB.wAdd(mB, P);
                        aB += iB * Vec2.cross(rB, P);
                    } else {
                        var C1 = Vec2.zero();
                        C1.wAdd(1, cB, 1, rB);
                        C1.wSub(1, cA, 1, rA);
                        var C2 = aB - aA - this.m_referenceAngle;
                        // float
                        positionError = C1.length();
                        angularError = Math.abs(C2);
                        var C = Vec3(C1.x, C1.y, C2);
                        var impulse = Vec3();
                        if (K.ez.z > 0) {
                            impulse = Vec3.neg(K.solve33(C));
                        } else {
                            var impulse2 = Vec2.neg(K.solve22(C1));
                            impulse.set(impulse2.x, impulse2.y, 0);
                        }
                        var P = Vec2.neo(impulse.x, impulse.y);
                        cA.wSub(mA, P);
                        aA -= iA * (Vec2.cross(rA, P) + impulse.z);
                        cB.wAdd(mB, P);
                        aB += iB * (Vec2.cross(rB, P) + impulse.z);
                    }
                    this.m_bodyA.c_position.c = cA;
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c = cB;
                    this.m_bodyB.c_position.a = aB;
                    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/create": 51, "../util/options": 52 }], 37: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = WheelJoint;

                var options = require("../util/options");

                var create = require("../util/create");

                var Settings = require("../Settings");

                var Math = require("../common/Math");

                var Vec2 = require("../common/Vec2");

                var Vec3 = require("../common/Vec3");

                var Mat22 = require("../common/Mat22");

                var Mat33 = require("../common/Mat33");

                var Rot = require("../common/Rot");

                var Sweep = require("../common/Sweep");

                var Transform = require("../common/Transform");

                var Velocity = require("../common/Velocity");

                var Position = require("../common/Position");

                var Joint = require("../Joint");

                WheelJoint.TYPE = "wheel-joint";

                WheelJoint._super = Joint;

                WheelJoint.prototype = create(WheelJoint._super.prototype);

                /**
                 * @typedef {Object} WheelJointDef
                 *
                 * Wheel joint definition. This requires defining a line of motion using an axis
                 * and an anchor point. The definition uses local anchor points and a local axis
                 * so that the initial configuration can violate the constraint slightly. The
                 * joint translation is zero when the local anchor points coincide in world
                 * space. Using local anchors and a local axis helps when saving and loading a
                 * game.
                 * 
                 * @prop {boolean} enableMotor Enable/disable the joint motor.
                 * @prop {float} maxMotorTorque The maximum motor torque, usually in N-m.
                 * @prop {float} motorSpeed The desired motor speed in radians per second.
                 * @prop {float} frequencyHz Suspension frequency, zero indicates no suspension
                 * @prop {float} dampingRatio Suspension damping ratio, one indicates critical
                 *       damping
                 */
                var WheelJointDef = {
                    enableMotor: false,
                    maxMotorTorque: 0,
                    motorSpeed: 0,
                    frequencyHz: 2,
                    dampingRatio: .7
                };

                /**
                 * A wheel joint. This joint provides two degrees of freedom: translation along
                 * an axis fixed in bodyA and rotation in the plane. In other words, it is a
                 * point to line constraint with a rotational motor and a linear spring/damper.
                 * This joint is designed for vehicle suspensions.
                 * 
                 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
                 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
                 * @prop {Vec2} localAxisA The local translation axis in bodyA.
                 */
                function WheelJoint(def, bodyA, bodyB, anchor, axis) {
                    if (!(this instanceof WheelJoint)) {
                        return new WheelJoint(def, bodyA, bodyB, anchor, axis);
                    }
                    def = options(def, WheelJointDef);
                    Joint.call(this, def, bodyA, bodyB);
                    this.m_type = WheelJoint.TYPE;
                    this.m_localAnchorA = bodyA.getLocalPoint(anchor);
                    this.m_localAnchorB = bodyB.getLocalPoint(anchor);
                    this.m_localXAxisA = bodyA.getLocalVector(axis || Vec2.neo(1, 0));
                    this.m_localYAxisA = Vec2.cross(1, this.m_localXAxisA);
                    this.m_mass = 0;
                    this.m_impulse = 0;
                    this.m_motorMass = 0;
                    this.m_motorImpulse = 0;
                    this.m_springMass = 0;
                    this.m_springImpulse = 0;
                    this.m_maxMotorTorque = def.maxMotorTorque;
                    this.m_motorSpeed = def.motorSpeed;
                    this.m_enableMotor = def.enableMotor;
                    this.m_frequencyHz = def.frequencyHz;
                    this.m_dampingRatio = def.dampingRatio;
                    this.m_bias = 0;
                    this.m_gamma = 0;
                    // Solver temp
                    this.m_localCenterA;
                    // Vec2
                    this.m_localCenterB;
                    // Vec2
                    this.m_invMassA;
                    // float
                    this.m_invMassB;
                    // float
                    this.m_invIA;
                    // float
                    this.m_invIB;
                    // float
                    this.m_ax = Vec2.zero();
                    this.m_ay = Vec2.zero();
                    // Vec2
                    this.m_sAx;
                    this.m_sBx;
                    // float
                    this.m_sAy;
                    this.m_sBy;
                }

                /**
                 * The local anchor point relative to bodyA's origin.
                 */
                WheelJoint.prototype.getLocalAnchorA = function () {
                    return this.m_localAnchorA;
                };

                /**
                 * The local anchor point relative to bodyB's origin.
                 */
                WheelJoint.prototype.getLocalAnchorB = function () {
                    return this.m_localAnchorB;
                };

                /**
                 * The local joint axis relative to bodyA.
                 */
                WheelJoint.prototype.getLocalAxisA = function () {
                    return this.m_localXAxisA;
                };

                /**
                 * Get the current joint translation, usually in meters.
                 */
                WheelJoint.prototype.getJointTranslation = function () {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    var pA = bA.getWorldPoint(this.m_localAnchorA);
                    // Vec2
                    var pB = bB.getWorldPoint(this.m_localAnchorB);
                    // Vec2
                    var d = pB - pA;
                    // Vec2
                    var axis = bA.getWorldVector(this.m_localXAxisA);
                    // Vec2
                    var translation = Dot(d, axis);
                    // float
                    return translation;
                };

                /**
                 * Get the current joint translation speed, usually in meters per second.
                 */
                WheelJoint.prototype.getJointSpeed = function () {
                    var wA = this.m_bodyA.m_angularVelocity;
                    var wB = this.m_bodyB.m_angularVelocity;
                    return wB - wA;
                };

                /**
                 * Is the joint motor enabled?
                 */
                WheelJoint.prototype.isMotorEnabled = function () {
                    return this.m_enableMotor;
                };

                /**
                 * Enable/disable the joint motor.
                 */
                WheelJoint.prototype.enableMotor = function (flag) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_enableMotor = flag;
                };

                /**
                 * Set the motor speed, usually in radians per second.
                 */
                WheelJoint.prototype.setMotorSpeed = function (speed) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_motorSpeed = speed;
                };

                /**
                 * Get the motor speed, usually in radians per second.
                 */
                WheelJoint.prototype.getMotorSpeed = function () {
                    return this.m_motorSpeed;
                };

                /**
                 * Set/Get the maximum motor force, usually in N-m.
                 */
                WheelJoint.prototype.setMaxMotorTorque = function (torque) {
                    this.m_bodyA.setAwake(true);
                    this.m_bodyB.setAwake(true);
                    this.m_maxMotorTorque = torque;
                };

                WheelJoint.prototype.getMaxMotorTorque = function () {
                    return this.m_maxMotorTorque;
                };

                /**
                 * Get the current motor torque given the inverse time step, usually in N-m.
                 */
                WheelJoint.prototype.getMotorTorque = function (inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                };

                /**
                 * Set/Get the spring frequency in hertz. Setting the frequency to zero disables
                 * the spring.
                 */
                WheelJoint.prototype.setSpringFrequencyHz = function (hz) {
                    this.m_frequencyHz = hz;
                };

                WheelJoint.prototype.getSpringFrequencyHz = function () {
                    return this.m_frequencyHz;
                };

                /**
                 * Set/Get the spring damping ratio
                 */
                WheelJoint.prototype.setSpringDampingRatio = function (ratio) {
                    this.m_dampingRatio = ratio;
                };

                WheelJoint.prototype.getSpringDampingRatio = function () {
                    return this.m_dampingRatio;
                };

                WheelJoint.prototype.getAnchorA = function () {
                    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
                };

                WheelJoint.prototype.getAnchorB = function () {
                    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
                };

                WheelJoint.prototype.getReactionForce = function (inv_dt) {
                    return inv_dt * (this.m_impulse * this.m_ay + this.m_springImpulse * this.m_ax);
                };

                WheelJoint.prototype.getReactionTorque = function (inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                };

                WheelJoint.prototype.initVelocityConstraints = function (step) {
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    // Compute the effective masses.
                    var rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    // Vec2
                    var rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // Vec2
                    var d = Vec2.zero();
                    d.wAdd(1, cB, 1, rB);
                    d.wSub(1, cA, 1, rA);
                    // Vec2
                    // Point to line constraint
                    {
                        this.m_ay = Rot.mul(qA, this.m_localYAxisA);
                        this.m_sAy = Vec2.cross(Vec2.add(d, rA), this.m_ay);
                        this.m_sBy = Vec2.cross(rB, this.m_ay);
                        this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;
                        if (this.m_mass > 0) {
                            this.m_mass = 1 / this.m_mass;
                        }
                    }
                    // Spring constraint
                    this.m_springMass = 0;
                    this.m_bias = 0;
                    this.m_gamma = 0;
                    if (this.m_frequencyHz > 0) {
                        this.m_ax = Rot.mul(qA, this.m_localXAxisA);
                        this.m_sAx = Vec2.cross(Vec2.add(d, rA), this.m_ax);
                        this.m_sBx = Vec2.cross(rB, this.m_ax);
                        var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;
                        // float
                        if (invMass > 0) {
                            this.m_springMass = 1 / invMass;
                            var C = Vec2.dot(d, this.m_ax);
                            // float
                            // Frequency
                            var omega = 2 * Math.PI * this.m_frequencyHz;
                            // float
                            // Damping coefficient
                            var d = 2 * this.m_springMass * this.m_dampingRatio * omega;
                            // float
                            // Spring stiffness
                            var k = this.m_springMass * omega * omega;
                            // float
                            // magic formulas
                            var h = step.dt;
                            // float
                            this.m_gamma = h * (d + h * k);
                            if (this.m_gamma > 0) {
                                this.m_gamma = 1 / this.m_gamma;
                            }
                            this.m_bias = C * h * k * this.m_gamma;
                            this.m_springMass = invMass + this.m_gamma;
                            if (this.m_springMass > 0) {
                                this.m_springMass = 1 / this.m_springMass;
                            }
                        }
                    } else {
                        this.m_springImpulse = 0;
                    }
                    // Rotational motor
                    if (this.m_enableMotor) {
                        this.m_motorMass = iA + iB;
                        if (this.m_motorMass > 0) {
                            this.m_motorMass = 1 / this.m_motorMass;
                        }
                    } else {
                        this.m_motorMass = 0;
                        this.m_motorImpulse = 0;
                    }
                    if (step.warmStarting) {
                        // Account for variable time step.
                        this.m_impulse *= step.dtRatio;
                        this.m_springImpulse *= step.dtRatio;
                        this.m_motorImpulse *= step.dtRatio;
                        var P = Vec2.wAdd(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);
                        var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
                        var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
                        vA.wSub(this.m_invMassA, P);
                        wA -= this.m_invIA * LA;
                        vB.wAdd(this.m_invMassB, P);
                        wB += this.m_invIB * LB;
                    } else {
                        this.m_impulse = 0;
                        this.m_springImpulse = 0;
                        this.m_motorImpulse = 0;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };

                WheelJoint.prototype.solveVelocityConstraints = function (step) {
                    var mA = this.m_invMassA;
                    var mB = this.m_invMassB;
                    // float
                    var iA = this.m_invIA;
                    var iB = this.m_invIB;
                    // float
                    var vA = this.m_bodyA.c_velocity.v;
                    var wA = this.m_bodyA.c_velocity.w;
                    var vB = this.m_bodyB.c_velocity.v;
                    var wB = this.m_bodyB.c_velocity.w;
                    // Solve spring constraint
                    {
                        var Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx * wB - this.m_sAx * wA;
                        // float
                        var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);
                        // float
                        this.m_springImpulse += impulse;
                        var P = Vec2.zero().wSet(impulse, this.m_ax);
                        // Vec2
                        var LA = impulse * this.m_sAx;
                        // float
                        var LB = impulse * this.m_sBx;
                        // float
                        vA.wSub(mA, P);
                        wA -= iA * LA;
                        vB.wAdd(mB, P);
                        wB += iB * LB;
                    }
                    // Solve rotational motor constraint
                    {
                        var Cdot = wB - wA - this.m_motorSpeed;
                        // float
                        var impulse = -this.m_motorMass * Cdot;
                        // float
                        var oldImpulse = this.m_motorImpulse;
                        // float
                        var maxImpulse = step.dt * this.m_maxMotorTorque;
                        // float
                        this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_motorImpulse - oldImpulse;
                        wA -= iA * impulse;
                        wB += iB * impulse;
                    }
                    // Solve point to line constraint
                    {
                        var Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy * wB - this.m_sAy * wA;
                        // float
                        var impulse = -this.m_mass * Cdot;
                        // float
                        this.m_impulse += impulse;
                        var P = Vec2.zero().wSet(impulse, this.m_ay);
                        // Vec2
                        var LA = impulse * this.m_sAy;
                        // float
                        var LB = impulse * this.m_sBy;
                        // float
                        vA.wSub(mA, P);
                        wA -= iA * LA;
                        vB.wAdd(mB, P);
                        wB += iB * LB;
                    }
                    this.m_bodyA.c_velocity.v.set(vA);
                    this.m_bodyA.c_velocity.w = wA;
                    this.m_bodyB.c_velocity.v.set(vB);
                    this.m_bodyB.c_velocity.w = wB;
                };

                WheelJoint.prototype.solvePositionConstraints = function (step) {
                    var cA = this.m_bodyA.c_position.c;
                    var aA = this.m_bodyA.c_position.a;
                    var cB = this.m_bodyB.c_position.c;
                    var aB = this.m_bodyB.c_position.a;
                    var qA = Rot.neo(aA);
                    var qB = Rot.neo(aB);
                    var rA = Rot.mul(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                    // Vec2
                    var rB = Rot.mul(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                    // Vec2
                    var d = Vec2.zero();
                    d.wAdd(1, cB, 1, rB);
                    d.wSub(1, cA, 1, rA);
                    // Vec2
                    var ay = Rot.mul(qA, this.m_localYAxisA);
                    // Vec2
                    var sAy = Vec2.cross(Vec2.sub(d, rA), ay);
                    // float
                    var sBy = Vec2.cross(rB, ay);
                    // float
                    var C = Vec2.dot(d, ay);
                    // float
                    var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
                    // float
                    var impulse;
                    // float
                    if (k != 0) {
                        impulse = -C / k;
                    } else {
                        impulse = 0;
                    }
                    var P = Vec2.zero().wSet(impulse, ay);
                    // Vec2
                    var LA = impulse * sAy;
                    // float
                    var LB = impulse * sBy;
                    // float
                    cA.wSub(this.m_invMassA, P);
                    aA -= this.m_invIA * LA;
                    cB.wAdd(this.m_invMassB, P);
                    aB += this.m_invIB * LB;
                    this.m_bodyA.c_position.c.set(cA);
                    this.m_bodyA.c_position.a = aA;
                    this.m_bodyB.c_position.c.set(cB);
                    this.m_bodyB.c_position.a = aB;
                    return Math.abs(C) <= Settings.linearSlop;
                };
            }, { "../Joint": 5, "../Settings": 7, "../common/Mat22": 16, "../common/Mat33": 17, "../common/Math": 18, "../common/Position": 19, "../common/Rot": 20, "../common/Sweep": 21, "../common/Transform": 22, "../common/Vec2": 23, "../common/Vec3": 24, "../common/Velocity": 25, "../util/create": 51, "../util/options": 52 }], 38: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = BoxShape;

                var common = require("../util/common");

                var create = require("../util/create");

                var options = require("../util/options");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Rot = require("../common/Rot");

                var Vec2 = require("../common/Vec2");

                var AABB = require("../collision/AABB");

                var Settings = require("../Settings");

                var PolygonShape = require("./PolygonShape");

                BoxShape._super = PolygonShape;

                BoxShape.prototype = create(BoxShape._super.prototype);

                BoxShape.TYPE = "polygon";

                /**
                 * A rectangle polygon which extend PolygonShape.
                 */
                function BoxShape(hx, hy, center, angle) {
                    if (!(this instanceof BoxShape)) {
                        return new BoxShape(hx, hy, center, angle);
                    }
                    BoxShape._super.call(this);
                    this.m_vertices[0] = Vec2.neo(-hx, -hy);
                    this.m_vertices[1] = Vec2.neo(hx, -hy);
                    this.m_vertices[2] = Vec2.neo(hx, hy);
                    this.m_vertices[3] = Vec2.neo(-hx, hy);
                    this.m_normals[0] = Vec2.neo(0, -1);
                    this.m_normals[1] = Vec2.neo(1, 0);
                    this.m_normals[2] = Vec2.neo(0, 1);
                    this.m_normals[3] = Vec2.neo(-1, 0);
                    this.m_count = 4;
                    if (center && "x" in center && "y" in center) {
                        angle = angle || 0;
                        this.m_centroid.set(center);
                        var xf = Transform.identity();
                        xf.p.set(center);
                        xf.q.set(angle);
                        // Transform vertices and normals.
                        for (var i = 0; i < this.m_count; ++i) {
                            this.m_vertices[i] = Transform.mul(xf, this.m_vertices[i]);
                            this.m_normals[i] = Rot.mul(xf.q, this.m_normals[i]);
                        }
                    }
                }
            }, { "../Settings": 7, "../collision/AABB": 11, "../common/Math": 18, "../common/Rot": 20, "../common/Transform": 22, "../common/Vec2": 23, "../util/common": 50, "../util/create": 51, "../util/options": 52, "./PolygonShape": 47 }], 39: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = ChainShape;

                var common = require("../util/common");

                var create = require("../util/create");

                var options = require("../util/options");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Rot = require("../common/Rot");

                var Vec2 = require("../common/Vec2");

                var AABB = require("../collision/AABB");

                var Settings = require("../Settings");

                var Shape = require("../Shape");

                var EdgeShape = require("./EdgeShape");

                ChainShape._super = Shape;

                ChainShape.prototype = create(ChainShape._super.prototype);

                ChainShape.TYPE = "chain";

                /**
                 * A chain shape is a free form sequence of line segments. The chain has
                 * two-sided collision, so you can use inside and outside collision. Therefore,
                 * you may use any winding order. Connectivity information is used to create
                 * smooth collisions.
                 * 
                 * WARNING: The chain will not collide properly if there are self-intersections.
                 */
                function ChainShape(vertices, loop) {
                    if (!(this instanceof ChainShape)) {
                        return new ChainShape(vertices, loop);
                    }
                    ChainShape._super.call(this);
                    this.m_type = ChainShape.TYPE;
                    this.m_radius = Settings.polygonRadius;
                    this.m_vertices = [];
                    this.m_count = 0;
                    this.m_prevVertex = null;
                    this.m_nextVertex = null;
                    this.m_hasPrevVertex = false;
                    this.m_hasNextVertex = false;
                    if (vertices && vertices.length) {
                        if (loop) {
                            this._createLoop(vertices);
                        } else {
                            this._createChain(vertices);
                        }
                    }
                }

                // ChainShape.clear = function() {
                // this.m_vertices.length = 0;
                // this.m_count = 0;
                // }
                /**
                 * Create a loop. This automatically adjusts connectivity.
                 * 
                 * @param vertices an array of vertices, these are copied
                 * @param count the vertex count
                 */
                ChainShape.prototype._createLoop = function (vertices) {
                    //ASSERT && common.assert(this.m_vertices.length == 0 && this.m_count == 0);
                    //ASSERT && common.assert(vertices.length >= 3);
                    for (var i = 1; i < vertices.length; ++i) {
                        var v1 = vertices[i - 1];
                        var v2 = vertices[i];
                        // If the code crashes here, it means your vertices are too close together.
                        //ASSERT && common.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);
                    }
                    this.m_vertices.length = 0;
                    this.m_count = vertices.length + 1;
                    for (var i = 0; i < vertices.length; ++i) {
                        this.m_vertices[i] = vertices[i].clone();
                    }
                    this.m_vertices[vertices.length] = vertices[0].clone();
                    this.m_prevVertex = this.m_vertices[this.m_count - 2];
                    this.m_nextVertex = this.m_vertices[1];
                    this.m_hasPrevVertex = true;
                    this.m_hasNextVertex = true;
                    return this;
                };

                /**
                 * Create a chain with isolated end vertices.
                 * 
                 * @param vertices an array of vertices, these are copied
                 * @param count the vertex count
                 */
                ChainShape.prototype._createChain = function (vertices) {
                    //ASSERT && common.assert(this.m_vertices.length == 0 && this.m_count == 0);
                    //ASSERT && common.assert(vertices.length >= 2);
                    for (var i = 1; i < vertices.length; ++i) {
                        // If the code crashes here, it means your vertices are too close together.
                        var v1 = vertices[i - 1];
                        var v2 = vertices[i];
                        //ASSERT && common.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);
                    }
                    this.m_count = vertices.length;
                    for (var i = 0; i < vertices.length; ++i) {
                        this.m_vertices[i] = vertices[i].clone();
                    }
                    this.m_hasPrevVertex = false;
                    this.m_hasNextVertex = false;
                    this.m_prevVertex = null;
                    this.m_nextVertex = null;
                    return this;
                };

                /**
                 * Establish connectivity to a vertex that precedes the first vertex. Don't call
                 * this for loops.
                 */
                ChainShape.prototype._setPrevVertex = function (prevVertex) {
                    this.m_prevVertex = prevVertex;
                    this.m_hasPrevVertex = true;
                };

                /**
                 * Establish connectivity to a vertex that follows the last vertex. Don't call
                 * this for loops.
                 */
                ChainShape.prototype._setNextVertex = function (nextVertex) {
                    this.m_nextVertex = nextVertex;
                    this.m_hasNextVertex = true;
                };

                ChainShape.prototype._clone = function () {
                    var clone = new ChainShape();
                    clone.createChain(this.m_vertices);
                    clone.m_type = this.m_type;
                    clone.m_radius = this.m_radius;
                    clone.m_prevVertex = this.m_prevVertex;
                    clone.m_nextVertex = this.m_nextVertex;
                    clone.m_hasPrevVertex = this.m_hasPrevVertex;
                    clone.m_hasNextVertex = this.m_hasNextVertex;
                    return clone;
                };

                ChainShape.prototype.getChildCount = function () {
                    // edge count = vertex count - 1
                    return this.m_count - 1;
                };

                // Get a child edge.
                ChainShape.prototype.getChildEdge = function (edge, childIndex) {
                    //ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count - 1);
                    edge.m_type = EdgeShape.TYPE;
                    edge.m_radius = this.m_radius;
                    edge.m_vertex1 = this.m_vertices[childIndex];
                    edge.m_vertex2 = this.m_vertices[childIndex + 1];
                    if (childIndex > 0) {
                        edge.m_vertex0 = this.m_vertices[childIndex - 1];
                        edge.m_hasVertex0 = true;
                    } else {
                        edge.m_vertex0 = this.m_prevVertex;
                        edge.m_hasVertex0 = this.m_hasPrevVertex;
                    }
                    if (childIndex < this.m_count - 2) {
                        edge.m_vertex3 = this.m_vertices[childIndex + 2];
                        edge.m_hasVertex3 = true;
                    } else {
                        edge.m_vertex3 = this.m_nextVertex;
                        edge.m_hasVertex3 = this.m_hasNextVertex;
                    }
                };

                ChainShape.prototype.getVertex = function (index) {
                    //ASSERT && common.assert(0 <= index && index <= this.m_count);
                    if (index < this.m_count) {
                        return this.m_vertices[index];
                    } else {
                        return this.m_vertices[0];
                    }
                };

                /**
                 * This always return false.
                 */
                ChainShape.prototype.testPoint = function (xf, p) {
                    return false;
                };

                ChainShape.prototype.rayCast = function (output, input, xf, childIndex) {
                    //ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);
                    var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));
                    return edgeShape.rayCast(output, input, xf, 0);
                };

                ChainShape.prototype.computeAABB = function (aabb, xf, childIndex) {
                    //ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);
                    var v1 = Transform.mul(xf, this.getVertex(childIndex));
                    var v2 = Transform.mul(xf, this.getVertex(childIndex + 1));
                    aabb.combinePoints(v1, v2);
                };

                /**
                 * Chains have zero mass.
                 */
                ChainShape.prototype.computeMass = function (massData, density) {
                    massData.mass = 0;
                    massData.center = Vec2.neo();
                    massData.I = 0;
                };

                ChainShape.prototype.computeDistanceProxy = function (proxy, childIndex) {
                    //ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);
                    proxy.m_buffer[0] = this.getVertex(childIndex);
                    proxy.m_buffer[1] = this.getVertex(childIndex + 1);
                    proxy.m_vertices = proxy.m_buffer;
                    proxy.m_count = 2;
                    proxy.m_radius = this.m_radius;
                };
            }, { "../Settings": 7, "../Shape": 8, "../collision/AABB": 11, "../common/Math": 18, "../common/Rot": 20, "../common/Transform": 22, "../common/Vec2": 23, "../util/common": 50, "../util/create": 51, "../util/options": 52, "./EdgeShape": 46 }], 40: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = CircleShape;

                var common = require("../util/common");

                var create = require("../util/create");

                var options = require("../util/options");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Rot = require("../common/Rot");

                var Vec2 = require("../common/Vec2");

                var AABB = require("../collision/AABB");

                var Settings = require("../Settings");

                var Shape = require("../Shape");

                CircleShape._super = Shape;

                CircleShape.prototype = create(CircleShape._super.prototype);

                CircleShape.TYPE = "circle";

                function CircleShape(a, b) {
                    if (!(this instanceof CircleShape)) {
                        return new CircleShape(a, b);
                    }
                    CircleShape._super.call(this);
                    this.m_type = CircleShape.TYPE;
                    this.m_p = Vec2.zero();
                    this.m_radius = 1;
                    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === "object" && Vec2.isValid(a)) {
                        this.m_p.set(a);
                        if (typeof b === "number") {
                            this.m_radius = b;
                        }
                    } else if (typeof a === "number") {
                        this.m_radius = a;
                    }
                }

                CircleShape.prototype.getRadius = function () {
                    return this.m_radius;
                };

                CircleShape.prototype.getCenter = function () {
                    return this.m_p;
                };

                CircleShape.prototype.getSupportVertex = function (d) {
                    return this.m_p;
                };

                CircleShape.prototype.getVertex = function (index) {
                    //ASSERT && common.assert(index == 0);
                    return this.m_p;
                };

                CircleShape.prototype.getVertexCount = function (index) {
                    return 1;
                };

                CircleShape.prototype._clone = function () {
                    var clone = new CircleShape();
                    clone.m_type = this.m_type;
                    clone.m_radius = this.m_radius;
                    clone.m_p = this.m_p.clone();
                    return clone;
                };

                CircleShape.prototype.getChildCount = function () {
                    return 1;
                };

                CircleShape.prototype.testPoint = function (xf, p) {
                    var center = Vec2.add(xf.p, Rot.mul(xf.q, this.m_p));
                    var d = Vec2.sub(p, center);
                    return Vec2.dot(d, d) <= this.m_radius * this.m_radius;
                };

                // Collision Detection in Interactive 3D Environments by Gino van den Bergen
                // From Section 3.1.2
                // x = s + a * r
                // norm(x) = radius
                CircleShape.prototype.rayCast = function (output, input, xf, childIndex) {
                    var position = Vec2.add(xf.p, Rot.mul(xf.q, this.m_p));
                    var s = Vec2.sub(input.p1, position);
                    var b = Vec2.dot(s, s) - this.m_radius * this.m_radius;
                    // Solve quadratic equation.
                    var r = Vec2.sub(input.p2, input.p1);
                    var c = Vec2.dot(s, r);
                    var rr = Vec2.dot(r, r);
                    var sigma = c * c - rr * b;
                    // Check for negative discriminant and short segment.
                    if (sigma < 0 || rr < Math.EPSILON) {
                        return false;
                    }
                    // Find the point of intersection of the line with the circle.
                    var a = -(c + Math.sqrt(sigma));
                    // Is the intersection point on the segment?
                    if (0 <= a && a <= input.maxFraction * rr) {
                        a /= rr;
                        output.fraction = a;
                        output.normal = Vec2.add(s, Vec2.mul(a, r));
                        output.normal.normalize();
                        return true;
                    }
                    return false;
                };

                CircleShape.prototype.computeAABB = function (aabb, xf, childIndex) {
                    var p = Vec2.add(xf.p, Rot.mul(xf.q, this.m_p));
                    aabb.lowerBound.set(p.x - this.m_radius, p.y - this.m_radius);
                    aabb.upperBound.set(p.x + this.m_radius, p.y + this.m_radius);
                };

                CircleShape.prototype.computeMass = function (massData, density) {
                    massData.mass = density * Math.PI * this.m_radius * this.m_radius;
                    massData.center = this.m_p;
                    // inertia about the local origin
                    massData.I = massData.mass * (.5 * this.m_radius * this.m_radius + Vec2.dot(this.m_p, this.m_p));
                };

                CircleShape.prototype.computeDistanceProxy = function (proxy) {
                    proxy.m_vertices.push(this.m_p);
                    proxy.m_count = 1;
                    proxy.m_radius = this.m_radius;
                };
            }, { "../Settings": 7, "../Shape": 8, "../collision/AABB": 11, "../common/Math": 18, "../common/Rot": 20, "../common/Transform": 22, "../common/Vec2": 23, "../util/common": 50, "../util/create": 51, "../util/options": 52 }], 41: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var common = require("../util/common");

                var create = require("../util/create");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Vec2 = require("../common/Vec2");

                var Settings = require("../Settings");

                var Shape = require("../Shape");

                var Contact = require("../Contact");

                var Manifold = require("../Manifold");

                var CircleShape = require("./CircleShape");

                Contact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);

                function CircleCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    //ASSERT && common.assert(fixtureA.getType() == CircleShape.TYPE);
                    //ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);
                    CollideCircles(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
                }

                function CollideCircles(manifold, circleA, xfA, circleB, xfB) {
                    manifold.pointCount = 0;
                    var pA = Transform.mul(xfA, circleA.m_p);
                    var pB = Transform.mul(xfB, circleB.m_p);
                    var distSqr = Vec2.distanceSquared(pB, pA);
                    var rA = circleA.m_radius;
                    var rB = circleB.m_radius;
                    var radius = rA + rB;
                    if (distSqr > radius * radius) {
                        return;
                    }
                    manifold.type = Manifold.e_circles;
                    manifold.localPoint.set(circleA.m_p);
                    manifold.localNormal.setZero();
                    manifold.pointCount = 1;
                    manifold.points[0].localPoint.set(circleB.m_p);
                    manifold.points[0].id.key = 0;
                }

                exports.CollideCircles = CollideCircles;
            }, { "../Contact": 3, "../Manifold": 6, "../Settings": 7, "../Shape": 8, "../common/Math": 18, "../common/Transform": 22, "../common/Vec2": 23, "../util/common": 50, "../util/create": 51, "./CircleShape": 40 }], 42: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var common = require("../util/common");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Rot = require("../common/Rot");

                var Vec2 = require("../common/Vec2");

                var AABB = require("../collision/AABB");

                var Settings = require("../Settings");

                var Manifold = require("../Manifold");

                var Contact = require("../Contact");

                var Shape = require("../Shape");

                var CircleShape = require("./CircleShape");

                var PolygonShape = require("./PolygonShape");

                Contact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);

                function PolygonCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    //ASSERT && common.assert(fixtureA.getType() == PolygonShape.TYPE);
                    //ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);
                    CollidePolygonCircle(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
                }

                function CollidePolygonCircle(manifold, polygonA, xfA, circleB, xfB) {
                    manifold.pointCount = 0;
                    // Compute circle position in the frame of the polygon.
                    var c = Transform.mul(xfB, circleB.m_p);
                    var cLocal = Transform.mulT(xfA, c);
                    // Find the min separating edge.
                    var normalIndex = 0;
                    var separation = -Infinity;
                    var radius = polygonA.m_radius + circleB.m_radius;
                    var vertexCount = polygonA.m_count;
                    var vertices = polygonA.m_vertices;
                    var normals = polygonA.m_normals;
                    for (var i = 0; i < vertexCount; ++i) {
                        var s = Vec2.dot(normals[i], Vec2.sub(cLocal, vertices[i]));
                        if (s > radius) {
                            // Early out.
                            return;
                        }
                        if (s > separation) {
                            separation = s;
                            normalIndex = i;
                        }
                    }
                    // Vertices that subtend the incident face.
                    var vertIndex1 = normalIndex;
                    var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
                    var v1 = vertices[vertIndex1];
                    var v2 = vertices[vertIndex2];
                    // If the center is inside the polygon ...
                    if (separation < Math.EPSILON) {
                        manifold.pointCount = 1;
                        manifold.type = Manifold.e_faceA;
                        manifold.localNormal.set(normals[normalIndex]);
                        manifold.localPoint.wSet(.5, v1, .5, v2);
                        manifold.points[0].localPoint = circleB.m_p;
                        manifold.points[0].id.key = 0;
                        return;
                    }
                    // Compute barycentric coordinates
                    var u1 = Vec2.dot(Vec2.sub(cLocal, v1), Vec2.sub(v2, v1));
                    var u2 = Vec2.dot(Vec2.sub(cLocal, v2), Vec2.sub(v1, v2));
                    if (u1 <= 0) {
                        if (Vec2.distanceSquared(cLocal, v1) > radius * radius) {
                            return;
                        }
                        manifold.pointCount = 1;
                        manifold.type = Manifold.e_faceA;
                        manifold.localNormal.wSet(1, cLocal, -1, v1);
                        manifold.localNormal.normalize();
                        manifold.localPoint = v1;
                        manifold.points[0].localPoint.set(circleB.m_p);
                        manifold.points[0].id.key = 0;
                    } else if (u2 <= 0) {
                        if (Vec2.distanceSquared(cLocal, v2) > radius * radius) {
                            return;
                        }
                        manifold.pointCount = 1;
                        manifold.type = Manifold.e_faceA;
                        manifold.localNormal.wSet(1, cLocal, -1, v2);
                        manifold.localNormal.normalize();
                        manifold.localPoint.set(v2);
                        manifold.points[0].localPoint.set(circleB.m_p);
                        manifold.points[0].id.key = 0;
                    } else {
                        var faceCenter = Vec2.mid(v1, v2);
                        var separation = Vec2.dot(cLocal, normals[vertIndex1]) - Vec2.dot(faceCenter, normals[vertIndex1]);
                        if (separation > radius) {
                            return;
                        }
                        manifold.pointCount = 1;
                        manifold.type = Manifold.e_faceA;
                        manifold.localNormal.set(normals[vertIndex1]);
                        manifold.localPoint.set(faceCenter);
                        manifold.points[0].localPoint.set(circleB.m_p);
                        manifold.points[0].id.key = 0;
                    }
                }
            }, { "../Contact": 3, "../Manifold": 6, "../Settings": 7, "../Shape": 8, "../collision/AABB": 11, "../common/Math": 18, "../common/Rot": 20, "../common/Transform": 22, "../common/Vec2": 23, "../util/common": 50, "./CircleShape": 40, "./PolygonShape": 47 }], 43: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var common = require("../util/common");

                var create = require("../util/create");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Vec2 = require("../common/Vec2");

                var Rot = require("../common/Rot");

                var Settings = require("../Settings");

                var Shape = require("../Shape");

                var Contact = require("../Contact");

                var Manifold = require("../Manifold");

                var EdgeShape = require("./EdgeShape");

                var ChainShape = require("./ChainShape");

                var CircleShape = require("./CircleShape");

                Contact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);

                Contact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);

                function EdgeCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    //ASSERT && common.assert(fixtureA.getType() == EdgeShape.TYPE);
                    //ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);
                    var shapeA = fixtureA.getShape();
                    var shapeB = fixtureB.getShape();
                    CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
                }

                function ChainCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    //ASSERT && common.assert(fixtureA.getType() == ChainShape.TYPE);
                    //ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);
                    var chain = fixtureA.getShape();
                    var edge = new EdgeShape();
                    chain.getChildEdge(edge, indexA);
                    var shapeA = edge;
                    var shapeB = fixtureB.getShape();
                    CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
                }

                // Compute contact points for edge versus circle.
                // This accounts for edge connectivity.
                function CollideEdgeCircle(manifold, edgeA, xfA, circleB, xfB) {
                    manifold.pointCount = 0;
                    // Compute circle in frame of edge
                    var Q = Transform.mulT(xfA, Transform.mul(xfB, circleB.m_p));
                    var A = edgeA.m_vertex1;
                    var B = edgeA.m_vertex2;
                    var e = Vec2.sub(B, A);
                    // Barycentric coordinates
                    var u = Vec2.dot(e, Vec2.sub(B, Q));
                    var v = Vec2.dot(e, Vec2.sub(Q, A));
                    var radius = edgeA.m_radius + circleB.m_radius;
                    // Region A
                    if (v <= 0) {
                        var P = Vec2.clone(A);
                        var d = Vec2.sub(Q, P);
                        var dd = Vec2.dot(d, d);
                        if (dd > radius * radius) {
                            return;
                        }
                        // Is there an edge connected to A?
                        if (edgeA.m_hasVertex0) {
                            var A1 = edgeA.m_vertex0;
                            var B1 = A;
                            var e1 = Vec2.sub(B1, A1);
                            var u1 = Vec2.dot(e1, Vec2.sub(B1, Q));
                            // Is the circle in Region AB of the previous edge?
                            if (u1 > 0) {
                                return;
                            }
                        }
                        manifold.type = Manifold.e_circles;
                        manifold.localNormal.setZero();
                        manifold.localPoint.set(P);
                        manifold.pointCount = 1;
                        manifold.points[0].localPoint.set(circleB.m_p);
                        manifold.points[0].id.key = 0;
                        manifold.points[0].id.cf.indexA = 0;
                        manifold.points[0].id.cf.typeA = Manifold.e_vertex;
                        manifold.points[0].id.cf.indexB = 0;
                        manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                        return;
                    }
                    // Region B
                    if (u <= 0) {
                        var P = Vec2.clone(B);
                        var d = Vec2.sub(Q, P);
                        var dd = Vec2.dot(d, d);
                        if (dd > radius * radius) {
                            return;
                        }
                        // Is there an edge connected to B?
                        if (edgeA.m_hasVertex3) {
                            var B2 = edgeA.m_vertex3;
                            var A2 = B;
                            var e2 = Vec2.sub(B2, A2);
                            var v2 = Vec2.dot(e2, Vec2.sub(Q, A2));
                            // Is the circle in Region AB of the next edge?
                            if (v2 > 0) {
                                return;
                            }
                        }
                        manifold.type = Manifold.e_circles;
                        manifold.localNormal.setZero();
                        manifold.localPoint.set(P);
                        manifold.pointCount = 1;
                        manifold.points[0].localPoint.set(circleB.m_p);
                        manifold.points[0].id.key = 0;
                        manifold.points[0].id.cf.indexA = 1;
                        manifold.points[0].id.cf.typeA = Manifold.e_vertex;
                        manifold.points[0].id.cf.indexB = 0;
                        manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                        return;
                    }
                    // Region AB
                    var den = Vec2.dot(e, e);
                    //ASSERT && common.assert(den > 0);
                    var P = Vec2.wAdd(u / den, A, v / den, B);
                    var d = Vec2.sub(Q, P);
                    var dd = Vec2.dot(d, d);
                    if (dd > radius * radius) {
                        return;
                    }
                    var n = Vec2.neo(-e.y, e.x);
                    if (Vec2.dot(n, Vec2.sub(Q, A)) < 0) {
                        n.set(-n.x, -n.y);
                    }
                    n.normalize();
                    manifold.type = Manifold.e_faceA;
                    manifold.localNormal = n;
                    manifold.localPoint.set(A);
                    manifold.pointCount = 1;
                    manifold.points[0].localPoint.set(circleB.m_p);
                    manifold.points[0].id.key = 0;
                    manifold.points[0].id.cf.indexA = 0;
                    manifold.points[0].id.cf.typeA = Manifold.e_face;
                    manifold.points[0].id.cf.indexB = 0;
                    manifold.points[0].id.cf.typeB = Manifold.e_vertex;
                }
            }, { "../Contact": 3, "../Manifold": 6, "../Settings": 7, "../Shape": 8, "../common/Math": 18, "../common/Rot": 20, "../common/Transform": 22, "../common/Vec2": 23, "../util/common": 50, "../util/create": 51, "./ChainShape": 39, "./CircleShape": 40, "./EdgeShape": 46 }], 44: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var common = require("../util/common");

                var create = require("../util/create");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Vec2 = require("../common/Vec2");

                var Rot = require("../common/Rot");

                var Settings = require("../Settings");

                var Shape = require("../Shape");

                var Contact = require("../Contact");

                var Manifold = require("../Manifold");

                var EdgeShape = require("./EdgeShape");

                var ChainShape = require("./ChainShape");

                var PolygonShape = require("./PolygonShape");

                Contact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);

                Contact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);

                function EdgePolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
                    //ASSERT && common.assert(fA.getType() == EdgeShape.TYPE);
                    //ASSERT && common.assert(fB.getType() == PolygonShape.TYPE);
                    CollideEdgePolygon(manifold, fA.getShape(), xfA, fB.getShape(), xfB);
                }

                function ChainPolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
                    //ASSERT && common.assert(fA.getType() == ChainShape.TYPE);
                    //ASSERT && common.assert(fB.getType() == PolygonShape.TYPE);
                    var chain = fA.getShape();
                    var edge = new EdgeShape();
                    chain.getChildEdge(edge, indexA);
                    CollideEdgePolygon(manifold, edge, xfA, fB.getShape(), xfB);
                }

                // EPAxis Type
                var e_unknown = -1;

                var e_edgeA = 1;

                var e_edgeB = 2;

                // VertexType unused?
                var e_isolated = 0;

                var e_concave = 1;

                var e_convex = 2;

                // This structure is used to keep track of the best separating axis.
                function EPAxis() {
                    this.type;
                    // Type
                    this.index;
                    this.separation;
                }

                // This holds polygon B expressed in frame A.
                function TempPolygon() {
                    this.vertices = [];
                    // Vec2[Settings.maxPolygonVertices]
                    this.normals = [];
                    // Vec2[Settings.maxPolygonVertices];
                    this.count = 0;
                }

                // Reference face used for clipping
                function ReferenceFace() {
                    this.i1, this.i2;
                    // int
                    this.v1, this.v2;
                    // v
                    this.normal = Vec2.zero();
                    this.sideNormal1 = Vec2.zero();
                    this.sideOffset1;
                    // float
                    this.sideNormal2 = Vec2.zero();
                    this.sideOffset2;
                }

                // reused
                var edgeAxis = new EPAxis();

                var polygonAxis = new EPAxis();

                var polygonBA = new TempPolygon();

                var rf = new ReferenceFace();

                /**
                 * This function collides and edge and a polygon, taking into account edge
                 * adjacency.
                 */
                function CollideEdgePolygon(manifold, edgeA, xfA, polygonB, xfB) {
                    //DEBUG && common.debug("CollideEdgePolygon");
                    // Algorithm:
                    // 1. Classify v1 and v2
                    // 2. Classify polygon centroid as front or back
                    // 3. Flip normal if necessary
                    // 4. Initialize normal range to [-pi, pi] about face normal
                    // 5. Adjust normal range according to adjacent edges
                    // 6. Visit each separating axes, only accept axes within the range
                    // 7. Return if _any_ axis indicates separation
                    // 8. Clip
                    var m_type1, m_type2;
                    // VertexType unused?
                    var xf = Transform.mulT(xfA, xfB);
                    var centroidB = Transform.mul(xf, polygonB.m_centroid);
                    var v0 = edgeA.m_vertex0;
                    var v1 = edgeA.m_vertex1;
                    var v2 = edgeA.m_vertex2;
                    var v3 = edgeA.m_vertex3;
                    var hasVertex0 = edgeA.m_hasVertex0;
                    var hasVertex3 = edgeA.m_hasVertex3;
                    var edge1 = Vec2.sub(v2, v1);
                    edge1.normalize();
                    var normal1 = Vec2.neo(edge1.y, -edge1.x);
                    var offset1 = Vec2.dot(normal1, Vec2.sub(centroidB, v1));
                    var offset0 = 0;
                    var offset2 = 0;
                    var convex1 = false;
                    var convex2 = false;
                    // Is there a preceding edge?
                    if (hasVertex0) {
                        var edge0 = Vec2.sub(v1, v0);
                        edge0.normalize();
                        var normal0 = Vec2.neo(edge0.y, -edge0.x);
                        convex1 = Vec2.cross(edge0, edge1) >= 0;
                        offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);
                    }
                    // Is there a following edge?
                    if (hasVertex3) {
                        var edge2 = Vec2.sub(v3, v2);
                        edge2.normalize();
                        var normal2 = Vec2.neo(edge2.y, -edge2.x);
                        convex2 = Vec2.cross(edge1, edge2) > 0;
                        offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);
                    }
                    var front;
                    var normal = Vec2.zero();
                    var lowerLimit = Vec2.zero();
                    var upperLimit = Vec2.zero();
                    // Determine front or back collision. Determine collision normal limits.
                    if (hasVertex0 && hasVertex3) {
                        if (convex1 && convex2) {
                            front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal0);
                                upperLimit.set(normal2);
                            } else {
                                normal.wSet(-1, normal1);
                                lowerLimit.wSet(-1, normal1);
                                upperLimit.wSet(-1, normal1);
                            }
                        } else if (convex1) {
                            front = offset0 >= 0 || offset1 >= 0 && offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal0);
                                upperLimit.set(normal1);
                            } else {
                                normal.wSet(-1, normal1);
                                lowerLimit.wSet(-1, normal2);
                                upperLimit.wSet(-1, normal1);
                            }
                        } else if (convex2) {
                            front = offset2 >= 0 || offset0 >= 0 && offset1 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal1);
                                upperLimit.set(normal2);
                            } else {
                                normal.wSet(-1, normal1);
                                lowerLimit.wSet(-1, normal1);
                                upperLimit.wSet(-1, normal0);
                            }
                        } else {
                            front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal1);
                                upperLimit.set(normal1);
                            } else {
                                normal.wSet(-1, normal1);
                                lowerLimit.wSet(-1, normal2);
                                upperLimit.wSet(-1, normal0);
                            }
                        }
                    } else if (hasVertex0) {
                        if (convex1) {
                            front = offset0 >= 0 || offset1 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal0);
                                upperLimit.wSet(-1, normal1);
                            } else {
                                normal.wSet(-1, normal1);
                                lowerLimit.set(normal1);
                                upperLimit.wSet(-1, normal1);
                            }
                        } else {
                            front = offset0 >= 0 && offset1 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.set(normal1);
                                upperLimit.wSet(-1, normal1);
                            } else {
                                normal.wSet(-1, normal1);
                                lowerLimit.set(normal1);
                                upperLimit.wSet(-1, normal0);
                            }
                        }
                    } else if (hasVertex3) {
                        if (convex2) {
                            front = offset1 >= 0 || offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.wSet(-1, normal1);
                                upperLimit.set(normal2);
                            } else {
                                normal.wSet(-1, normal1);
                                lowerLimit.wSet(-1, normal1);
                                upperLimit.set(normal1);
                            }
                        } else {
                            front = offset1 >= 0 && offset2 >= 0;
                            if (front) {
                                normal.set(normal1);
                                lowerLimit.wSet(-1, normal1);
                                upperLimit.set(normal1);
                            } else {
                                normal.wSet(-1, normal1);
                                lowerLimit.wSet(-1, normal2);
                                upperLimit.set(normal1);
                            }
                        }
                    } else {
                        front = offset1 >= 0;
                        if (front) {
                            normal.set(normal1);
                            lowerLimit.wSet(-1, normal1);
                            upperLimit.wSet(-1, normal1);
                        } else {
                            normal.wSet(-1, normal1);
                            lowerLimit.set(normal1);
                            upperLimit.set(normal1);
                        }
                    }
                    // Get polygonB in frameA
                    polygonBA.count = polygonB.m_count;
                    for (var i = 0; i < polygonB.m_count; ++i) {
                        polygonBA.vertices[i] = Transform.mul(xf, polygonB.m_vertices[i]);
                        polygonBA.normals[i] = Rot.mul(xf.q, polygonB.m_normals[i]);
                    }
                    var radius = 2 * Settings.polygonRadius;
                    manifold.pointCount = 0;
                    {
                        // ComputeEdgeSeparation
                        edgeAxis.type = e_edgeA;
                        edgeAxis.index = front ? 0 : 1;
                        edgeAxis.separation = Infinity;
                        for (var i = 0; i < polygonBA.count; ++i) {
                            var s = Vec2.dot(normal, Vec2.sub(polygonBA.vertices[i], v1));
                            if (s < edgeAxis.separation) {
                                edgeAxis.separation = s;
                            }
                        }
                    }
                    // If no valid normal can be found than this edge should not collide.
                    if (edgeAxis.type == e_unknown) {
                        return;
                    }
                    if (edgeAxis.separation > radius) {
                        return;
                    }
                    {
                        // ComputePolygonSeparation
                        polygonAxis.type = e_unknown;
                        polygonAxis.index = -1;
                        polygonAxis.separation = -Infinity;
                        var perp = Vec2.neo(-normal.y, normal.x);
                        for (var i = 0; i < polygonBA.count; ++i) {
                            var n = Vec2.neg(polygonBA.normals[i]);
                            var s1 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v1));
                            var s2 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v2));
                            var s = Math.min(s1, s2);
                            if (s > radius) {
                                // No collision
                                polygonAxis.type = e_edgeB;
                                polygonAxis.index = i;
                                polygonAxis.separation = s;
                                break;
                            }
                            // Adjacency
                            if (Vec2.dot(n, perp) >= 0) {
                                if (Vec2.dot(Vec2.sub(n, upperLimit), normal) < -Settings.angularSlop) {
                                    continue;
                                }
                            } else {
                                if (Vec2.dot(Vec2.sub(n, lowerLimit), normal) < -Settings.angularSlop) {
                                    continue;
                                }
                            }
                            if (s > polygonAxis.separation) {
                                polygonAxis.type = e_edgeB;
                                polygonAxis.index = i;
                                polygonAxis.separation = s;
                            }
                        }
                    }
                    if (polygonAxis.type != e_unknown && polygonAxis.separation > radius) {
                        return;
                    }
                    // Use hysteresis for jitter reduction.
                    var k_relativeTol = .98;
                    var k_absoluteTol = .001;
                    var primaryAxis;
                    if (polygonAxis.type == e_unknown) {
                        primaryAxis = edgeAxis;
                    } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {
                        primaryAxis = polygonAxis;
                    } else {
                        primaryAxis = edgeAxis;
                    }
                    var ie = [new Manifold.clipVertex(), new Manifold.clipVertex()];
                    if (primaryAxis.type == e_edgeA) {
                        manifold.type = Manifold.e_faceA;
                        // Search for the polygon normal that is most anti-parallel to the edge
                        // normal.
                        var bestIndex = 0;
                        var bestValue = Vec2.dot(normal, polygonBA.normals[0]);
                        for (var i = 1; i < polygonBA.count; ++i) {
                            var value = Vec2.dot(normal, polygonBA.normals[i]);
                            if (value < bestValue) {
                                bestValue = value;
                                bestIndex = i;
                            }
                        }
                        var i1 = bestIndex;
                        var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;
                        ie[0].v = polygonBA.vertices[i1];
                        ie[0].id.cf.indexA = 0;
                        ie[0].id.cf.indexB = i1;
                        ie[0].id.cf.typeA = Manifold.e_face;
                        ie[0].id.cf.typeB = Manifold.e_vertex;
                        ie[1].v = polygonBA.vertices[i2];
                        ie[1].id.cf.indexA = 0;
                        ie[1].id.cf.indexB = i2;
                        ie[1].id.cf.typeA = Manifold.e_face;
                        ie[1].id.cf.typeB = Manifold.e_vertex;
                        if (front) {
                            rf.i1 = 0;
                            rf.i2 = 1;
                            rf.v1 = v1;
                            rf.v2 = v2;
                            rf.normal.set(normal1);
                        } else {
                            rf.i1 = 1;
                            rf.i2 = 0;
                            rf.v1 = v2;
                            rf.v2 = v1;
                            rf.normal.wSet(-1, normal1);
                        }
                    } else {
                        manifold.type = Manifold.e_faceB;
                        ie[0].v = v1;
                        ie[0].id.cf.indexA = 0;
                        ie[0].id.cf.indexB = primaryAxis.index;
                        ie[0].id.cf.typeA = Manifold.e_vertex;
                        ie[0].id.cf.typeB = Manifold.e_face;
                        ie[1].v = v2;
                        ie[1].id.cf.indexA = 0;
                        ie[1].id.cf.indexB = primaryAxis.index;
                        ie[1].id.cf.typeA = Manifold.e_vertex;
                        ie[1].id.cf.typeB = Manifold.e_face;
                        rf.i1 = primaryAxis.index;
                        rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;
                        rf.v1 = polygonBA.vertices[rf.i1];
                        rf.v2 = polygonBA.vertices[rf.i2];
                        rf.normal.set(polygonBA.normals[rf.i1]);
                    }
                    rf.sideNormal1.set(rf.normal.y, -rf.normal.x);
                    rf.sideNormal2.wSet(-1, rf.sideNormal1);
                    rf.sideOffset1 = Vec2.dot(rf.sideNormal1, rf.v1);
                    rf.sideOffset2 = Vec2.dot(rf.sideNormal2, rf.v2);
                    // Clip incident edge against extruded edge1 side edges.
                    var clipPoints1 = [new Manifold.clipVertex(), new Manifold.clipVertex()];
                    var clipPoints2 = [new Manifold.clipVertex(), new Manifold.clipVertex()];
                    var np;
                    // Clip to box side 1
                    np = Manifold.clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);
                    if (np < Settings.maxManifoldPoints) {
                        return;
                    }
                    // Clip to negative box side 1
                    np = Manifold.clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);
                    if (np < Settings.maxManifoldPoints) {
                        return;
                    }
                    // Now clipPoints2 contains the clipped points.
                    if (primaryAxis.type == e_edgeA) {
                        manifold.localNormal = Vec2.clone(rf.normal);
                        manifold.localPoint = Vec2.clone(rf.v1);
                    } else {
                        manifold.localNormal = Vec2.clone(polygonB.m_normals[rf.i1]);
                        manifold.localPoint = Vec2.clone(polygonB.m_vertices[rf.i1]);
                    }
                    var pointCount = 0;
                    for (var i = 0; i < Settings.maxManifoldPoints; ++i) {
                        var separation = Vec2.dot(rf.normal, Vec2.sub(clipPoints2[i].v, rf.v1));
                        if (separation <= radius) {
                            var cp = manifold.points[pointCount];
                            // ManifoldPoint
                            if (primaryAxis.type == e_edgeA) {
                                cp.localPoint = Transform.mulT(xf, clipPoints2[i].v);
                                cp.id = clipPoints2[i].id;
                            } else {
                                cp.localPoint = clipPoints2[i].v;
                                cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;
                                cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;
                                cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;
                                cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;
                            }
                            ++pointCount;
                        }
                    }
                    manifold.pointCount = pointCount;
                }
            }, { "../Contact": 3, "../Manifold": 6, "../Settings": 7, "../Shape": 8, "../common/Math": 18, "../common/Rot": 20, "../common/Transform": 22, "../common/Vec2": 23, "../util/common": 50, "../util/create": 51, "./ChainShape": 39, "./EdgeShape": 46, "./PolygonShape": 47 }], 45: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var common = require("../util/common");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Rot = require("../common/Rot");

                var Vec2 = require("../common/Vec2");

                var AABB = require("../collision/AABB");

                var Settings = require("../Settings");

                var Manifold = require("../Manifold");

                var Contact = require("../Contact");

                var Shape = require("../Shape");

                var PolygonShape = require("./PolygonShape");

                module.exports = CollidePolygons;

                Contact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);

                function PolygonContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
                    //ASSERT && common.assert(fixtureA.getType() == PolygonShape.TYPE);
                    //ASSERT && common.assert(fixtureB.getType() == PolygonShape.TYPE);
                    CollidePolygons(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
                }

                /**
                 * Find the max separation between poly1 and poly2 using edge normals from
                 * poly1.
                 */
                function FindMaxSeparation(poly1, xf1, poly2, xf2) {
                    var count1 = poly1.m_count;
                    var count2 = poly2.m_count;
                    var n1s = poly1.m_normals;
                    var v1s = poly1.m_vertices;
                    var v2s = poly2.m_vertices;
                    var xf = Transform.mulT(xf2, xf1);
                    var bestIndex = 0;
                    var maxSeparation = -Infinity;
                    for (var i = 0; i < count1; ++i) {
                        // Get poly1 normal in frame2.
                        var n = Rot.mul(xf.q, n1s[i]);
                        var v1 = Transform.mul(xf, v1s[i]);
                        // Find deepest point for normal i.
                        var si = Infinity;
                        for (var j = 0; j < count2; ++j) {
                            var sij = Vec2.dot(n, v2s[j]) - Vec2.dot(n, v1);
                            if (sij < si) {
                                si = sij;
                            }
                        }
                        if (si > maxSeparation) {
                            maxSeparation = si;
                            bestIndex = i;
                        }
                    }
                    // used to keep last FindMaxSeparation call values
                    FindMaxSeparation._maxSeparation = maxSeparation;
                    FindMaxSeparation._bestIndex = bestIndex;
                }

                /**
                 * @param {ClipVertex[2]} c
                 * @param {int} edge1
                 */
                function FindIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {
                    var normals1 = poly1.m_normals;
                    var count2 = poly2.m_count;
                    var vertices2 = poly2.m_vertices;
                    var normals2 = poly2.m_normals;
                    //ASSERT && common.assert(0 <= edge1 && edge1 < poly1.m_count);
                    // Get the normal of the reference edge in poly2's frame.
                    var normal1 = Rot.mulT(xf2.q, Rot.mul(xf1.q, normals1[edge1]));
                    // Find the incident edge on poly2.
                    var index = 0;
                    var minDot = Infinity;
                    for (var i = 0; i < count2; ++i) {
                        var dot = Vec2.dot(normal1, normals2[i]);
                        if (dot < minDot) {
                            minDot = dot;
                            index = i;
                        }
                    }
                    // Build the clip vertices for the incident edge.
                    var i1 = index;
                    var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
                    c[0].v = Transform.mul(xf2, vertices2[i1]);
                    c[0].id.cf.indexA = edge1;
                    c[0].id.cf.indexB = i1;
                    c[0].id.cf.typeA = Manifold.e_face;
                    c[0].id.cf.typeB = Manifold.e_vertex;
                    c[1].v = Transform.mul(xf2, vertices2[i2]);
                    c[1].id.cf.indexA = edge1;
                    c[1].id.cf.indexB = i2;
                    c[1].id.cf.typeA = Manifold.e_face;
                    c[1].id.cf.typeB = Manifold.e_vertex;
                }

                /**
                 * 
                 * Find edge normal of max separation on A - return if separating axis is found<br>
                 * Find edge normal of max separation on B - return if separation axis is found<br>
                 * Choose reference edge as min(minA, minB)<br>
                 * Find incident edge<br>
                 * Clip
                 * 
                 * The normal points from 1 to 2
                 */
                function CollidePolygons(manifold, polyA, xfA, polyB, xfB) {
                    manifold.pointCount = 0;
                    var totalRadius = polyA.m_radius + polyB.m_radius;
                    FindMaxSeparation(polyA, xfA, polyB, xfB);
                    var edgeA = FindMaxSeparation._bestIndex;
                    var separationA = FindMaxSeparation._maxSeparation;
                    if (separationA > totalRadius) return;
                    FindMaxSeparation(polyB, xfB, polyA, xfA);
                    var edgeB = FindMaxSeparation._bestIndex;
                    var separationB = FindMaxSeparation._maxSeparation;
                    if (separationB > totalRadius) return;
                    var poly1;
                    // reference polygon
                    var poly2;
                    // incident polygon
                    var xf1;
                    var xf2;
                    var edge1;
                    // reference edge
                    var flip;
                    var k_tol = .1 * Settings.linearSlop;
                    if (separationB > separationA + k_tol) {
                        poly1 = polyB;
                        poly2 = polyA;
                        xf1 = xfB;
                        xf2 = xfA;
                        edge1 = edgeB;
                        manifold.type = Manifold.e_faceB;
                        flip = 1;
                    } else {
                        poly1 = polyA;
                        poly2 = polyB;
                        xf1 = xfA;
                        xf2 = xfB;
                        edge1 = edgeA;
                        manifold.type = Manifold.e_faceA;
                        flip = 0;
                    }
                    var incidentEdge = [new Manifold.clipVertex(), new Manifold.clipVertex()];
                    FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
                    var count1 = poly1.m_count;
                    var vertices1 = poly1.m_vertices;
                    var iv1 = edge1;
                    var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
                    var v11 = vertices1[iv1];
                    var v12 = vertices1[iv2];
                    var localTangent = Vec2.sub(v12, v11);
                    localTangent.normalize();
                    var localNormal = Vec2.cross(localTangent, 1);
                    var planePoint = Vec2.wAdd(.5, v11, .5, v12);
                    var tangent = Rot.mul(xf1.q, localTangent);
                    var normal = Vec2.cross(tangent, 1);
                    v11 = Transform.mul(xf1, v11);
                    v12 = Transform.mul(xf1, v12);
                    // Face offset.
                    var frontOffset = Vec2.dot(normal, v11);
                    // Side offsets, extended by polytope skin thickness.
                    var sideOffset1 = -Vec2.dot(tangent, v11) + totalRadius;
                    var sideOffset2 = Vec2.dot(tangent, v12) + totalRadius;
                    // Clip incident edge against extruded edge1 side edges.
                    var clipPoints1 = [new Manifold.clipVertex(), new Manifold.clipVertex()];
                    var clipPoints2 = [new Manifold.clipVertex(), new Manifold.clipVertex()];
                    var np;
                    // Clip to box side 1
                    np = Manifold.clipSegmentToLine(clipPoints1, incidentEdge, Vec2.neg(tangent), sideOffset1, iv1);
                    if (np < 2) {
                        return;
                    }
                    // Clip to negative box side 1
                    np = Manifold.clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);
                    if (np < 2) {
                        return;
                    }
                    // Now clipPoints2 contains the clipped points.
                    manifold.localNormal = localNormal;
                    manifold.localPoint = planePoint;
                    var pointCount = 0;
                    for (var i = 0; i < clipPoints2.length; ++i) {
                        var separation = Vec2.dot(normal, clipPoints2[i].v) - frontOffset;
                        if (separation <= totalRadius) {
                            var cp = manifold.points[pointCount];
                            // ManifoldPoint
                            cp.localPoint.set(Transform.mulT(xf2, clipPoints2[i].v));
                            cp.id = clipPoints2[i].id;
                            if (flip) {
                                // Swap features
                                var cf = cp.id.cf;
                                // ContactFeature
                                var indexA = cf.indexA;
                                var indexB = cf.indexB;
                                var typeA = cf.typeA;
                                var typeB = cf.typeB;
                                cf.indexA = indexB;
                                cf.indexB = indexA;
                                cf.typeA = typeB;
                                cf.typeB = typeA;
                            }
                            ++pointCount;
                        }
                    }
                    manifold.pointCount = pointCount;
                }
            }, { "../Contact": 3, "../Manifold": 6, "../Settings": 7, "../Shape": 8, "../collision/AABB": 11, "../common/Math": 18, "../common/Rot": 20, "../common/Transform": 22, "../common/Vec2": 23, "../util/common": 50, "./PolygonShape": 47 }], 46: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = EdgeShape;

                var create = require("../util/create");

                var options = require("../util/options");

                var Settings = require("../Settings");

                var Shape = require("../Shape");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Rot = require("../common/Rot");

                var Vec2 = require("../common/Vec2");

                var AABB = require("../collision/AABB");

                EdgeShape._super = Shape;

                EdgeShape.prototype = create(EdgeShape._super.prototype);

                EdgeShape.TYPE = "edge";

                /**
                 * A line segment (edge) shape. These can be connected in chains or loops to
                 * other edge shapes. The connectivity information is used to ensure correct
                 * contact normals.
                 */
                function EdgeShape(v1, v2) {
                    if (!(this instanceof EdgeShape)) {
                        return new EdgeShape(v1, v2);
                    }
                    EdgeShape._super.call(this);
                    this.m_type = EdgeShape.TYPE;
                    this.m_radius = Settings.polygonRadius;
                    // These are the edge vertices
                    this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();
                    this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();
                    // Optional adjacent vertices. These are used for smooth collision.
                    // Used by chain shape.
                    this.m_vertex0 = Vec2.zero();
                    this.m_vertex3 = Vec2.zero();
                    this.m_hasVertex0 = false;
                    this.m_hasVertex3 = false;
                }

                EdgeShape.prototype.setNext = function (v3) {
                    if (v3) {
                        this.m_vertex3.set(v3);
                        this.m_hasVertex3 = true;
                    } else {
                        this.m_vertex3.setZero();
                        this.m_hasVertex3 = false;
                    }
                    return this;
                };

                EdgeShape.prototype.setPrev = function (v0) {
                    if (v0) {
                        this.m_vertex0.set(v0);
                        this.m_hasVertex0 = true;
                    } else {
                        this.m_vertex0.setZero();
                        this.m_hasVertex0 = false;
                    }
                    return this;
                };

                /**
                 * Set this as an isolated edge.
                 */
                EdgeShape.prototype._set = function (v1, v2) {
                    this.m_vertex1.set(v1);
                    this.m_vertex2.set(v2);
                    this.m_hasVertex0 = false;
                    this.m_hasVertex3 = false;
                    return this;
                };

                EdgeShape.prototype._clone = function () {
                    var clone = new EdgeShape();
                    clone.m_type = this.m_type;
                    clone.m_radius = this.m_radius;
                    clone.m_vertex1.set(this.m_vertex1);
                    clone.m_vertex2.set(this.m_vertex2);
                    clone.m_vertex0.set(this.m_vertex0);
                    clone.m_vertex3.set(this.m_vertex3);
                    clone.m_hasVertex0 = this.m_hasVertex0;
                    clone.m_hasVertex3 = this.m_hasVertex3;
                    return clone;
                };

                EdgeShape.prototype.getChildCount = function () {
                    return 1;
                };

                EdgeShape.prototype.testPoint = function (xf, p) {
                    return false;
                };

                // p = p1 + t * d
                // v = v1 + s * e
                // p1 + t * d = v1 + s * e
                // s * e - t * d = p1 - v1
                EdgeShape.prototype.rayCast = function (output, input, xf, childIndex) {
                    // NOT_USED(childIndex);
                    // Put the ray into the edge's frame of reference.
                    var p1 = Rot.mulT(xf.q, Vec2.sub(input.p1, xf.p));
                    var p2 = Rot.mulT(xf.q, Vec2.sub(input.p2, xf.p));
                    var d = Vec2.sub(p2, p1);
                    var v1 = this.m_vertex1;
                    var v2 = this.m_vertex2;
                    var e = Vec2.sub(v2, v1);
                    var normal = Vec2.neo(e.y, -e.x);
                    normal.normalize();
                    // q = p1 + t * d
                    // dot(normal, q - v1) = 0
                    // dot(normal, p1 - v1) + t * dot(normal, d) = 0
                    var numerator = Vec2.dot(normal, Vec2.sub(v1, p1));
                    var denominator = Vec2.dot(normal, d);
                    if (denominator == 0) {
                        return false;
                    }
                    var t = numerator / denominator;
                    if (t < 0 || input.maxFraction < t) {
                        return false;
                    }
                    var q = Vec2.add(p1, Vec2.mul(t, d));
                    // q = v1 + s * r
                    // s = dot(q - v1, r) / dot(r, r)
                    var r = Vec2.sub(v2, v1);
                    var rr = Vec2.dot(r, r);
                    if (rr == 0) {
                        return false;
                    }
                    var s = Vec2.dot(Vec2.sub(q, v1), r) / rr;
                    if (s < 0 || 1 < s) {
                        return false;
                    }
                    output.fraction = t;
                    if (numerator > 0) {
                        output.normal = Rot.mul(xf.q, normal).neg();
                    } else {
                        output.normal = Rot.mul(xf.q, normal);
                    }
                    return true;
                };

                EdgeShape.prototype.computeAABB = function (aabb, xf, childIndex) {
                    var v1 = Transform.mul(xf, this.m_vertex1);
                    var v2 = Transform.mul(xf, this.m_vertex2);
                    aabb.combinePoints(v1, v2);
                    aabb.extend(this.m_radius);
                };

                EdgeShape.prototype.computeMass = function (massData, density) {
                    massData.mass = 0;
                    massData.center.wSet(.5, this.m_vertex1, .5, this.m_vertex2);
                    massData.I = 0;
                };

                EdgeShape.prototype.computeDistanceProxy = function (proxy) {
                    proxy.m_vertices.push(this.m_vertex1);
                    proxy.m_vertices.push(this.m_vertex2);
                    proxy.m_count = 2;
                    proxy.m_radius = this.m_radius;
                };
            }, { "../Settings": 7, "../Shape": 8, "../collision/AABB": 11, "../common/Math": 18, "../common/Rot": 20, "../common/Transform": 22, "../common/Vec2": 23, "../util/create": 51, "../util/options": 52 }], 47: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = PolygonShape;

                var common = require("../util/common");

                var create = require("../util/create");

                var options = require("../util/options");

                var Math = require("../common/Math");

                var Transform = require("../common/Transform");

                var Rot = require("../common/Rot");

                var Vec2 = require("../common/Vec2");

                var AABB = require("../collision/AABB");

                var Settings = require("../Settings");

                var Shape = require("../Shape");

                PolygonShape._super = Shape;

                PolygonShape.prototype = create(PolygonShape._super.prototype);

                PolygonShape.TYPE = "polygon";

                /**
                 * A convex polygon. It is assumed that the interior of the polygon is to the
                 * left of each edge. Polygons have a maximum number of vertices equal to
                 * Settings.maxPolygonVertices. In most cases you should not need many vertices
                 * for a convex polygon. extends Shape
                 */
                function PolygonShape(vertices) {
                    if (!(this instanceof PolygonShape)) {
                        return new PolygonShape(vertices);
                    }
                    PolygonShape._super.call(this);
                    this.m_type = PolygonShape.TYPE;
                    this.m_radius = Settings.polygonRadius;
                    this.m_centroid = Vec2.zero();
                    this.m_vertices = [];
                    // Vec2[Settings.maxPolygonVertices]
                    this.m_normals = [];
                    // Vec2[Settings.maxPolygonVertices]
                    this.m_count = 0;
                    if (vertices && vertices.length) {
                        this._set(vertices);
                    }
                }

                PolygonShape.prototype.getVertex = function (index) {
                    //ASSERT && common.assert(0 <= index && index < this.m_count);
                    return this.m_vertices[index];
                };

                PolygonShape.prototype._clone = function () {
                    var clone = new PolygonShape();
                    clone.m_type = this.m_type;
                    clone.m_radius = this.m_radius;
                    clone.m_count = this.m_count;
                    clone.m_centroid.set(this.m_centroid);
                    for (var i = 0; i < this.m_count; i++) {
                        clone.m_vertices.push(this.m_vertices[i].clone());
                    }
                    for (var i = 0; i < this.m_normals.length; i++) {
                        clone.m_normals.push(this.m_normals[i].clone());
                    }
                    return clone;
                };

                PolygonShape.prototype.getChildCount = function () {
                    return 1;
                };

                function ComputeCentroid(vs, count) {
                    //ASSERT && common.assert(count >= 3);
                    var c = Vec2.zero();
                    var area = 0;
                    // pRef is the reference point for forming triangles.
                    // It's location doesn't change the result (except for rounding error).
                    var pRef = Vec2.zero();
                    if (false) {
                        // This code would put the reference point inside the polygon.
                        for (var i = 0; i < count; ++i) {
                            pRef.add(vs[i]);
                        }
                        pRef.mul(1 / count);
                    }
                    var inv3 = 1 / 3;
                    for (var i = 0; i < count; ++i) {
                        // Triangle vertices.
                        var p1 = pRef;
                        var p2 = vs[i];
                        var p3 = i + 1 < count ? vs[i + 1] : vs[0];
                        var e1 = Vec2.sub(p2, p1);
                        var e2 = Vec2.sub(p3, p1);
                        var D = Vec2.cross(e1, e2);
                        var triangleArea = .5 * D;
                        area += triangleArea;
                        // Area weighted centroid
                        c.wAdd(triangleArea * inv3, p1);
                        c.wAdd(triangleArea * inv3, p2);
                        c.wAdd(triangleArea * inv3, p3);
                    }
                    // Centroid
                    //ASSERT && common.assert(area > Math.EPSILON);
                    c.mul(1 / area);
                    return c;
                }

                /**
                 * @private
                 *
                 * Create a convex hull from the given array of local points. The count must be
                 * in the range [3, Settings.maxPolygonVertices].
                 * 
                 * Warning: the points may be re-ordered, even if they form a convex polygon
                 * Warning: collinear points are handled but not removed. Collinear points may
                 * lead to poor stacking behavior.
                 */
                PolygonShape.prototype._set = function (vertices) {
                    //ASSERT && common.assert(3 <= vertices.length && vertices.length <= Settings.maxPolygonVertices);
                    if (vertices.length < 3) {
                        SetAsBox(1, 1);
                        return;
                    }
                    var n = Math.min(vertices.length, Settings.maxPolygonVertices);
                    // Perform welding and copy vertices into local buffer.
                    var ps = [];
                    // [Settings.maxPolygonVertices];
                    var tempCount = 0;
                    for (var i = 0; i < n; ++i) {
                        var v = vertices[i];
                        var unique = true;
                        for (var j = 0; j < tempCount; ++j) {
                            if (Vec2.distanceSquared(v, ps[j]) < .25 * Settings.linearSlopSquared) {
                                unique = false;
                                break;
                            }
                        }
                        if (unique) {
                            ps[tempCount++] = v;
                        }
                    }
                    n = tempCount;
                    if (n < 3) {
                        // Polygon is degenerate.
                        //ASSERT && common.assert(false);
                        SetAsBox(1, 1);
                        return;
                    }
                    // Create the convex hull using the Gift wrapping algorithm
                    // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm
                    // Find the right most point on the hull
                    var i0 = 0;
                    var x0 = ps[0].x;
                    for (var i = 1; i < n; ++i) {
                        var x = ps[i].x;
                        if (x > x0 || x == x0 && ps[i].y < ps[i0].y) {
                            i0 = i;
                            x0 = x;
                        }
                    }
                    var hull = [];
                    // [Settings.maxPolygonVertices];
                    var m = 0;
                    var ih = i0;
                    for (;;) {
                        hull[m] = ih;
                        var ie = 0;
                        for (var j = 1; j < n; ++j) {
                            if (ie == ih) {
                                ie = j;
                                continue;
                            }
                            var r = Vec2.sub(ps[ie], ps[hull[m]]);
                            var v = Vec2.sub(ps[j], ps[hull[m]]);
                            var c = Vec2.cross(r, v);
                            if (c < 0) {
                                ie = j;
                            }
                            // Collinearity check
                            if (c == 0 && v.lengthSquared() > r.lengthSquared()) {
                                ie = j;
                            }
                        }
                        ++m;
                        ih = ie;
                        if (ie == i0) {
                            break;
                        }
                    }
                    if (m < 3) {
                        // Polygon is degenerate.
                        //ASSERT && common.assert(false);
                        SetAsBox(1, 1);
                        return;
                    }
                    this.m_count = m;
                    // Copy vertices.
                    for (var i = 0; i < m; ++i) {
                        this.m_vertices[i] = ps[hull[i]];
                    }
                    // Compute normals. Ensure the edges have non-zero length.
                    for (var i = 0; i < m; ++i) {
                        var i1 = i;
                        var i2 = i + 1 < m ? i + 1 : 0;
                        var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);
                        //ASSERT && common.assert(edge.lengthSquared() > Math.EPSILON * Math.EPSILON);
                        this.m_normals[i] = Vec2.cross(edge, 1);
                        this.m_normals[i].normalize();
                    }
                    // Compute the polygon centroid.
                    this.m_centroid = ComputeCentroid(this.m_vertices, m);
                };

                PolygonShape.prototype.testPoint = function (xf, p) {
                    var pLocal = Rot.mulT(xf.q, Vec2.sub(p, xf.p));
                    for (var i = 0; i < this.m_count; ++i) {
                        var dot = Vec2.dot(this.m_normals[i], Vec2.sub(pLocal, this.m_vertices[i]));
                        if (dot > 0) {
                            return false;
                        }
                    }
                    return true;
                };

                PolygonShape.prototype.rayCast = function (output, input, xf, childIndex) {
                    // Put the ray into the polygon's frame of reference.
                    var p1 = Rot.mulT(xf.q, Vec2.sub(input.p1, xf.p));
                    var p2 = Rot.mulT(xf.q, Vec2.sub(input.p2, xf.p));
                    var d = Vec2.sub(p2, p1);
                    var lower = 0;
                    var upper = input.maxFraction;
                    var index = -1;
                    for (var i = 0; i < this.m_count; ++i) {
                        // p = p1 + a * d
                        // dot(normal, p - v) = 0
                        // dot(normal, p1 - v) + a * dot(normal, d) = 0
                        var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));
                        var denominator = Vec2.dot(this.m_normals[i], d);
                        if (denominator == 0) {
                            if (numerator < 0) {
                                return false;
                            }
                        } else {
                            // Note: we want this predicate without division:
                            // lower < numerator / denominator, where denominator < 0
                            // Since denominator < 0, we have to flip the inequality:
                            // lower < numerator / denominator <==> denominator * lower > numerator.
                            if (denominator < 0 && numerator < lower * denominator) {
                                // Increase lower.
                                // The segment enters this half-space.
                                lower = numerator / denominator;
                                index = i;
                            } else if (denominator > 0 && numerator < upper * denominator) {
                                // Decrease upper.
                                // The segment exits this half-space.
                                upper = numerator / denominator;
                            }
                        }
                        // The use of epsilon here causes the assert on lower to trip
                        // in some cases. Apparently the use of epsilon was to make edge
                        // shapes work, but now those are handled separately.
                        // if (upper < lower - Math.EPSILON)
                        if (upper < lower) {
                            return false;
                        }
                    }
                    //ASSERT && common.assert(0 <= lower && lower <= input.maxFraction);
                    if (index >= 0) {
                        output.fraction = lower;
                        output.normal = Rot.mul(xf.q, this.m_normals[index]);
                        return true;
                    }
                    return false;
                };

                PolygonShape.prototype.computeAABB = function (aabb, xf, childIndex) {
                    var minX = Infinity,
                        minY = Infinity;
                    var maxX = -Infinity,
                        maxY = -Infinity;
                    for (var i = 0; i < this.m_count; ++i) {
                        var v = Transform.mul(xf, this.m_vertices[i]);
                        minX = Math.min(minX, v.x);
                        maxX = Math.max(maxX, v.x);
                        minY = Math.min(minY, v.y);
                        maxY = Math.max(maxY, v.y);
                    }
                    aabb.lowerBound.set(minX, minY);
                    aabb.upperBound.set(maxX, maxY);
                    aabb.extend(this.m_radius);
                };

                PolygonShape.prototype.computeMass = function (massData, density) {
                    // Polygon mass, centroid, and inertia.
                    // Let rho be the polygon density in mass per unit area.
                    // Then:
                    // mass = rho * int(dA)
                    // centroid.x = (1/mass) * rho * int(x * dA)
                    // centroid.y = (1/mass) * rho * int(y * dA)
                    // I = rho * int((x*x + y*y) * dA)
                    //
                    // We can compute these integrals by summing all the integrals
                    // for each triangle of the polygon. To evaluate the integral
                    // for a single triangle, we make a change of variables to
                    // the (u,v) coordinates of the triangle:
                    // x = x0 + e1x * u + e2x * v
                    // y = y0 + e1y * u + e2y * v
                    // where 0 <= u && 0 <= v && u + v <= 1.
                    //
                    // We integrate u from [0,1-v] and then v from [0,1].
                    // We also need to use the Jacobian of the transformation:
                    // D = cross(e1, e2)
                    //
                    // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)
                    //
                    // The rest of the derivation is handled by computer algebra.
                    //ASSERT && common.assert(this.m_count >= 3);
                    var center = Vec2.zero();
                    var area = 0;
                    var I = 0;
                    // s is the reference point for forming triangles.
                    // It's location doesn't change the result (except for rounding error).
                    var s = Vec2.zero();
                    // This code would put the reference point inside the polygon.
                    for (var i = 0; i < this.m_count; ++i) {
                        s.add(this.m_vertices[i]);
                    }
                    s.mul(1 / this.m_count);
                    var k_inv3 = 1 / 3;
                    for (var i = 0; i < this.m_count; ++i) {
                        // Triangle vertices.
                        var e1 = Vec2.sub(this.m_vertices[i], s);
                        var e2 = i + 1 < this.m_count ? Vec2.sub(this.m_vertices[i + 1], s) : Vec2.sub(this.m_vertices[0], s);
                        var D = Vec2.cross(e1, e2);
                        var triangleArea = .5 * D;
                        area += triangleArea;
                        // Area weighted centroid
                        center.wAdd(triangleArea * k_inv3, e1, triangleArea * k_inv3, e2);
                        var ex1 = e1.x;
                        var ey1 = e1.y;
                        var ex2 = e2.x;
                        var ey2 = e2.y;
                        var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
                        var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;
                        I += .25 * k_inv3 * D * (intx2 + inty2);
                    }
                    // Total mass
                    massData.mass = density * area;
                    // Center of mass
                    //ASSERT && common.assert(area > Math.EPSILON);
                    center.mul(1 / area);
                    massData.center.wSet(1, center, 1, s);
                    // Inertia tensor relative to the local origin (point s).
                    massData.I = density * I;
                    // Shift to center of mass then to original body origin.
                    massData.I += massData.mass * (Vec2.dot(massData.center, massData.center) - Vec2.dot(center, center));
                };

                // Validate convexity. This is a very time consuming operation.
                // @returns true if valid
                PolygonShape.prototype.validate = function () {
                    for (var i = 0; i < this.m_count; ++i) {
                        var i1 = i;
                        var i2 = i < this.m_count - 1 ? i1 + 1 : 0;
                        var p = this.m_vertices[i1];
                        var e = Vec2.sub(this.m_vertices[i2], p);
                        for (var j = 0; j < this.m_count; ++j) {
                            if (j == i1 || j == i2) {
                                continue;
                            }
                            var v = Vec2.sub(this.m_vertices[j], p);
                            var c = Vec2.cross(e, v);
                            if (c < 0) {
                                return false;
                            }
                        }
                    }
                    return true;
                };

                PolygonShape.prototype.computeDistanceProxy = function (proxy) {
                    proxy.m_vertices = this.m_vertices;
                    proxy.m_count = this.m_count;
                    proxy.m_radius = this.m_radius;
                };
            }, { "../Settings": 7, "../Shape": 8, "../collision/AABB": 11, "../common/Math": 18, "../common/Rot": 20, "../common/Transform": 22, "../common/Vec2": 23, "../util/common": 50, "../util/create": 51, "../util/options": 52 }], 48: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports = Pool;

                function Pool(opts) {
                    var _list = [];
                    var _max = opts.max || Infinity;
                    var _createFn = opts.create;
                    var _outFn = opts.allocate;
                    var _inFn = opts.release;
                    var _discardFn = opts.discard;
                    var _createCount = 0;
                    var _outCount = 0;
                    var _inCount = 0;
                    var _discardCount = 0;
                    this.max = function (n) {
                        if (typeof n === "number") {
                            _max = n;
                            return this;
                        }
                        return _max;
                    };
                    this.size = function () {
                        return _list.length;
                    };
                    this.allocate = function () {
                        var item;
                        if (_list.length > 0) {
                            item = _list.shift();
                        } else {
                            _createCount++;
                            if (typeof _createFn === "function") {
                                item = _createFn();
                            } else {
                                item = {};
                            }
                        }
                        _outCount++;
                        if (typeof _outFn === "function") {
                            _outFn(item);
                        }
                        return item;
                    };
                    this.release = function (item) {
                        if (_list.length < _max) {
                            _inCount++;
                            if (typeof _inFn === "function") {
                                _inFn(item);
                            }
                            _list.push(item);
                        } else {
                            _discardCount++;
                            if (typeof _discardFn === "function") {
                                item = _discardFn(item);
                            }
                        }
                    };
                    this.toString = function () {
                        return " +" + _createCount + " >" + _outCount + " <" + _inCount + " -" + _discardCount + " =" + _list.length + "/" + _max;
                    };
                }
            }, {}], 49: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                module.exports.now = function () {
                    return Date.now();
                };

                module.exports.diff = function (time) {
                    return Date.now() - time;
                };
            }, {}], 50: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                exports.debug = function () {
                    //if (!DEBUG) return;
                    //console.log.apply(console, arguments);
                };

                exports.assert = function (statement, err, log) {
                    //if (!ASSERT) return;
                    if (statement) return;
                    log && console.log(log);
                    throw new Error(err);
                };
            }, {}], 51: [function (require, module, exports) {
                if (typeof Object.create == "function") {
                    module.exports = function (proto, props) {
                        return Object.create.call(Object, proto, props);
                    };
                } else {
                    var noop = function noop() {};

                    module.exports = function (proto, props) {
                        if (props) throw Error("Second argument is not supported!");
                        if ((typeof proto === 'undefined' ? 'undefined' : _typeof(proto)) !== "object" || proto === null) throw Error("Invalid prototype!");
                        noop.prototype = proto;
                        return new noop();
                    };
                }
            }, {}], 52: [function (require, module, exports) {
                //DEBUG = typeof DEBUG === "undefined" ? false : DEBUG;

                //ASSERT = typeof ASSERT === "undefined" ? false : ASSERT;

                var propIsEnumerable = Object.prototype.propertyIsEnumerable;

                module.exports = function (to, from) {
                    if (to === null || typeof to === "undefined") {
                        to = {};
                    }
                    for (var key in from) {
                        if (from.hasOwnProperty(key) && typeof to[key] === "undefined") {
                            to[key] = from[key];
                        }
                    }
                    if (typeof Object.getOwnPropertySymbols === "function") {
                        var symbols = Object.getOwnPropertySymbols(from);
                        for (var i = 0; i < symbols.length; i++) {
                            var symbol = symbols[i];
                            if (from.propertyIsEnumerable(symbol) && typeof to[key] === "undefined") {
                                to[symbol] = from[symbol];
                            }
                        }
                    }
                    return to;
                };
            }, {}] }, {}, [1])(1);
    });

    /***/
},
/* 33 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return actionManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__common_keycodeaction__ = __webpack_require__(71);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_defs__ = __webpack_require__(0);
    // 
    //  FILE NAME: actionmanager.js
    //  DESC:      Class for handling action mapping
    //


    var ActionManager = function () {
        function ActionManager() {
            _classCallCheck(this, ActionManager);

            this.keyboardKeyCodeMap = new Map();
            this.mouseKeyCodeMap = new Map();
            //this.gamepadKeyCodeMap = new Map;

            // Action maps
            this.keyboardActionMap = new Map();
            this.mouseActionMap = new Map();
            this.gamepadActionMap = new Map();

            // Flag to allow action handling
            this.allowAction = true;

            // Last device used
            this.lastDeviceUsed = __WEBPACK_IMPORTED_MODULE_2__common_defs__["h" /* DEVICE_NULL */];

            this.keyboardKeyCodeMap.set('---', -1);
            this.keyboardKeyCodeMap.set('RETURN', 13);
            this.keyboardKeyCodeMap.set('ESCAPE', 27);

            this.keyboardKeyCodeMap.set('ARROW UP', 38);
            this.keyboardKeyCodeMap.set('ARROW DOWN', 40);
            this.keyboardKeyCodeMap.set('ARROW LEFT', 37);
            this.keyboardKeyCodeMap.set('ARROW RIGHT', 39);

            this.keyboardKeyCodeMap.set('A', 'A'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('B', 'B'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('C', 'C'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('D', 'D'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('E', 'E'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('F', 'F'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('G', 'G'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('H', 'H'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('I', 'I'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('J', 'J'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('K', 'K'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('L', 'L'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('M', 'M'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('N', 'N'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('O', 'O'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('P', 'P'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('Q', 'Q'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('R', 'R'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('S', 'S'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('T', 'T'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('U', 'U'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('V', 'V'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('W', 'W'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('X', 'X'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('Y', 'Y'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('Z', 'Z'.charCodeAt(0));

            this.keyboardKeyCodeMap.set('0', '0'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('1', '1'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('2', '2'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('3', '3'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('4', '4'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('5', '5'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('6', '6'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('7', '7'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('8', '8'.charCodeAt(0));
            this.keyboardKeyCodeMap.set('9', '9'.charCodeAt(0));

            this.keyboardKeyCodeMap.set('F1', 112);
            this.keyboardKeyCodeMap.set('F2', 113);
            this.keyboardKeyCodeMap.set('F3', 114);
            this.keyboardKeyCodeMap.set('F4', 115);
            this.keyboardKeyCodeMap.set('F5', 116);
            this.keyboardKeyCodeMap.set('F6', 117);
            this.keyboardKeyCodeMap.set('F7', 118);
            this.keyboardKeyCodeMap.set('F8', 119);
            this.keyboardKeyCodeMap.set('F9', 120);
            this.keyboardKeyCodeMap.set('F10', 121);
            this.keyboardKeyCodeMap.set('F11', 122);
            this.keyboardKeyCodeMap.set('F12', 123);

            this.keyboardKeyCodeMap.set('NUMPAD 0', 96);
            this.keyboardKeyCodeMap.set('NUMPAD 1', 97);
            this.keyboardKeyCodeMap.set('NUMPAD 2', 98);
            this.keyboardKeyCodeMap.set('NUMPAD 3', 99);
            this.keyboardKeyCodeMap.set('NUMPAD 4', 100);
            this.keyboardKeyCodeMap.set('NUMPAD 5', 101);
            this.keyboardKeyCodeMap.set('NUMPAD 6', 102);
            this.keyboardKeyCodeMap.set('NUMPAD 7', 103);
            this.keyboardKeyCodeMap.set('NUMPAD 8', 104);
            this.keyboardKeyCodeMap.set('NUMPAD 9', 105);

            this.keyboardKeyCodeMap.set('NUM LOCK', 144);
            this.keyboardKeyCodeMap.set('NUMPAD /', 111);
            this.keyboardKeyCodeMap.set('NUMPAD *', 106);
            this.keyboardKeyCodeMap.set('NUMPAD -', 109);
            this.keyboardKeyCodeMap.set('NUMPAD +', 107);
            this.keyboardKeyCodeMap.set('NUMPAD ENTER', 13);
            this.keyboardKeyCodeMap.set('NUMPAD .', 110);

            this.keyboardKeyCodeMap.set('CTRL', 17);
            this.keyboardKeyCodeMap.set('SHIFT', 16);
            this.keyboardKeyCodeMap.set('ALT', 18);

            this.keyboardKeyCodeMap.set('PRINT SCREEN', 42);
            this.keyboardKeyCodeMap.set('SCROLL LOCK', 145);
            this.keyboardKeyCodeMap.set('PAUSE', 19);

            this.keyboardKeyCodeMap.set('END', 35);
            this.keyboardKeyCodeMap.set('INSERT', 45);
            this.keyboardKeyCodeMap.set('DELETE', 46);
            this.keyboardKeyCodeMap.set('HOME', 36);
            this.keyboardKeyCodeMap.set('PAGE UP', 33);
            this.keyboardKeyCodeMap.set('PAGE DOWN', 34);

            this.keyboardKeyCodeMap.set('BACKSPACE', 8);
            this.keyboardKeyCodeMap.set('TAB', 9);
            this.keyboardKeyCodeMap.set('SPACE', 32);
            this.keyboardKeyCodeMap.set(',', 188);
            this.keyboardKeyCodeMap.set('-', 173);
            this.keyboardKeyCodeMap.set('.', 190);
            this.keyboardKeyCodeMap.set('/', 191);
            this.keyboardKeyCodeMap.set('=', 61);

            this.keyboardKeyCodeMap.set(';', 59);
            this.keyboardKeyCodeMap.set('[', 219);
            this.keyboardKeyCodeMap.set('\\', 220);
            this.keyboardKeyCodeMap.set(']', 221);
            this.keyboardKeyCodeMap.set('`', 192);
            this.keyboardKeyCodeMap.set("'", 222);

            this.mouseKeyCodeMap.set('---', -1);
            this.mouseKeyCodeMap.set('LEFT MOUSE', 0);
            this.mouseKeyCodeMap.set('MIDDLE MOUSE', 1);
            this.mouseKeyCodeMap.set('RIGHT MOUSE', 2);
        }

        // 
        //  DESC: Load data from XML node
        //


        _createClass(ActionManager, [{
            key: 'load',
            value: function load(node) {
                if (node) {
                    // Load the keyboard/mouse/gamepad mapping
                    this.loadKeyboardMappingFromNode(node.getElementsByTagName('keyboardMapping'));
                    this.loadMouseMappingFromNode(node.getElementsByTagName('mouseMapping'));
                    //this.loadGamepadMappingFromNode( node.getElementsByTagName( 'gamepadMapping' ) );
                }
            }

            // 
            //  DESC: Load the keyboard mapping from node
            //

        }, {
            key: 'loadKeyboardMappingFromNode',
            value: function loadKeyboardMappingFromNode(node) {
                // Load the player hidden controls
                this.loadActionFromNode(node[0].getElementsByTagName('playerHidden'), this.keyboardKeyCodeMap, this.keyboardActionMap);

                // Load the player visible controls
                this.loadActionFromNode(node[0].getElementsByTagName('playerVisible'), this.keyboardKeyCodeMap, this.keyboardActionMap);
            }

            // 
            //  DESC: Load the keyboard mapping from node
            //

        }, {
            key: 'loadMouseMappingFromNode',
            value: function loadMouseMappingFromNode(node) {
                // Load the player hidden controls
                this.loadActionFromNode(node[0].getElementsByTagName('playerHidden'), this.mouseKeyCodeMap, this.mouseActionMap);

                // Load the player visible controls
                this.loadActionFromNode(node[0].getElementsByTagName('playerVisible'), this.mouseKeyCodeMap, this.mouseActionMap);
            }

            // 
            //  DESC: Load the keyboard mapping from node
            //
            /*loadGamepadMappingFromNode( node )
            {
                // Load the player hidden controls
                LoadActionFromNode( node[0].getElementsByTagName("playerHidden"), this.gamepadKeyCodeMap, this.gamepadActionMap );
                 // Load the player visible controls
                LoadActionFromNode( node[0].getElementsByTagName("playerVisible"), this.gamepadKeyCodeMap, this.gamepadActionMap );
            }*/

            // 
            //  DESC: Load action data from xml node
            //

        }, {
            key: 'loadActionFromNode',
            value: function loadActionFromNode(node, keyCodeMap, actionMap) {
                if (node.length) {
                    var actionNode = node[0].getElementsByTagName('actionMap');

                    for (var i = 0; i < actionNode.length; ++i) {
                        // See if we can find the string that represents the key code id
                        var componentIdStr = actionNode[i].getAttribute('componetId');
                        var keyCode = keyCodeMap.get(componentIdStr);

                        // Add it in if we found it
                        if (keyCode !== undefined) {
                            var actionStr = actionNode[i].getAttribute('action');

                            // See if the controller action string has already been added
                            var action = actionMap.get(actionStr);

                            if (action !== undefined) {
                                // If it's found, add another id to this map
                                action.setId(keyCode);
                            } else {
                                // Add new action to the map
                                actionMap.set(actionStr, new __WEBPACK_IMPORTED_MODULE_0__common_keycodeaction__["a" /* KeyCodeAction */](keyCode));
                            }
                        }
                    }
                }
            }

            // 
            //  DESC: Was this an action
            //

        }, {
            key: 'wasActionPress',
            value: function wasActionPress(event, actionStr, actionPress) {
                if (this.wasAction(event, actionStr) === actionPress) return true;

                return false;
            }

            // 
            //  DESC: Was this an action
            //

        }, {
            key: 'wasAction',
            value: function wasAction(event, actionStr) {
                var result = __WEBPACK_IMPORTED_MODULE_2__common_defs__["l" /* EAP_IDLE */];

                if (this.allowAction) {
                    // Check for keyboard event
                    if (event instanceof KeyboardEvent) {
                        this.lastDeviceUsed = __WEBPACK_IMPORTED_MODULE_2__common_defs__["_56" /* KEYBOARD */];

                        if (this.wasActionMap(event.keyCode, actionStr, this.keyboardActionMap)) {
                            result = __WEBPACK_IMPORTED_MODULE_2__common_defs__["m" /* EAP_UP */];

                            // Check for the "D" character code for keydown
                            if (event.type.charCodeAt(3) === 100) {
                                result = __WEBPACK_IMPORTED_MODULE_2__common_defs__["k" /* EAP_DOWN */];
                            }
                        }
                    }
                    // Check for mouse event
                    else if (event instanceof MouseEvent) {
                            this.lastDeviceUsed = __WEBPACK_IMPORTED_MODULE_2__common_defs__["_57" /* MOUSE */];

                            if (this.wasActionMap(event.button, actionStr, this.mouseActionMap)) {
                                result = __WEBPACK_IMPORTED_MODULE_2__common_defs__["m" /* EAP_UP */];

                                // Check for the "D" character code for mousedown
                                if (event.type.charCodeAt(5) === 100) {
                                    result = __WEBPACK_IMPORTED_MODULE_2__common_defs__["k" /* EAP_DOWN */];
                                }
                            }
                        }
                }

                return result;
            }

            // 
            //  DESC: Was this an action
            //

        }, {
            key: 'wasActionMap',
            value: function wasActionMap(id, actionStr, actionMap) {
                var result = false;

                // See if the action has already been added
                var action = actionMap.get(actionStr);

                // If it's found, see if this is the correct action
                if (action !== undefined) {
                    result = action.wasAction(id);
                }

                return result;
            }

            // 
            //  DESC: What was the last device
            //

        }, {
            key: 'wasLastDeviceGamepad',
            value: function wasLastDeviceGamepad() {
                return this.lastDeviceUsed === __WEBPACK_IMPORTED_MODULE_2__common_defs__["_55" /* GAMEPAD */];
            }
        }, {
            key: 'wasLastDeviceKeyboard',
            value: function wasLastDeviceKeyboard() {
                return this.lastDeviceUsed === __WEBPACK_IMPORTED_MODULE_2__common_defs__["_56" /* KEYBOARD */];
            }
        }, {
            key: 'wasLastDeviceMouse',
            value: function wasLastDeviceMouse() {
                return this.lastDeviceUsed === __WEBPACK_IMPORTED_MODULE_2__common_defs__["_57" /* MOUSE */];
            }
        }]);

        return ActionManager;
    }();

    var actionManager = new ActionManager();

    /***/
},
/* 34 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (immutable) */
    __webpack_exports__["a"] = create;
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__managers_signalmanager__ = __webpack_require__(18);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__uilabel__ = __webpack_require__(81);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__uibutton__ = __webpack_require__(82);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__uisubcontrol__ = __webpack_require__(27);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__uibuttonlist__ = __webpack_require__(83);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__uicheckbox__ = __webpack_require__(84);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__uislider__ = __webpack_require__(85);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__uiscrollbox__ = __webpack_require__(86);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__uimeter__ = __webpack_require__(87);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__uiprogressbar__ = __webpack_require__(45);
    // 
    //  FILE NAME: uicontrolfactory.js
    //  DESC:      factory for control creation
    //


    // 
    //  DESC: Load the control info from XML node
    //
    function create(node, group) {
        var control = null;

        // Get the control type. This is required
        var ctrlType = node.getAttribute('controlType');

        // New up the control with its respected control type
        if (ctrlType === 'label') control = new __WEBPACK_IMPORTED_MODULE_1__uilabel__["a" /* UILabel */](group);else if (ctrlType === 'button') control = new __WEBPACK_IMPORTED_MODULE_2__uibutton__["a" /* UIButton */](group);else if (ctrlType === 'sub_control') control = new __WEBPACK_IMPORTED_MODULE_3__uisubcontrol__["a" /* UISubControl */](group);else if (ctrlType === 'button_list') control = new __WEBPACK_IMPORTED_MODULE_4__uibuttonlist__["a" /* UIButtonList */](group);else if (ctrlType === 'check_box') control = new __WEBPACK_IMPORTED_MODULE_5__uicheckbox__["a" /* UICheckBox */](group);else if (ctrlType === 'slider') control = new __WEBPACK_IMPORTED_MODULE_6__uislider__["a" /* UISlider */](group);else if (ctrlType === 'scroll_box') control = new __WEBPACK_IMPORTED_MODULE_7__uiscrollbox__["a" /* UIScrollBox */](group);else if (ctrlType === 'meter') control = new __WEBPACK_IMPORTED_MODULE_8__uimeter__["a" /* UIMeter */](group);else if (ctrlType === 'progress_bar') control = new __WEBPACK_IMPORTED_MODULE_9__uiprogressbar__["a" /* UIProgressBar */](group);else throw new Error('UI Control not defined! (' + ctrlType + ')');

        // Have the control load it's share
        control.loadFromNode(node);

        // Broadcast signal to let the game handle smart gui inits
        __WEBPACK_IMPORTED_MODULE_0__managers_signalmanager__["a" /* signalManager */].broadcast_smartGui(control);

        // Do any smart gui Create
        control.smartCreate();

        return control;
    }

    /***/
},
/* 35 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return soundManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__managers_managerbase__ = __webpack_require__(23);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_sound__ = __webpack_require__(90);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_playlist__ = __webpack_require__(91);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__utilities_assetholder__ = __webpack_require__(12);

    // 
    //  FILE NAME: soundmanager.js
    //  DESC:      Sound Manager class singleton
    //


    var SoundManager = function (_WEBPACK_IMPORTED_MO7) {
        _inherits(SoundManager, _WEBPACK_IMPORTED_MO7);

        function SoundManager() {
            _classCallCheck(this, SoundManager);

            var _this15 = _possibleConstructorReturn(this, (SoundManager.__proto__ || Object.getPrototypeOf(SoundManager)).call(this));

            _this15.context = null;

            if (typeof AudioContext !== 'undefined') _this15.context = new AudioContext();else if (typeof webkitAudioContext !== 'undefined') _this15.context = new webkitAudioContext();else throw new Error('AudioContext not supported.');

            // Map containing a group of sound ID's
            _this15.soundMapMap = new Map();

            // Map containing a group of play list ID's
            // Do not free the sounds copied to the play list
            _this15.playListMapMap = new Map();
            return _this15;
        }

        //
        //  DESC: Load all XML's associated with this group
        //


        _createClass(SoundManager, [{
            key: 'loadGroup',
            value: function loadGroup(groupAry, finishCallback) {
                _get(SoundManager.prototype.__proto__ || Object.getPrototypeOf(SoundManager.prototype), 'loadGroup', this).call(this, 'Sound', this.soundMapMap, groupAry, finishCallback);
            }

            //
            //  DESC: Load sound data from an xml node
            //

        }, {
            key: 'loadFromNode',
            value: function loadFromNode(group, node, filePath, finishCallback) {
                var _this16 = this;

                // Get the group map
                var groupMap = this.soundMapMap.get(group);

                // Get the node to the sound files to be loaded into a buffer
                var loadFilesNode = node.getElementsByTagName('load');

                // Load the buffered sounds

                var _loop3 = function _loop3(i) {
                    var id = loadFilesNode[i].getAttribute('id');
                    var filePath = loadFilesNode[i].getAttribute('file');

                    // Check for duplicate names
                    if (groupMap.has(id)) throw new Error('Duplicate sound group id (' + id + ', ' + group + ', ' + filePath + ')!');

                    var snd = new __WEBPACK_IMPORTED_MODULE_1__common_sound__["a" /* Sound */]();
                    groupMap.set(id, snd);

                    // Load from node
                    snd.loadFromNode(loadFilesNode[i]);

                    // Check if this file has already been loaded
                    if (!__WEBPACK_IMPORTED_MODULE_3__utilities_assetholder__["a" /* assetHolder */].has(group, filePath)) {
                        _this16.downloadFile('binary', group, filePath, finishCallback, function (group, audioData, filePath, finishCallback) {
                            // Store the preloaded XML file
                            __WEBPACK_IMPORTED_MODULE_3__utilities_assetholder__["a" /* assetHolder */].set(group, filePath, audioData);

                            // Call the class function to load the data
                            _this16.loadFromBinaryData(group, id, audioData, filePath, finishCallback);
                        });
                    } else {
                        _this16.loadFromBinaryData(group, id, __WEBPACK_IMPORTED_MODULE_3__utilities_assetholder__["a" /* assetHolder */].get(group, filePath), filePath);
                    }
                };

                for (var i = 0; i < loadFilesNode.length; ++i) {
                    _loop3(i);
                }

                // Get the node to the sound files
                var playListNode = node.getElementsByTagName('playList');
                if (playListNode.length) {
                    var _groupMap = new Map();
                    this.playListMapMap.set(group, _groupMap);

                    for (var i = 0; i < playListNode.length; ++i) {
                        // Get the id
                        var _id = playListNode[i].getAttribute('id');

                        // Check for duplicate names
                        if (_groupMap.has(_id)) throw new Error('Duplicate playlist group id (' + _id + ', ' + group + ', ' + filePath + ')!');

                        // Add the playlist data to the map
                        var playLst = new __WEBPACK_IMPORTED_MODULE_2__common_playlist__["a" /* PlayList */]();
                        _groupMap.set(_id, playLst);

                        // Load the playlist from node
                        playLst.loadFromNode(playListNode[i], this.soundMapMap.get(group), group, filePath);
                    }
                }
            }

            //
            //  DESC: Load from binary data
            //

        }, {
            key: 'loadFromBinaryData',
            value: function loadFromBinaryData(group, id, audioData, filePath, finishCallback) {
                var _this17 = this;

                // Increment the load counter because the decoder is asynchronous
                ++this.loadCounter;

                // Get the group map
                var groupMap = this.soundMapMap.get(group);

                // Get the sound
                var sound = groupMap.get(id);

                // Create a sound buffer and decode
                this.context.decodeAudioData(audioData, function (soundBuffer) {
                    sound.init(_this17.context, soundBuffer);

                    // Decrement the load counter
                    --_this17.loadCounter;

                    if (_this17.loadCounter === 0) finishCallback();
                }, function (error) {
                    return console.log('Error decoding audio data (' + error.err + ')!');
                });
            }

            //
            //  DESC: Free a symbol group
            //

        }, {
            key: 'freeGroup',
            value: function freeGroup(groupAry) {
                for (var grp = 0; grp < groupAry.length; ++grp) {
                    var group = groupAry[grp];

                    // Make sure the group we are looking for exists
                    if (this.listTableMap.get(group) === undefined) throw new Error('Sound group name can\'t be found (' + group + ')!');

                    // Erase the group
                    if (this.soundMapMap.has(group)) this.soundMapMap.delete(group);

                    if (this.playListMapMap.has(group)) this.playListMapMap.delete(group);
                }
            }

            //
            //  DESC: Get the sound
            //

        }, {
            key: 'getSound',
            value: function getSound(group, soundID) {
                // Check if this is a playlist sound ID
                var playLst = this.getPlayList(group, soundID);
                if (playLst) {
                    return playLst.getSound();
                }

                var groupMap = this.soundMapMap.get(group);
                if (!groupMap) throw new Error('Sound group name can\'t be found (' + group + ')!');

                var snd = groupMap.get(soundID);
                if (!snd) throw new Error('Sound ID can\'t be found (' + group + ', ' + soundID + ')!');

                return snd;
            }

            //
            //  DESC: Get the playlist
            //

        }, {
            key: 'getPlayList',
            value: function getPlayList(group, playLstID) {
                // Check if this is a playlist sound ID
                var groupMap = this.playListMapMap.get(group);
                if (groupMap) {
                    return groupMap.get(playLstID);
                }

                return undefined;
            }

            //
            //  DESC: Play a sound
            //

        }, {
            key: 'play',
            value: function play(group, soundID) {
                var loop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

                this.getSound(group, soundID).play(loop);
            }

            //
            //  DESC: Pause a sound
            //

        }, {
            key: 'pause',
            value: function pause(group, soundID) {
                this.getSound(group, soundID).pause();
            }

            //
            //  DESC: Resume a sound
            //

        }, {
            key: 'resume',
            value: function resume(group, soundID) {
                this.getSound(group, soundID).resume();
            }

            //
            //  DESC: Resume a sound
            //

        }, {
            key: 'stop',
            value: function stop(group, soundID) {
                this.getSound(group, soundID).stop();
            }

            //
            //  DESC: Set/Get the volume for music or channel
            //

        }, {
            key: 'setVolume',
            value: function setVolume(group, soundID, volume) {
                this.getSound(group, soundID).setVolume(volume);
            }
        }, {
            key: 'getVolume',
            value: function getVolume(group, soundID) {
                return this.getSound(group, soundID).getVolume();
            }

            //
            //  DESC: Is music or channel playing?
            //

        }, {
            key: 'isPlaying',
            value: function isPlaying(group, soundID) {
                return this.getSound(group, soundID).isPlaying();
            }

            //
            //  DESC: Is music or channel paused?
            //

        }, {
            key: 'isPaused',
            value: function isPaused(group, soundID) {
                return this.getSound(group, soundID).isPaused();
            }
        }]);

        return SoundManager;
    }(__WEBPACK_IMPORTED_MODULE_0__managers_managerbase__["a" /* ManagerBase */]);

    var soundManager = new SoundManager();

    /***/
},
/* 36 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (immutable) */
    __webpack_exports__["b"] = load;
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__commonstate__ = __webpack_require__(47);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__library_2d_sprite2d__ = __webpack_require__(13);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__library_3d_sprite3d__ = __webpack_require__(93);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__library_utilities_camera__ = __webpack_require__(95);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__ = __webpack_require__(11);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__library_managers_shadermanager__ = __webpack_require__(15);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__library_gui_menumanager__ = __webpack_require__(24);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__library_system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__library_script_scriptcomponent__ = __webpack_require__(21);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__library_utilities_highresolutiontimer__ = __webpack_require__(8);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__library_script_scriptmanager__ = __webpack_require__(14);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_11__library_managers_loadmanager__ = __webpack_require__(28);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_12__gamestate__ = __webpack_require__(22);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_13__library_common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: titlescreenstate.js
    //  DESC:      titles screen state class
    //


    var TitleScreenState = function (_WEBPACK_IMPORTED_MO8) {
        _inherits(TitleScreenState, _WEBPACK_IMPORTED_MO8);

        function TitleScreenState() {
            var gameLoopCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            _classCallCheck(this, TitleScreenState);

            var _this18 = _possibleConstructorReturn(this, (TitleScreenState.__proto__ || Object.getPrototypeOf(TitleScreenState)).call(this, __WEBPACK_IMPORTED_MODULE_12__gamestate__["d" /* GAME_STATE_TITLESCREEN */], __WEBPACK_IMPORTED_MODULE_12__gamestate__["a" /* GAME_STATE_LOAD */], gameLoopCallback));

            _this18.background = new __WEBPACK_IMPORTED_MODULE_1__library_2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(title_screen)', 'background'));
            _this18.background.transform();

            _this18.camera = new __WEBPACK_IMPORTED_MODULE_3__library_utilities_camera__["a" /* Camera */]();
            _this18.camera.setPosXYZ(0, 0, 20);
            _this18.camera.setRotXYZ(10, 0, 0);

            _this18.cube = new __WEBPACK_IMPORTED_MODULE_2__library_3d_sprite3d__["a" /* Sprite3D */](__WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(cube)', 'cube'));
            _this18.cube.setScaleXYZ(3, 3, 3);

            // Create the script component and add a script
            _this18.scriptComponent = new __WEBPACK_IMPORTED_MODULE_8__library_script_scriptcomponent__["a" /* ScriptComponent */]();
            _this18.scriptComponent.set(__WEBPACK_IMPORTED_MODULE_10__library_script_scriptmanager__["a" /* scriptManager */].get('ScreenFade')(0, 1, 500));

            //let meter = menuManager.getMenuControl( 'title_screen_menu', 'meter' );
            //meter.startBangUp( 10000000 );
            return _this18;
        }

        // 
        //  DESC: Do any pre-game loop init's
        //


        _createClass(TitleScreenState, [{
            key: 'init',
            value: function init() {
                // Unblock the menu messaging and activate needed trees
                __WEBPACK_IMPORTED_MODULE_6__library_gui_menumanager__["a" /* menuManager */].allowEventHandling = true;
                __WEBPACK_IMPORTED_MODULE_6__library_gui_menumanager__["a" /* menuManager */].activateTree(['title_screen_tree']);

                // Reset the elapsed time before entering the render loop
                __WEBPACK_IMPORTED_MODULE_9__library_utilities_highresolutiontimer__["a" /* highResTimer */].calcElapsedTime();

                // Start the game loop
                requestAnimationFrame(this.callback);
            }

            // 
            //  DESC: Clean up after the startup state
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                unload();
            }

            // 
            //  DESC: handle events
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                _get(TitleScreenState.prototype.__proto__ || Object.getPrototypeOf(TitleScreenState.prototype), 'handleEvent', this).call(this, event);

                if (event instanceof CustomEvent) {
                    // Check for the "game change state" message
                    if (event.detail.type === __WEBPACK_IMPORTED_MODULE_13__library_common_defs__["Z" /* EGE_MENU_GAME_STATE_CHANGE */]) {
                        if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_13__library_common_defs__["_50" /* ETC_BEGIN */]) this.scriptComponent.set(__WEBPACK_IMPORTED_MODULE_10__library_script_scriptmanager__["a" /* scriptManager */].get('ScreenFade')(1, 0, 500, true));
                    }
                }
            }

            // 
            //  DESC: Update objects that require them
            //

        }, {
            key: 'update',
            value: function update() {
                _get(TitleScreenState.prototype.__proto__ || Object.getPrototypeOf(TitleScreenState.prototype), 'update', this).call(this);

                this.scriptComponent.update();

                var rot = __WEBPACK_IMPORTED_MODULE_9__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime * 0.04;
                this.cube.incRotXYZ(0, rot, 0);
            }

            // 
            //  DESC: Transform the game objects
            //

        }, {
            key: 'transform',
            value: function transform() {
                _get(TitleScreenState.prototype.__proto__ || Object.getPrototypeOf(TitleScreenState.prototype), 'transform', this).call(this);

                this.camera.transform();
                this.cube.transform();
            }

            // 
            //  DESC: 2D/3D Render of game content
            //

        }, {
            key: 'preRender',
            value: function preRender() {
                _get(TitleScreenState.prototype.__proto__ || Object.getPrototypeOf(TitleScreenState.prototype), 'preRender', this).call(this);

                this.background.render(__WEBPACK_IMPORTED_MODULE_7__library_system_device__["a" /* device */].orthographicMatrix);
                this.cube.render(__WEBPACK_IMPORTED_MODULE_7__library_system_device__["a" /* device */].perspectiveMatrix, this.camera);
            }

            // 
            //  DESC: 2D/3D Render of game content
            //

        }, {
            key: 'postRender',
            value: function postRender() {
                _get(TitleScreenState.prototype.__proto__ || Object.getPrototypeOf(TitleScreenState.prototype), 'postRender', this).call(this);
            }
        }]);

        return TitleScreenState;
    }(__WEBPACK_IMPORTED_MODULE_0__commonstate__["a" /* CommonState */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = TitleScreenState;

    // 
    //  DESC: Unload files
    //
    function unload() {
        __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].freeGroup(['(title_screen)', '(cube)']);
    }

    // 
    //  DESC: Load files
    //
    function load() {
        // Load the xml group
        __WEBPACK_IMPORTED_MODULE_11__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadXMLGroup2D(['(title_screen)'], callback);
        });

        // Load all the textures associated with this group
        __WEBPACK_IMPORTED_MODULE_11__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadTextureGroup2D(['(title_screen)'], callback);
        });

        // Load all the meshes associated with this group
        __WEBPACK_IMPORTED_MODULE_11__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadMeshGroup2D(['(title_screen)'], callback);
        });

        // Create OpenGL objects from the loaded data
        __WEBPACK_IMPORTED_MODULE_11__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].createFromData(['(title_screen)'], callback);
        });

        // Load the object data list table and (startup) group
        __WEBPACK_IMPORTED_MODULE_11__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadXMLGroup3D(['(cube)'], callback);
        });

        // Load all the meshes associated with this group
        __WEBPACK_IMPORTED_MODULE_11__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadMeshGroup3D(['(cube)'], callback);
        });

        // Load all the textures associated with this group
        __WEBPACK_IMPORTED_MODULE_11__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadTextureGroup3D(['(cube)'], callback);
        });

        // Combine the meshes with their textures
        __WEBPACK_IMPORTED_MODULE_11__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].createFromData(['(cube)'], callback);
        });
    }

    /***/
},
/* 37 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__size__ = __webpack_require__(1);

    //
    //  FILE NAME: texture.js
    //  DESC:      Class for holding texture data
    //


    var Texture = function Texture() {
        _classCallCheck(this, Texture);

        // OpenGL texture ID
        this.id = 0;

        // Texture type (diffuse, normal, specular, displacement, etc)
        this.type = 0;

        // Texture size - mostly needed for 2D
        this.size = new __WEBPACK_IMPORTED_MODULE_0__size__["a" /* Size */]();
    };
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Texture;

    /***/
},
/* 38 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return fontManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__2d_font__ = __webpack_require__(63);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_genfunc__ = __webpack_require__(3);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__managers_texturemanager__ = __webpack_require__(6);

    //
    //  FILE NAME: fontmanager.js
    //  DESC:      font manager class singleton
    //


    var FontManager = function () {
        function FontManager() {
            _classCallCheck(this, FontManager);

            // map list of fonts
            this.fontMap = new Map();

            // Group name
            this.group = '';

            // Load helpers
            this.loadCompleteCallback = null;
            this.loadCounter = 0;
        }

        //
        //  DESC: Load the fonts from xml node
        //


        _createClass(FontManager, [{
            key: 'load',
            value: function load(node, callback) {
                if (node) {
                    this.loadCompleteCallback = callback;

                    // Get the group the textures will be saves as
                    var listGroupNode = node.getElementsByTagName('listGroup');
                    this.group = listGroupNode[0].getAttribute('name');

                    // Get the list of font info
                    var fontNode = node.getElementsByTagName('font');

                    for (var i = 0; i < fontNode.length; ++i) {
                        // Get the name of the font
                        var _name6 = fontNode[i].getAttribute('name');

                        // Sanity check to make sure the font has not already been added in
                        if (this.fontMap.has(_name6)) {
                            throw new Error('Font name has already been loaded (' + _name6 + ').');
                            return;
                        }

                        // Add the font to our list
                        this.fontMap.set(_name6, new __WEBPACK_IMPORTED_MODULE_0__2d_font__["a" /* Font */]());

                        // Use a counter to determine when the load is done because there's
                        // no garentee they will finish in the order executed.
                        // Always do this before the load
                        ++this.loadCounter;

                        // Load the character info from file
                        this.downloadFontFiles(_name6, fontNode[i].getAttribute('file'));
                    }
                }
            }

            //
            //  DESC: Download the XML and texture via file path
            //

        }, {
            key: 'downloadFontFiles',
            value: function downloadFontFiles(name, filePath) {
                var _this19 = this;

                // Create the vertex shader
                __WEBPACK_IMPORTED_MODULE_1__utilities_genfunc__["b" /* downloadFile */]('img', filePath + '.png', function (image) {
                    // Load the image as a texture in the texture manager
                    __WEBPACK_IMPORTED_MODULE_2__managers_texturemanager__["a" /* textureManager */].load(_this19.group, name, image);

                    __WEBPACK_IMPORTED_MODULE_1__utilities_genfunc__["b" /* downloadFile */]('xml', filePath + '.fnt', function (xmlNode) {
                        // Load the font
                        _this19.loadFont(name, xmlNode);

                        // Always do this after the load
                        --_this19.loadCounter;

                        if (_this19.loadCounter === 0) {
                            _this19.loadCompleteCallback();
                        }
                    });
                });
            }

            //
            //  DESC: Load the font
            //

        }, {
            key: 'loadFont',
            value: function loadFont(name, xmlNode) {
                var font = this.fontMap.get(name);
                if (font === undefined) throw new Error('Font name has not been added to the map (' + name + ').');

                font.loadFromNode(this.group, name, xmlNode);
            }

            //
            //  DESC: Get the font
            //

        }, {
            key: 'getFont',
            value: function getFont(name) {
                var font = this.fontMap.get(name);
                if (font === undefined) throw new Error('Font name can\'t be found (' + name + ').');

                return font;
            }

            // 
            //  DESC: allow event handling access function
            //

        }, {
            key: 'groupName',
            get: function get() {
                return this.group;
            }
        }]);

        return FontManager;
    }();

    var fontManager = new FontManager();

    /***/
},
/* 39 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return spriteSheetManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__common_spritesheet__ = __webpack_require__(40);

    //
    //  FILE NAME: spritesheetmanager.js
    //  DESC:      Temporary container for loading sprite sheet data
    //             so that the same large complex xml is not reloaded.
    //


    var SpriteSheetManager = function () {
        function SpriteSheetManager() {
            _classCallCheck(this, SpriteSheetManager);

            this.spriteSheetMap = new Map();
        }

        //
        //  DESC: Load the glyph data from XML node
        //


        _createClass(SpriteSheetManager, [{
            key: 'loadFromNode',
            value: function loadFromNode(filePath, node) {
                var spriteSheet = this.spriteSheetMap.get(filePath);
                if (spriteSheet === undefined) {
                    spriteSheet = new __WEBPACK_IMPORTED_MODULE_0__common_spritesheet__["a" /* SpriteSheet */]();

                    // Load the glyph data from XML node
                    spriteSheet.loadFromNode(node);

                    // Add a new entry to the map
                    this.spriteSheetMap.set(filePath, spriteSheet);
                }
            }

            //
            //  DESC: Load the glyph data from XML node
            //

        }, {
            key: 'getSpriteSheet',
            value: function getSpriteSheet(filePath) {
                var spriteSheet = this.spriteSheetMap.get(filePath);
                if (spriteSheet === undefined) throw new Error('Sprite sheet mesh file missing (' + filePath + ')!');

                return spriteSheet;
            }

            //
            //  DESC: Clear all the sprite sheet data
            //

        }, {
            key: 'clear',
            value: function clear() {
                this.spriteSheetMap.clear();
            }
        }]);

        return SpriteSheetManager;
    }();

    var spriteSheetManager = new SpriteSheetManager();

    /***/
},
/* 40 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_spritesheetglyph__ = __webpack_require__(64);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_rect__ = __webpack_require__(20);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__utilities_xmlparsehelper__ = __webpack_require__(4);

    // 
    //  FILE NAME:  spritesheet.js
    //  DESC:       Class for holding sprite sheet data
    //


    var SpriteSheet = function () {
        function SpriteSheet() {
            var defaultIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var glyphCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var columns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            _classCallCheck(this, SpriteSheet);

            // Sprite Sheet default index
            this.defaultIndex = defaultIndex;

            // Sprite Sheet element count
            this.glyphCount = glyphCount;

            // Sprite Sheet columns
            this.columns = columns;

            // An array of all the glyphs built manually that are of the same size
            this.glyphAry = null;

            // A map of all the glyphs
            this.glyphMap = null;
        }

        // 
        //  DESC: Copy the passed in data
        //


        _createClass(SpriteSheet, [{
            key: 'copy',
            value: function copy(obj) {
                this.defaultIndex = obj.defaultIndex;
                this.glyphCount = obj.glyphCount;
                this.columns = obj.columns;

                if (obj.glyphAry) {
                    if (this.glyphAry === null) this.glyphAry = [];

                    for (var i = 0; i < obj.glyphAry.length; ++i) {
                        var glyph = obj.glyphAry[i];
                        var size = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */](glyph.size.w, glyph.size.h);
                        var rect = new __WEBPACK_IMPORTED_MODULE_2__common_rect__["a" /* Rect */](glyph.uv.x1, glyph.uv.y1, glyph.uv.x2, glyph.uv.y2);
                        var cropOffset = null;
                        if (glyph.cropOffset) cropOffset = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */](glyph.cropOffset.w, glyph.cropOffset.h);

                        this.glyphAry.push(new __WEBPACK_IMPORTED_MODULE_0__common_spritesheetglyph__["a" /* SpriteSheetGlyph */](size, rect, cropOffset));
                    }
                }
            }

            // 
            //  DESC: Build the simple (grid) sprite sheet data
            //

        }, {
            key: 'build',
            value: function build(sheetSize) {
                if (this.glyphCount != 0 && this.columns != 0) {
                    this.glyphAry = [];

                    var rows = Math.trunc(this.glyphCount / this.columns);

                    if (this.glyphCount % this.columns > 0) ++rows;

                    // Calculate the size of the individual glyph. They are all the same size
                    var size = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */](sheetSize.w / this.columns, sheetSize.h / rows);

                    for (var i = 0; i < rows; ++i) {
                        for (var j = 0; j < this.columns; ++j) {
                            var rect = new __WEBPACK_IMPORTED_MODULE_2__common_rect__["a" /* Rect */](j * size.w / sheetSize.w, i * size.h / sheetSize.h, size.w / sheetSize.w, size.h / sheetSize.h);

                            this.glyphAry.push(new __WEBPACK_IMPORTED_MODULE_0__common_spritesheetglyph__["a" /* SpriteSheetGlyph */](size, rect));

                            // Break out after all the gylphs have been defined
                            if (this.glyphAry.length === this.glyphCount) break;
                        }
                    }
                }
            }

            // 
            //  DESC: Load the glyph data from XML node
            //

        }, {
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                this.glyphMap = new Map();

                var sheetSize = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */]();
                var attr = node.getAttribute('width');
                if (attr) sheetSize.w = Number(attr);

                attr = node.getAttribute('height');
                if (attr) sheetSize.h = Number(attr);

                var rectNode = node.getElementsByTagName('rect');
                if (rectNode.length) {
                    for (var i = 0; i < rectNode.length; ++i) {
                        var rect = __WEBPACK_IMPORTED_MODULE_3__utilities_xmlparsehelper__["g" /* loadRectFromChild */](rectNode[i]);

                        var size = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */](rect.x2, rect.y2);

                        var uv = new __WEBPACK_IMPORTED_MODULE_2__common_rect__["a" /* Rect */](rect.x1 / sheetSize.w, rect.y1 / sheetSize.h, rect.x2 / sheetSize.w, rect.y2 / sheetSize.h);

                        var cropOffset = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */](Number(rectNode[i].getAttribute('cx')), Number(rectNode[i].getAttribute('cy')));

                        // Add to the map
                        var strId = rectNode[i].getAttribute('name');
                        this.glyphMap.set(strId, new __WEBPACK_IMPORTED_MODULE_0__common_spritesheetglyph__["a" /* SpriteSheetGlyph */](size, uv, cropOffset));
                    }
                }
            }

            // 
            //  DESC: Load the glyph data from XML node
            //

        }, {
            key: 'getGlyph',
            value: function getGlyph() {
                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

                if (index > -1) return this.glyphAry[index];else return this.glyphAry[this.defaultIndex];
            }

            // 
            //  DESC: Find the glyph by Id
            //

        }, {
            key: 'findGlyph',
            value: function findGlyph(glyphId) {
                var glyph = this.glyphMap.get(glyphId);
                if (glyph === undefined) {
                    throw new Error('Glyph name is missing (' + glyphId + ')!');
                }

                return glyph;
            }

            // 
            //  DESC: Set the gylph data
            //

        }, {
            key: 'setGlyph',
            value: function setGlyph(spriteSheet, glyphId) {
                var glyph = this.glyphMap.get(glyphId);
                if (glyph !== undefined) {
                    if (spriteSheet.glyphAry === null) spriteSheet.glyphAry = [];

                    spriteSheet.glyphAry.push(glyph);
                } else {
                    throw new Error('Glyph name is missing (' + glyphId + ')!');
                }
            }

            // 
            //  DESC: Get the number of gylphs in this sprite sheet
            //

        }, {
            key: 'getCount',
            value: function getCount() {
                if (this.glyphAry !== null && this.glyphAry.length) return this.glyphAry.length;else if (this.glyphMap !== null && this.glyphMap.length) return this.glyphMap.length;

                return this.glyphCount;
            }

            // 
            //  DESC: Copy over the gylph data
            //

        }, {
            key: 'copyTo',
            value: function copyTo(spriteSheet, strIdAry) {
                if (strIdAry.length === 0) {
                    spriteSheet.glyphAry = this.glyphAry;
                } else if (this.glyphMap.size) {
                    // Init the sprite sheet class when each glyph is defined in the object data
                    if (spriteSheet.glyphCount === 0) {
                        for (var i = 0; i < strIdAry.length; ++i) {
                            this.setGlyph(spriteSheet, strIdAry[i]);
                        }
                    }
                    // Init the sprite sheet class with an animation that is one glyph defined with a format code
                    else {
                            // Should only be one entry
                            if (strIdAry.length === 1) {
                                for (var _i7 = 0; _i7 < spriteSheet.glyphCount; ++_i7) {
                                    this.setGlyph(spriteSheet, strIdAry[0] + _i7);
                                }
                            } else {
                                throw new Error('Sprite Sheet Incorrect configuration!');
                            }
                        }
                }
            }
        }]);

        return SpriteSheet;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = SpriteSheet;

    /***/
},
/* 41 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__utilities_bitmask__ = __webpack_require__(31);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__utilities_xmlparsehelper__ = __webpack_require__(4);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME:  object.js
    //  DESC:       object class
    //


    var Object = function () {
        function Object() {
            _classCallCheck(this, Object);

            // Bitmask settings to record if the object needs to be transformed
            this.parameters = new __WEBPACK_IMPORTED_MODULE_2__utilities_bitmask__["a" /* BitMask */](__WEBPACK_IMPORTED_MODULE_4__common_defs__["_65" /* VISIBLE */]);

            // Local position
            this.pos = new __WEBPACK_IMPORTED_MODULE_0__point__["a" /* Point */]();

            // Local Rotation in radians
            this.rot = new __WEBPACK_IMPORTED_MODULE_0__point__["a" /* Point */]();

            // Local scale
            this.scale = new __WEBPACK_IMPORTED_MODULE_0__point__["a" /* Point */](1, 1, 1);

            // The center point. Point of rotation
            // This is used for defining a different center point
            this.centerPos = new __WEBPACK_IMPORTED_MODULE_0__point__["a" /* Point */]();

            // Offset due to a sprite sheet crop.
            this.cropOffset = new __WEBPACK_IMPORTED_MODULE_1__size__["a" /* Size */]();
        }

        _createClass(Object, [{
            key: 'setPos',


            //
            //  DESC: Set the object's position
            //
            value: function setPos(pos) {
                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_64" /* TRANSLATE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                this.pos.set(pos);
            }
        }, {
            key: 'setPosXYZ',
            value: function setPosXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_64" /* TRANSLATE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                this.pos.setXYZ(x, y, z);
            }
        }, {
            key: 'incPos',
            value: function incPos(pos) {
                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_64" /* TRANSLATE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                this.pos.inc(pos);
            }
        }, {
            key: 'incPosXYZ',
            value: function incPosXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_64" /* TRANSLATE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                this.pos.incXYZ(x, y, z);
            }

            //
            //  DESC: Set the pre-translation matrix
            //

        }, {
            key: 'setRot',
            value: function setRot(rot) {
                var convertToRadians = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_60" /* ROTATE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                if (convertToRadians) this.rot.setXYZ(rot.x * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */], rot.y * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */], rot.z * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */]);else this.rot.set(rot);
            }
        }, {
            key: 'setRotXYZ',
            value: function setRotXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var convertToRadians = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_60" /* ROTATE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                if (convertToRadians) this.rot.setXYZ(x * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */], y * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */], z * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */]);else this.rot.setXYZ(x, y, z);
            }
        }, {
            key: 'incRot',
            value: function incRot(rot) {
                var convertToRadians = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_60" /* ROTATE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                if (convertToRadians) this.rot.incXYZ(rot.x * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */], rot.y * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */], rot.z * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */]);else this.rot.inc(rot);

                this.rot.cap(360 * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */]);
            }
        }, {
            key: 'incRotXYZ',
            value: function incRotXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var convertToRadians = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_60" /* ROTATE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                if (convertToRadians) this.rot.incXYZ(x * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */], y * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */], z * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */]);else this.rot.incXYZ(x, y, z);

                this.rot.cap(360 * __WEBPACK_IMPORTED_MODULE_4__common_defs__["g" /* DEG_TO_RAD */]);
            }

            //
            //  DESC: Set the pre-translation matrix
            //

        }, {
            key: 'setScale',
            value: function setScale(scale) {
                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_61" /* SCALE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                this.scale.set(scale);
            }
        }, {
            key: 'setScaleXYZ',
            value: function setScaleXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_61" /* SCALE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                this.scale.setXYZ(x, y, z);
            }
        }, {
            key: 'incScale',
            value: function incScale(scale) {
                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_61" /* SCALE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                this.scale.inc(scale);
            }
        }, {
            key: 'incScaleXYZ',
            value: function incScaleXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_61" /* SCALE */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                this.scale.incXYZ(x, y, z);
            }

            //
            //  DESC: Set the object's center position
            //

        }, {
            key: 'setCenterPos',
            value: function setCenterPos(pos) {
                this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["c" /* CENTER_POINT */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                this.centerPos = pos;
            }

            //
            //  DESC: Set the object's crop offset
            //

        }, {
            key: 'setCropOffset',
            value: function setCropOffset(offset) {
                if (!this.centerPos.isEmpty() || offset !== null && !offset.isEmpty()) {
                    this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["f" /* CROP_OFFSET */] | __WEBPACK_IMPORTED_MODULE_4__common_defs__["_63" /* TRANSFORM */]);

                    this.cropOffset = offset;
                }
            }

            //
            //  DESC: Set the object visible
            //

        }, {
            key: 'setVisible',
            value: function setVisible(value) {
                if (value) this.parameters.add(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_65" /* VISIBLE */]);else this.parameters.remove(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_65" /* VISIBLE */]);
            }

            //
            //  DESC: Is the object visible
            //

        }, {
            key: 'isVisible',
            value: function isVisible() {
                return this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_65" /* VISIBLE */]);
            }

            //
            //  DESC: Copy the transform to the passed in object
            //

        }, {
            key: 'copyTransform',
            value: function copyTransform(object) {
                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_64" /* TRANSLATE */])) object.setPos(this.pos);

                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_60" /* ROTATE */])) object.setRot(this.rot);

                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_4__common_defs__["_61" /* SCALE */])) object.setScale(this.scale);

                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_4__common_defs__["c" /* CENTER_POINT */])) object.setCenterPos(this.centerPos);

                if (this.parameters.isSet(__WEBPACK_IMPORTED_MODULE_4__common_defs__["f" /* CROP_OFFSET */])) object.setCropOffset(this.cropOffset);
            }

            //
            //  DESC: Load the transform data from node
            //

        }, {
            key: 'loadTransFromNode',
            value: function loadTransFromNode(node) {
                var pos = __WEBPACK_IMPORTED_MODULE_3__utilities_xmlparsehelper__["e" /* loadPosition */](node);
                if (pos) this.setPos(pos);

                var rot = __WEBPACK_IMPORTED_MODULE_3__utilities_xmlparsehelper__["h" /* loadRotation */](node);
                if (rot) this.setRot(rot);

                var scale = __WEBPACK_IMPORTED_MODULE_3__utilities_xmlparsehelper__["i" /* loadScale */](node);
                if (scale) this.setScale(scale);

                var centerPos = __WEBPACK_IMPORTED_MODULE_3__utilities_xmlparsehelper__["a" /* loadCenterPos */](node);
                if (centerPos) this.setCenterPos(centerPos);
            }
        }, {
            key: 'position',
            get: function get() {
                return this.pos;
            }
        }, {
            key: 'rotation',
            get: function get() {
                return this.rot;
            }
        }]);

        return Object;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Object;

    /***/
},
/* 42 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_defs__ = __webpack_require__(0);
    // 
    //  FILE NAME: scrollparam.js
    //  DESC:      Class for handling scroll parameter data
    //


    var ScrollParam = function () {
        function ScrollParam() {
            _classCallCheck(this, ScrollParam);

            // Array that holds the scroll messages allows by this menu or control
            this.scrollTypesMap = null;

            // The delay of the first scroll message
            this.startDelay = -1;

            // The delay of the rest of the scroll messages
            this.scrollDelay = -1;

            // The scroll message to send from the timer
            this.msg = -1;
        }

        // 
        //  DESC: Load the scroll data from node
        //


        _createClass(ScrollParam, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                if (node.length) {
                    this.scrollTypesMap = new Map();

                    this.startDelay = Number(node[0].getAttribute('startDelay'));
                    this.scrollDelay = Number(node[0].getAttribute('scrollDelay'));

                    if (node[0].getAttribute('up') === 'true') this.scrollTypesMap.set(__WEBPACK_IMPORTED_MODULE_0__common_defs__["_17" /* EGE_MENU_UP_ACTION */], __WEBPACK_IMPORTED_MODULE_0__common_defs__["_6" /* EGE_MENU_SCROLL_UP */]);

                    if (node[0].getAttribute('down') === 'true') this.scrollTypesMap.set(__WEBPACK_IMPORTED_MODULE_0__common_defs__["X" /* EGE_MENU_DOWN_ACTION */], __WEBPACK_IMPORTED_MODULE_0__common_defs__["_3" /* EGE_MENU_SCROLL_DOWN */]);

                    if (node[0].getAttribute('left') === 'true') this.scrollTypesMap.set(__WEBPACK_IMPORTED_MODULE_0__common_defs__["_0" /* EGE_MENU_LEFT_ACTION */], __WEBPACK_IMPORTED_MODULE_0__common_defs__["_4" /* EGE_MENU_SCROLL_LEFT */]);

                    if (node[0].getAttribute('right') === 'true') this.scrollTypesMap.set(__WEBPACK_IMPORTED_MODULE_0__common_defs__["_2" /* EGE_MENU_RIGHT_ACTION */], __WEBPACK_IMPORTED_MODULE_0__common_defs__["_5" /* EGE_MENU_SCROLL_RIGHT */]);
                }
            }

            // 
            //  DESC: Does this menu or control support scrolling this message?
            //

        }, {
            key: 'canScroll',
            value: function canScroll(msg) {
                if (this.scrollTypesMap) {
                    this.msg = -1;

                    var result = this.scrollTypesMap.get(msg);

                    if (result) {
                        this.msg = result;
                        return true;
                    }
                }

                return false;
            }
        }]);

        return ScrollParam;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ScrollParam;

    /***/
},
/* 43 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return physicsWorldManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__managers_managerbase__ = __webpack_require__(23);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_assetholder__ = __webpack_require__(12);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__physicsworld2d__ = __webpack_require__(77);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__physicsworld3d__ = __webpack_require__(78);

    // 
    //  FILE NAME: physicsworldmanager.js
    //  DESC:      Physics manager class singleton
    //


    var LOAD_2D = 0;
    var LOAD_3D = 1;

    var PhysicsWorldManager = function (_WEBPACK_IMPORTED_MO9) {
        _inherits(PhysicsWorldManager, _WEBPACK_IMPORTED_MO9);

        function PhysicsWorldManager() {
            _classCallCheck(this, PhysicsWorldManager);

            var _this20 = _possibleConstructorReturn(this, (PhysicsWorldManager.__proto__ || Object.getPrototypeOf(PhysicsWorldManager)).call(this));

            _this20.worldMap = new Map();
            return _this20;
        }

        //
        //  DESC: Load all XML's associated with this group
        //


        _createClass(PhysicsWorldManager, [{
            key: 'loadWorldGroup2D',
            value: function loadWorldGroup2D(group, finishCallback) {
                this.loadWorldGroup(LOAD_2D, group, finishCallback);
            }
        }, {
            key: 'loadWorldGroup3D',
            value: function loadWorldGroup3D(group, finishCallback) {
                this.loadWorldGroup(LOAD_3D, group, finishCallback);
            }
        }, {
            key: 'loadWorldGroup',
            value: function loadWorldGroup(loadType, group, finishCallback) {
                var _this21 = this;

                // Make sure the group we are looking for has been defined in the list table file
                var pathAry = this.listTableMap.get(group);
                if (pathAry !== undefined) {
                    // Load the group data if it doesn't already exist
                    if (this.worldMap.get(group) === undefined) {
                        // Create a new physics world inside of our map
                        if (loadType === LOAD_2D) this.worldMap.set(group, new __WEBPACK_IMPORTED_MODULE_2__physicsworld2d__["a" /* PhysicsWorld2D */]());else this.worldMap.set(group, new __WEBPACK_IMPORTED_MODULE_3__physicsworld3d__["a" /* PhysicsWorld3D */]());

                        // There will only be one xml per physics world
                        var _filePath4 = pathAry[0];

                        // Check if this file has already been loaded
                        if (!__WEBPACK_IMPORTED_MODULE_1__utilities_assetholder__["a" /* assetHolder */].has(group, _filePath4)) {
                            this.downloadFile('xml', group, _filePath4, finishCallback, function (group, xmlNode, filePath, finishCallback) {
                                // Store the preloaded XML file
                                __WEBPACK_IMPORTED_MODULE_1__utilities_assetholder__["a" /* assetHolder */].set(group, filePath, xmlNode);

                                // Load from an xml node
                                _this21.loadFromNode(group, xmlNode, filePath);
                            });
                        } else {
                            this.loadFromNode(group, __WEBPACK_IMPORTED_MODULE_1__utilities_assetholder__["a" /* assetHolder */].get(group, _filePath4), _filePath4);
                        }

                        // If there's nothing to load, call the complete callback
                        if (this.loadCounter === 0) finishCallback();
                    } else {
                        throw new Error('Physics world group has alread been loaded (' + group + ')!');
                    }
                } else {
                    throw new Error('Physics world list group name can\'t be found (' + group + ')!');
                }
            }

            //
            //  DESC: Load from an xml node
            //

        }, {
            key: 'loadFromNode',
            value: function loadFromNode(group, node, filePath) {
                // Get the physics world
                var world = this.worldMap.get(group);
                if (world === undefined) throw new Error('Physics World doesn\'t exist (' + group + ', ' + filePath + ')!');

                world.loadFromNode(node);
            }

            //
            //  DESC: Get the physics world
            //

        }, {
            key: 'getWorld',
            value: function getWorld(group) {
                var world = this.worldMap.get(group);
                if (world === undefined) throw new Error('Physics World doesn\'t exist (' + group + ')!');

                return world;
            }

            //
            //  DESC: Destroy the physics world
            //

        }, {
            key: 'destroyWorld',
            value: function destroyWorld(group) {
                this.worldMap.delete(group);
            }
        }]);

        return PhysicsWorldManager;
    }(__WEBPACK_IMPORTED_MODULE_0__managers_managerbase__["a" /* ManagerBase */]);

    var physicsWorldManager = new PhysicsWorldManager();

    /***/
},
/* 44 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__uicontrol__ = __webpack_require__(17);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uicontrolnavnode.js
    //  DESC:      UI Control Navigation Node
    //


    var UIControlNavNode = function () {
        function UIControlNavNode() {
            var uiControl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            _classCallCheck(this, UIControlNavNode);

            // UI Control pointer
            this.uiControl = uiControl;

            // Navigation node pointers
            this.upNode = null;
            this.downNode = null;
            this.leftNode = null;
            this.rightNode = null;
        }

        // 
        //  DESC: Set/Get Right Node
        //


        _createClass(UIControlNavNode, [{
            key: 'setNode',
            value: function setNode(navId, node) {
                if (navId === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_41" /* ENAV_NODE_UP */]) this.upNode = node;else if (navId === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_38" /* ENAV_NODE_DOWN */]) this.downNode = node;else if (navId === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_39" /* ENAV_NODE_LEFT */]) this.leftNode = node;else if (navId === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_40" /* ENAV_NODE_RIGHT */]) this.rightNode = node;
            }
        }, {
            key: 'getNode',
            value: function getNode(navNode) {
                if (navNode === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_41" /* ENAV_NODE_UP */]) return this.upNode;else if (navNode === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_38" /* ENAV_NODE_DOWN */]) return this.downNode;else if (navNode === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_39" /* ENAV_NODE_LEFT */]) return this.leftNode;else if (navNode === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_40" /* ENAV_NODE_RIGHT */]) return this.rightNode;

                return null;
            }
        }]);

        return UIControlNavNode;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UIControlNavNode;

    /***/
},
/* 45 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__uicontrol__ = __webpack_require__(17);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__2d_sprite2d__ = __webpack_require__(13);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__common_point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__objectdatamanager_objectdatamanager__ = __webpack_require__(11);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uiprogressbar.js
    //  DESC:      Class for user interface progress bar
    //


    var UIProgressBar = function (_WEBPACK_IMPORTED_MO10) {
        _inherits(UIProgressBar, _WEBPACK_IMPORTED_MO10);

        function UIProgressBar(group) {
            _classCallCheck(this, UIProgressBar);

            var _this22 = _possibleConstructorReturn(this, (UIProgressBar.__proto__ || Object.getPrototypeOf(UIProgressBar)).call(this, group));

            _this22.type = __WEBPACK_IMPORTED_MODULE_6__common_defs__["L" /* ECT_PROGRESS_BAR */];

            // stencil mask sprite
            _this22.stencilMaskSprite;

            // current value of progress bar
            _this22.curValue = 0;

            // Minimum value
            _this22.minValue = 0;

            // Max value of progress bar
            _this22.maxValue = 0;

            // Sprite index to apply stencil mask to
            _this22.spriteApplyIndex = -1;

            // Orentation
            _this22.orentation = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_42" /* EO_HORIZONTAL */];

            // alignment of this progress bar
            _this22.alignment = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_25" /* EHA_HORZ_LEFT */];

            // progress bar size
            _this22.progressBarSize = new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */]();

            // progress bar pos
            _this22.progressBarPos = new __WEBPACK_IMPORTED_MODULE_3__common_point__["a" /* Point */]();

            // progress bar scale
            _this22.progressBarScale = new __WEBPACK_IMPORTED_MODULE_3__common_point__["a" /* Point */]();
            return _this22;
        }

        //
        //  DESC: Load the control info from XML node
        //


        _createClass(UIProgressBar, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                _get(UIProgressBar.prototype.__proto__ || Object.getPrototypeOf(UIProgressBar.prototype), 'loadFromNode', this).call(this, node);

                // See if a range of values was specified
                var rangeNode = node.getElementsByTagName('range');
                if (rangeNode.length) {
                    var attr = rangeNode[0].getAttribute('cur');
                    if (attr) this.curValue = Number(attr);

                    attr = rangeNode[0].getAttribute('min');
                    if (attr) this.minValue = Number(attr);

                    attr = rangeNode[0].getAttribute('max');
                    if (attr) this.maxValue = Number(attr);
                }

                var orentNode = node.getElementsByTagName("orentation");
                if (orentNode.length) {
                    var _attr2 = orentNode[0].getAttribute("type");
                    if (_attr2 === 'vert') this.orentation = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_43" /* EO_VERTICAL */];

                    _attr2 = orentNode[0].getAttribute("alignment");
                    if (_attr2) {
                        if (this.orentation === __WEBPACK_IMPORTED_MODULE_6__common_defs__["_42" /* EO_HORIZONTAL */]) {
                            if (_attr2 === 'right') this.alignment = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_26" /* EHA_HORZ_RIGHT */];else if (_attr2 === 'center') this.alignment = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_24" /* EHA_HORZ_CENTER */];
                        } else {
                            if (_attr2 === 'bottom') this.alignment = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_52" /* EVA_VERT_BOTTOM */];else if (_attr2 === 'center') this.alignment = __WEBPACK_IMPORTED_MODULE_6__common_defs__["_53" /* EVA_VERT_CENTER */];
                        }
                    }
                }

                // Calculate the progress bar size and position
                this.setSizePos();
            }

            //
            //  DESC: Load the control specific info from XML node
            //

        }, {
            key: 'loadControlFromNode',
            value: function loadControlFromNode(controlNode) {
                _get(UIProgressBar.prototype.__proto__ || Object.getPrototypeOf(UIProgressBar.prototype), 'loadControlFromNode', this).call(this, controlNode);

                // Get the stencil mask node
                var stencilMaskNode = controlNode.getElementsByTagName("stencilMask");
                if (stencilMaskNode.length) {
                    var objectName = stencilMaskNode[0].getAttribute("objectName");

                    this.spriteApplyIndex = Number(stencilMaskNode[0].getAttribute("spriteIndex"));

                    if (objectName && objectName.length) {
                        this.stencilMaskSprite = new __WEBPACK_IMPORTED_MODULE_1__2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_4__objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData(this.group, objectName));

                        // Load the transform data
                        this.stencilMaskSprite.loadTransFromNode(stencilMaskNode[0]);

                        // Get the size
                        this.progressBarSize.copy(this.stencilMaskSprite.objData.size);

                        // Get the initial position
                        this.progressBarPos.copy(this.stencilMaskSprite.pos);

                        // Get the initial scale
                        this.progressBarScale.copy(this.stencilMaskSprite.scale);
                    } else {
                        // Get the size
                        this.progressBarSize.copy(this.spriteAry[this.spriteApplyIndex].objData.size);

                        // Get the initial position
                        this.progressBarPos.copy(this.spriteAry[this.spriteApplyIndex].pos);

                        // Get the initial scale
                        this.progressBarScale.copy(this.spriteAry[this.spriteApplyIndex].scale);
                    }
                }
            }

            // 
            //  DESC: Init the progress bar
            //  NOTE: Used to init this control manually
            //

        }, {
            key: 'initProgressBar',
            value: function initProgressBar() {
                var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var cur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var orentation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : __WEBPACK_IMPORTED_MODULE_6__common_defs__["_42" /* EO_HORIZONTAL */];
                var alignment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : __WEBPACK_IMPORTED_MODULE_6__common_defs__["_25" /* EHA_HORZ_LEFT */];

                this.maxValue = max;
                this.curValue = cur;
                this.minValue = min;
                this.orentation = orentation;
                this.alignment = alignment;

                this.setSizePos();
            }

            // 
            //  DESC: Load a sprite from an array
            //  NOTE: Used to init this control manually
            //

        }, {
            key: 'loadSpriteFromArray',
            value: function loadSpriteFromArray(objectNameAry, spriteApplyIndex) {
                var stencilMaskSprite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

                _get(UIProgressBar.prototype.__proto__ || Object.getPrototypeOf(UIProgressBar.prototype), 'loadSpriteFromArray', this).call(this, objectNameAry);

                this.spriteApplyIndex = spriteApplyIndex;

                if (stencilMaskSprite) {
                    this.stencilMaskSprite = new __WEBPACK_IMPORTED_MODULE_1__2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_4__objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData(this.group, stencilMaskSprite));

                    // Get the size
                    this.progressBarSize.copy(this.stencilMaskSprite.objData.size);

                    // Get the initial position
                    this.progressBarPos.copy(this.stencilMaskSprite.pos);

                    // Get the initial scale
                    this.progressBarScale.copy(this.stencilMaskSprite.scale);
                } else {
                    // Get the size
                    this.progressBarSize.copy(this.spriteAry[this.spriteApplyIndex].objData.size);

                    // Get the initial position
                    this.progressBarPos.copy(this.spriteAry[this.spriteApplyIndex].pos);

                    // Get the initial scale
                    this.progressBarScale.copy(this.spriteAry[this.spriteApplyIndex].scale);
                }
            }

            // 
            //  DESC: Inc the current value
            //

        }, {
            key: 'incCurrentValue',
            value: function incCurrentValue(cur) {
                this.curValue = cur;

                this.setSizePos();
            }

            //
            //  DESC: Transform the control
            //

        }, {
            key: 'doTransform',
            value: function doTransform(object) {
                _get(UIProgressBar.prototype.__proto__ || Object.getPrototypeOf(UIProgressBar.prototype), 'doTransform', this).call(this, object);

                if (this.stencilMaskSprite) this.stencilMaskSprite.transform(this.matrix, this.wasWorldPosTranformed());
            }

            // 
            //  DESC: Simple transform that does not include a parent or collision
            //

        }, {
            key: 'simpleTransform',
            value: function simpleTransform() {
                _get(UIProgressBar.prototype.__proto__ || Object.getPrototypeOf(UIProgressBar.prototype), 'simpleTransform', this).call(this);

                if (this.stencilMaskSprite) this.stencilMaskSprite.transform(this.matrix, this.wasWorldPosTranformed());
            }

            // 
            //  DESC: Transform the collision
            //  NOTE: This object has no collision
            //

        }, {
            key: 'transformCollision',
            value: function transformCollision() {}

            //
            //  DESC: do the render
            //

        }, {
            key: 'render',
            value: function render(matrix) {
                if (this.stencilMaskSprite) {
                    for (var i = 0; i < this.spriteAry.length; ++i) {
                        if (i === this.spriteApplyIndex) {
                            // Disable rendering to the color buffer
                            // NOTE: Using gl.FALSE or gl.TRUE causes a problem with this function call
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].colorMask(false, false, false, false);

                            // Disable rendering to the depth mask
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].depthMask(false);

                            // Start using the stencil
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].enable(__WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].STENCIL_TEST);

                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].stencilFunc(__WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].ALWAYS, 0x1, 0x1);
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].stencilOp(__WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].REPLACE, __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].REPLACE, __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].REPLACE);

                            this.stencilMaskSprite.render(matrix);

                            // Re-enable color
                            // NOTE: Using gl.FALSE or gl.TRUE causes a problem with this function call
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].colorMask(true, true, true, true);

                            // Where a 1 was not rendered
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].stencilFunc(__WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].EQUAL, 0x1, 0x1);

                            // Keep the pixel
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].stencilOp(__WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].KEEP, __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].KEEP, __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].KEEP);

                            // Enable rendering to the depth mask
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].depthMask(true);

                            this.spriteAry[i].render(matrix);

                            // Finished using stencil
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].disable(__WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].STENCIL_TEST);
                        } else this.spriteAry[i].render(matrix);
                    }
                } else {
                    _get(UIProgressBar.prototype.__proto__ || Object.getPrototypeOf(UIProgressBar.prototype), 'render', this).call(this, matrix);
                }
            }

            //
            //  DESC: Calculate the progress bar size and position
            //

        }, {
            key: 'setSizePos',
            value: function setSizePos() {
                var scaleX = this.progressBarScale.x;
                var scaleY = this.progressBarScale.y;
                var posX = this.progressBarPos.x;
                var posY = this.progressBarPos.y;

                // Calculate the new scale for the progress bar
                var scaler = (this.curValue - this.minValue) / (this.maxValue - this.minValue);

                if (this.orentation == __WEBPACK_IMPORTED_MODULE_6__common_defs__["_42" /* EO_HORIZONTAL */]) {
                    scaleX = this.progressBarScale.x * scaler;

                    var offset = this.progressBarSize.w * scaler;

                    if (this.alignment == __WEBPACK_IMPORTED_MODULE_6__common_defs__["_25" /* EHA_HORZ_LEFT */]) posX -= (this.progressBarSize.w - offset) / 2;else if (m_alignment.horz == __WEBPACK_IMPORTED_MODULE_6__common_defs__["_26" /* EHA_HORZ_RIGHT */]) posX += (this.progressBarSize.w - offset) / 2;
                } else {
                    scaleY = this.progressBarScale.y * scaler;

                    var _offset = this.progressBarSize.h * scaler;

                    if (this.alignment === __WEBPACK_IMPORTED_MODULE_6__common_defs__["_54" /* EVA_VERT_TOP */]) posY += (this.progressBarSize.h - _offset) / 2;else if (this.alignment === __WEBPACK_IMPORTED_MODULE_6__common_defs__["_52" /* EVA_VERT_BOTTOM */]) posY -= (this.progressBarSize.h - _offset) / 2;
                }

                if (this.stencilMaskSprite) {
                    this.stencilMaskSprite.setScaleXYZ(scaleX, scaleY, 1);
                    this.stencilMaskSprite.setPosXYZ(posX, posY);
                } else {
                    this.spriteAry[this.spriteApplyIndex].setScaleXYZ(scaleX, scaleY, 1);
                    this.spriteAry[this.spriteApplyIndex].setPosXYZ(posX, posY, 0);
                }
            }
        }]);

        return UIProgressBar;
    }(__WEBPACK_IMPORTED_MODULE_0__uicontrol__["a" /* UIControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UIProgressBar;

    /***/
},
/* 46 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return spriteStrategyManager;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__managers_managerbase__ = __webpack_require__(23);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_assetholder__ = __webpack_require__(12);

    // 
    //  FILE NAME: spritestrategymanager.js
    //  DESC:      Sprite strategy manager singleton
    //


    var SpriteStrategyManager = function (_WEBPACK_IMPORTED_MO11) {
        _inherits(SpriteStrategyManager, _WEBPACK_IMPORTED_MO11);

        function SpriteStrategyManager() {
            _classCallCheck(this, SpriteStrategyManager);

            // Map of unique strategy references
            var _this23 = _possibleConstructorReturn(this, (SpriteStrategyManager.__proto__ || Object.getPrototypeOf(SpriteStrategyManager)).call(this));

            _this23.strategyMap = new Map();

            // Sprite Id incrementor
            _this23.spriteInc = 0;
            return _this23;
        }

        //
        //  DESC: Load strategy data from an xml node
        //


        _createClass(SpriteStrategyManager, [{
            key: 'load',
            value: function load(strategyId, spriteStrategy, finishCallback) {
                // Check for duplicate Id's
                if (this.strategyMap.has(strategyId)) throw new Error('Duplicate strategy id (' + strategyId + ')!');

                // Add the strategy to the map
                this.strategyMap.set(strategyId, spriteStrategy);

                // Load all the xml's
                _get(SpriteStrategyManager.prototype.__proto__ || Object.getPrototypeOf(SpriteStrategyManager.prototype), 'load', this).call(this, strategyId, finishCallback);
            }

            //
            //  DESC: Load strategy data from an xml node
            //

        }, {
            key: 'loadFromNode',
            value: function loadFromNode(strategyId, node, filePath, finishCallback) {
                var strategy = this.strategyMap.get(strategyId);

                strategy.loadFromNode(node, filePath, this.downloadFile.bind(this), finishCallback);
            }

            /************************************************************************
            *    desc:  create the sprite and provide a unique id number for each one
            ************************************************************************/
            /*const std::vector<int> & CSpriteStrategyMgr::Create(
                const std::string & strategyId,
                const std::string & name,
                const int count,
                const CPoint<CWorldValue> & pos,
                const CPoint<float> & rot,
                const CPoint<float> & scale )
            {
                // Make sure the group we are looking has been defined in the list table file
                auto mapIter = m_pStrategyMap.find( strategyId );
                if( mapIter == m_pStrategyMap.end() )
                    throw NExcept::CCriticalException("Sprite Manager Strategy Group Find Error!",
                        boost::str( boost::format("Sprite Manager strategy id can't be found (%s).\n\n%s\nLine: %s") 
                            % strategyId % __FUNCTION__ % __LINE__ ));
                 m_incReturn.clear();
                m_incReturn.reserve(count);
                 // Create the requested number of sprites
                for( int i = 0; i < count; ++i )
                {
                    m_incReturn.push_back(++m_SpriteInc);
                    mapIter->second->Create( name, m_SpriteInc, pos, rot, scale );
                }
                 return m_incReturn;
             }   // Create
             int CSpriteStrategyMgr::Create(
                const std::string & strategyId,
                const std::string & name,
                const CPoint<CWorldValue> & pos,
                const CPoint<float> & rot,
                const CPoint<float> & scale )
            {
                // Make sure the group we are looking has been defined in the list table file
                auto mapIter = m_pStrategyMap.find( strategyId );
                if( mapIter == m_pStrategyMap.end() )
                    throw NExcept::CCriticalException("Sprite Manager Strategy Group Find Error!",
                        boost::str( boost::format("Sprite Manager strategy id can't be found (%s).\n\n%s\nLine: %s") 
                            % strategyId % __FUNCTION__ % __LINE__ ));
                 mapIter->second->Create( name, ++m_SpriteInc, pos, rot, scale );
                 return m_SpriteInc;
             }   // Create */

            //
            //  DESC: Delete all the sprites
            //

        }, {
            key: 'clear',
            value: function clear() {
                this.strategyMap.clear();
                this.spriteInc = 0;
            }

            //
            //  DESC: Do any pre-game loop init's
            //

        }, {
            key: 'init',
            value: function init() {
                var _iteratorNormalCompletion24 = true;
                var _didIteratorError24 = false;
                var _iteratorError24 = undefined;

                try {
                    for (var _iterator24 = this.strategyMap.entries()[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                        var _step24$value = _slicedToArray(_step24.value, 2),
                            key = _step24$value[0],
                            strategy = _step24$value[1];

                        strategy.init();
                    }
                } catch (err) {
                    _didIteratorError24 = true;
                    _iteratorError24 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion24 && _iterator24.return) {
                            _iterator24.return();
                        }
                    } finally {
                        if (_didIteratorError24) {
                            throw _iteratorError24;
                        }
                    }
                }
            }

            //
            //  DESC: Do some cleanup
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                var _iteratorNormalCompletion25 = true;
                var _didIteratorError25 = false;
                var _iteratorError25 = undefined;

                try {
                    for (var _iterator25 = this.strategyMap.entries()[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                        var _step25$value = _slicedToArray(_step25.value, 2),
                            key = _step25$value[0],
                            strategy = _step25$value[1];

                        strategy.cleanUp();
                    }
                } catch (err) {
                    _didIteratorError25 = true;
                    _iteratorError25 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion25 && _iterator25.return) {
                            _iterator25.return();
                        }
                    } finally {
                        if (_didIteratorError25) {
                            throw _iteratorError25;
                        }
                    }
                }
            }

            //
            //  DESC: Handle any misc processing before the real work is started
            //

        }, {
            key: 'miscProcess',
            value: function miscProcess() {
                var _iteratorNormalCompletion26 = true;
                var _didIteratorError26 = false;
                var _iteratorError26 = undefined;

                try {
                    for (var _iterator26 = this.strategyMap.entries()[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
                        var _step26$value = _slicedToArray(_step26.value, 2),
                            key = _step26$value[0],
                            strategy = _step26$value[1];

                        strategy.miscProcess();
                    }
                } catch (err) {
                    _didIteratorError26 = true;
                    _iteratorError26 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion26 && _iterator26.return) {
                            _iterator26.return();
                        }
                    } finally {
                        if (_didIteratorError26) {
                            throw _iteratorError26;
                        }
                    }
                }
            }

            //
            //  DESC: Update the sprites
            //

        }, {
            key: 'update',
            value: function update() {
                var _iteratorNormalCompletion27 = true;
                var _didIteratorError27 = false;
                var _iteratorError27 = undefined;

                try {
                    for (var _iterator27 = this.strategyMap.entries()[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                        var _step27$value = _slicedToArray(_step27.value, 2),
                            key = _step27$value[0],
                            strategy = _step27$value[1];

                        strategy.update();
                    }
                } catch (err) {
                    _didIteratorError27 = true;
                    _iteratorError27 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion27 && _iterator27.return) {
                            _iterator27.return();
                        }
                    } finally {
                        if (_didIteratorError27) {
                            throw _iteratorError27;
                        }
                    }
                }
            }

            //
            //  DESC: Transform the sprite
            //

        }, {
            key: 'transform',
            value: function transform() {
                var _iteratorNormalCompletion28 = true;
                var _didIteratorError28 = false;
                var _iteratorError28 = undefined;

                try {
                    for (var _iterator28 = this.strategyMap.entries()[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
                        var _step28$value = _slicedToArray(_step28.value, 2),
                            key = _step28$value[0],
                            strategy = _step28$value[1];

                        strategy.transform();
                    }
                } catch (err) {
                    _didIteratorError28 = true;
                    _iteratorError28 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion28 && _iterator28.return) {
                            _iterator28.return();
                        }
                    } finally {
                        if (_didIteratorError28) {
                            throw _iteratorError28;
                        }
                    }
                }
            }
        }, {
            key: 'transform',
            value: function transform(object) {
                var _iteratorNormalCompletion29 = true;
                var _didIteratorError29 = false;
                var _iteratorError29 = undefined;

                try {
                    for (var _iterator29 = this.strategyMap.entries()[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
                        var _step29$value = _slicedToArray(_step29.value, 2),
                            key = _step29$value[0],
                            strategy = _step29$value[1];

                        strategy.transform(object);
                    }
                } catch (err) {
                    _didIteratorError29 = true;
                    _iteratorError29 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion29 && _iterator29.return) {
                            _iterator29.return();
                        }
                    } finally {
                        if (_didIteratorError29) {
                            throw _iteratorError29;
                        }
                    }
                }
            }

            //
            //  DESC: Render the sprites
            //

        }, {
            key: 'render',
            value: function render(matrix) {
                var _iteratorNormalCompletion30 = true;
                var _didIteratorError30 = false;
                var _iteratorError30 = undefined;

                try {
                    for (var _iterator30 = this.strategyMap.entries()[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                        var _step30$value = _slicedToArray(_step30.value, 2),
                            key = _step30$value[0],
                            strategy = _step30$value[1];

                        strategy.render(matrix);
                    }
                } catch (err) {
                    _didIteratorError30 = true;
                    _iteratorError30 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion30 && _iterator30.return) {
                            _iterator30.return();
                        }
                    } finally {
                        if (_didIteratorError30) {
                            throw _iteratorError30;
                        }
                    }
                }
            }
        }]);

        return SpriteStrategyManager;
    }(__WEBPACK_IMPORTED_MODULE_0__managers_managerbase__["a" /* ManagerBase */]);

    var spriteStrategyManager = new SpriteStrategyManager();

    /***/
},
/* 47 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__gamestate__ = __webpack_require__(22);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__ = __webpack_require__(24);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__library_system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__library_common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: commonstate.js
    //  DESC:      CommonState Class State
    //


    var CommonState = function (_WEBPACK_IMPORTED_MO12) {
        _inherits(CommonState, _WEBPACK_IMPORTED_MO12);

        function CommonState(gameState, nextState, callBack) {
            _classCallCheck(this, CommonState);

            return _possibleConstructorReturn(this, (CommonState.__proto__ || Object.getPrototypeOf(CommonState)).call(this, gameState, nextState, callBack));
        }

        // 
        //  DESC: handle events
        //


        _createClass(CommonState, [{
            key: 'handleEvent',
            value: function handleEvent(event) {
                // Have the menu manager handle events
                __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__["a" /* menuManager */].handleEvent(event);

                if (event instanceof CustomEvent) {
                    // Check for the "game change state" message
                    if (event.detail.type === __WEBPACK_IMPORTED_MODULE_3__library_common_defs__["Z" /* EGE_MENU_GAME_STATE_CHANGE */]) {
                        if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_3__library_common_defs__["_50" /* ETC_BEGIN */]) {
                            // Block all message processing in the menu manager
                            __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__["a" /* menuManager */].allowEventHandling = false;

                            // Set the message to load and unload the states
                            this.stateMessage.setMsg(this.getLoadState(event.detail.arg[1]), this.gameState);
                        } else if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_3__library_common_defs__["_51" /* ETC_END */]) {
                            // Clear out all the trees
                            __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__["a" /* menuManager */].clearActiveTrees();

                            // Set the flag to change the state
                            this.stateChange = true;
                        }
                    }
                }
            }

            // 
            //  DESC: Update objects that require them
            //

        }, {
            key: 'update',
            value: function update() {
                // Update the menus
                __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__["a" /* menuManager */].update();
            }

            // 
            //  DESC: Transform the game objects
            //

        }, {
            key: 'transform',
            value: function transform() {
                // Transform the menus
                __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__["a" /* menuManager */].transform();
            }

            // 
            //  DESC: 2D/3D Render of game content
            //

        }, {
            key: 'preRender',
            value: function preRender() {
                __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__["a" /* menuManager */].renderInterface(__WEBPACK_IMPORTED_MODULE_2__library_system_device__["a" /* device */].orthographicMatrix);
            }

            // 
            //  DESC: 2D/3D Render of game content
            //

        }, {
            key: 'postRender',
            value: function postRender() {
                __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__["a" /* menuManager */].render(__WEBPACK_IMPORTED_MODULE_2__library_system_device__["a" /* device */].orthographicMatrix);
            }

            // 
            //  DESC: Get the load state
            //

        }, {
            key: 'getLoadState',
            value: function getLoadState(loadStateStr) {
                if (loadStateStr === 'title_screen_state') return __WEBPACK_IMPORTED_MODULE_0__gamestate__["d" /* GAME_STATE_TITLESCREEN */];else if (loadStateStr === 'run_state') return __WEBPACK_IMPORTED_MODULE_0__gamestate__["b" /* GAME_STATE_RUN */];

                throw new Error('State does not exist!. (' + loadStateStr + ')');
            }
        }]);

        return CommonState;
    }(__WEBPACK_IMPORTED_MODULE_0__gamestate__["e" /* GameState */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = CommonState;

    /***/
},
/* 48 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__2d_object2d__ = __webpack_require__(25);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_matrix__ = __webpack_require__(10);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME:  object3d.js
    //  DESC:       object 3D class
    //


    var Object3D = function (_WEBPACK_IMPORTED_MO13) {
        _inherits(Object3D, _WEBPACK_IMPORTED_MO13);

        function Object3D() {
            _classCallCheck(this, Object3D);

            // Matrix for rotations only
            // Basicly used for normal calculations
            var _this25 = _possibleConstructorReturn(this, (Object3D.__proto__ || Object.getPrototypeOf(Object3D)).call(this));

            _this25.rotMatrix = new __WEBPACK_IMPORTED_MODULE_1__utilities_matrix__["a" /* Matrix */]();
            return _this25;
        }

        //
        //  DESC: Set the translation/rotation from Bullet Physics
        //
        /*setTransform( trans )
        {
            this.parameters.add( defs.MATRIX_ROTATION | defs.TRANSFORM );
             // Set the position
            const btVector3 & btVec = trans.getOrigin();
            SetPos( CPoint<float>(btVec.x(), btVec.y(), btVec.z()) );
             // Set the rotation
            const btMatrix3x3 & btMat = trans.getBasis();
            for( int i = 0; i < 3; ++i )
            {
                const btVector3 & vec = btMat.getRow(i);
                m_rotMatrix.SetColumn( i, CPoint<float>(vec.x(), vec.y(), vec.z()) );
            }
        }*/

        //
        //  DESC: Apply the rotation
        //


        _createClass(Object3D, [{
            key: 'applyRotation',
            value: function applyRotation(matrix) {
                _get(Object3D.prototype.__proto__ || Object.getPrototypeOf(Object3D.prototype), 'applyRotation', this).call(this, matrix);

                this.rotMatrix.initilizeMatrix();
                this.rotMatrix.rotate(this.rot);
            }
        }]);

        return Object3D;
    }(__WEBPACK_IMPORTED_MODULE_0__2d_object2d__["a" /* Object2D */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Object3D;

    /***/
},
/* 49 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (immutable) */
    __webpack_exports__["c"] = loadScripts;
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__library_utilities_highresolutiontimer__ = __webpack_require__(8);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__library_managers_shadermanager__ = __webpack_require__(15);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__library_script_scriptmanager__ = __webpack_require__(14);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__library_managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__library_common_color__ = __webpack_require__(16);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__library_common_defs__ = __webpack_require__(0);

    //
    //  FILE NAME: utilityscripts.js
    //  DESC:      script for fading the screen
    //


    //
    //  DESC: Script for fading in the menu
    //

    var FadeTo = function () {
        function FadeTo(current, final, time) {
            _classCallCheck(this, FadeTo);

            this.current = current;
            this.final = final;
            this.time = time;
            this.inc = (this.final - this.current) / this.time;
            this.finished = false;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(FadeTo, [{
            key: 'execute',
            value: function execute() {
                this.time -= __WEBPACK_IMPORTED_MODULE_0__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;

                if (this.time < 0) {
                    this.finished = true;
                } else {
                    this.current += this.inc * __WEBPACK_IMPORTED_MODULE_0__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;
                }
            }
        }]);

        return FadeTo;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["b"] = FadeTo;

    //
    //  DESC: Color to the final color in time
    //

    var ColorTo = function () {
        function ColorTo() {
            _classCallCheck(this, ColorTo);

            this.current = new __WEBPACK_IMPORTED_MODULE_4__library_common_color__["a" /* Color */]();
            this.inc = new __WEBPACK_IMPORTED_MODULE_4__library_common_color__["a" /* Color */]();
            this.final;
            this.time;
        }

        _createClass(ColorTo, [{
            key: 'init',
            value: function init(current, final, time) {
                this.time = time;
                this.final = final;
                this.current.copy(current);

                for (var i = 0; i < 4; ++i) {
                    this.inc.data[i] = (this.final.data[i] - this.current.data[i]) / this.time;
                }this.finished = false;
            }

            // 
            //  DESC: Execute this script object
            //

        }, {
            key: 'execute',
            value: function execute() {
                var elapsedTime = __WEBPACK_IMPORTED_MODULE_0__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;
                this.time -= elapsedTime;

                if (this.time < 0) {
                    this.finished = true;
                } else {
                    for (var i = 0; i < 4; ++i) {
                        this.current.data[i] += this.inc.data[i] * elapsedTime;
                    }
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'color',
            get: function get() {
                if (this.finished) return this.final;else return this.current;
            }
        }]);

        return ColorTo;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ColorTo;

    //
    //  DESC: Script for fading the screen
    //

    var ScreenFade = function (_FadeTo) {
        _inherits(ScreenFade, _FadeTo);

        function ScreenFade(current, final, time, gameStateChangeMsg) {
            _classCallCheck(this, ScreenFade);

            var _this26 = _possibleConstructorReturn(this, (ScreenFade.__proto__ || Object.getPrototypeOf(ScreenFade)).call(this, current, final, time));

            _this26.gameStateChangeMsg = gameStateChangeMsg;
            return _this26;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(ScreenFade, [{
            key: 'execute',
            value: function execute() {
                _get(ScreenFade.prototype.__proto__ || Object.getPrototypeOf(ScreenFade.prototype), 'execute', this).call(this);

                if (this.finished) {
                    __WEBPACK_IMPORTED_MODULE_1__library_managers_shadermanager__["a" /* shaderManager */].setAllShaderValue4fv('additive', [this.final, this.final, this.final, 1]);

                    if (this.gameStateChangeMsg) __WEBPACK_IMPORTED_MODULE_3__library_managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_5__library_common_defs__["Z" /* EGE_MENU_GAME_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_5__library_common_defs__["_51" /* ETC_END */]);
                } else {
                    __WEBPACK_IMPORTED_MODULE_1__library_managers_shadermanager__["a" /* shaderManager */].setAllShaderValue4fv('additive', [this.current, this.current, this.current, 1]);
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return ScreenFade;
    }(FadeTo);

    // 
    //  DESC: Load the scripts in this file
    //


    function loadScripts() {
        __WEBPACK_IMPORTED_MODULE_2__library_script_scriptmanager__["a" /* scriptManager */].set('ScreenFade', function (current, final, time) {
            var gameStateChangeMsg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            return new ScreenFade(current, final, time, gameStateChangeMsg);
        });
    }

    /***/
},
/* 50 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (immutable) */
    __webpack_exports__["b"] = load;
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__library_gui_menumanager__ = __webpack_require__(24);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__library_utilities_highresolutiontimer__ = __webpack_require__(8);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__library_script_scriptcomponent__ = __webpack_require__(21);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__library_script_scriptmanager__ = __webpack_require__(14);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__library_physics_physicsworldmanager__ = __webpack_require__(43);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__ = __webpack_require__(11);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__library_managers_loadmanager__ = __webpack_require__(28);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__library_managers_soundmanager__ = __webpack_require__(35);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__library_managers_spritestrategymanager__ = __webpack_require__(46);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__library_2d_basicstagestrategy2d__ = __webpack_require__(98);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__library_2d_sprite2d__ = __webpack_require__(13);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_11__library_system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_12__commonstate__ = __webpack_require__(47);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_13__gamestate__ = __webpack_require__(22);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_14__library_common_defs__ = __webpack_require__(0);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_15__library_utilities_genfunc__ = __webpack_require__(3);

    // 
    //  FILE NAME: runstate.js
    //  DESC:      RunState Class State
    //


    var RunState = function (_WEBPACK_IMPORTED_MO14) {
        _inherits(RunState, _WEBPACK_IMPORTED_MO14);

        function RunState() {
            var gameLoopCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            _classCallCheck(this, RunState);

            var _this27 = _possibleConstructorReturn(this, (RunState.__proto__ || Object.getPrototypeOf(RunState)).call(this, __WEBPACK_IMPORTED_MODULE_13__gamestate__["b" /* GAME_STATE_RUN */], __WEBPACK_IMPORTED_MODULE_13__gamestate__["a" /* GAME_STATE_LOAD */], gameLoopCallback));

            _this27.physicsWorld = __WEBPACK_IMPORTED_MODULE_4__library_physics_physicsworldmanager__["a" /* physicsWorldManager */].getWorld("(game)");

            var pegOffset = [[-800, 320], [-640, 320], [-480, 320], [-320, 320], [-160, 320], [0, 320], [160, 320], [320, 320], [480, 320], [640, 320], [800, 320], [-720, 160], [-560, 160], [-400, 160], [-240, 160], [-80, 160], [80, 160], [240, 160], [400, 160], [560, 160], [720, 160], [-800, 0], [-640, 0], [-480, 0], [-320, 0], [-160, 0], [0, 0], [160, 0], [320, 0], [480, 0], [640, 0], [800, 0], [-720, -160], [-560, -160], [-400, -160], [-240, -160], [-80, -160], [80, -160], [240, -160], [400, -160], [560, -160], [720, -160], [-800, -320], [-640, -320], [-480, -320], [-320, -320], [-160, -320], [0, -320], [160, -320], [320, -320], [480, -320], [640, -320], [800, -320]];

            _this27.pegAry = [];
            var pegSpriteData = __WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(run)', 'peg');

            for (var i = 0; i < pegOffset.length; ++i) {
                var peg = new __WEBPACK_IMPORTED_MODULE_10__library_2d_sprite2d__["a" /* Sprite2D */](pegSpriteData);
                peg.setPosXYZ(pegOffset[i][0], pegOffset[i][1], 0);
                peg.initPhysics();
                peg.transform();

                _this27.pegAry.push(peg);
            }

            _this27.fallObjects = [];

            for (var _i8 = 0; _i8 < 20; ++_i8) {
                _this27.fallObjects.push(_this27.generateObj(_i8 % 5, __WEBPACK_IMPORTED_MODULE_15__library_utilities_genfunc__["d" /* randomInt */](-700, 700), __WEBPACK_IMPORTED_MODULE_15__library_utilities_genfunc__["d" /* randomInt */](600, 1000), __WEBPACK_IMPORTED_MODULE_15__library_utilities_genfunc__["d" /* randomInt */](0, 360) * __WEBPACK_IMPORTED_MODULE_14__library_common_defs__["g" /* DEG_TO_RAD */]));
            } // Create the script component and add a script
            _this27.scriptComponent = new __WEBPACK_IMPORTED_MODULE_2__library_script_scriptcomponent__["a" /* ScriptComponent */]();
            _this27.scriptComponent.set(__WEBPACK_IMPORTED_MODULE_3__library_script_scriptmanager__["a" /* scriptManager */].get('ScreenFade')(0, 1, 500));
            return _this27;
        }

        _createClass(RunState, [{
            key: 'generateObj',
            value: function generateObj(type, offsetX, offsetY, rot) {
                var object = void 0;

                if (type === 0) {
                    object = new __WEBPACK_IMPORTED_MODULE_10__library_2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(run)', 'triangle_blue'));
                } else if (type === 1) {
                    object = new __WEBPACK_IMPORTED_MODULE_10__library_2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(run)', 'triangle_green'));
                } else if (type === 2) {
                    object = new __WEBPACK_IMPORTED_MODULE_10__library_2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(run)', 'circle_blue'));
                } else if (type === 3) {
                    object = new __WEBPACK_IMPORTED_MODULE_10__library_2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(run)', 'circle_green'));
                } else {
                    object = new __WEBPACK_IMPORTED_MODULE_10__library_2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(run)', 'square_red'));
                    object.setScaleXYZ(0.9, 0.9, 1);
                }

                object.setPosXYZ(offsetX, offsetY, 0);
                object.setRotXYZ(0, 0, rot);
                object.initPhysics();

                return object;
            }

            // 
            //  DESC: handle events
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                _get(RunState.prototype.__proto__ || Object.getPrototypeOf(RunState.prototype), 'handleEvent', this).call(this, event);

                if (event instanceof CustomEvent) {
                    // Check for the "game change state" message
                    if (event.detail.type === __WEBPACK_IMPORTED_MODULE_14__library_common_defs__["Z" /* EGE_MENU_GAME_STATE_CHANGE */]) {
                        if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_14__library_common_defs__["_50" /* ETC_BEGIN */]) this.scriptComponent.set(__WEBPACK_IMPORTED_MODULE_3__library_script_scriptmanager__["a" /* scriptManager */].get('ScreenFade')(1, 0, 500, true));
                    }
                }
            }

            // 
            //  DESC: Do any pre-game loop init's
            //

        }, {
            key: 'init',
            value: function init() {
                // Unblock the menu messaging and activate needed trees
                __WEBPACK_IMPORTED_MODULE_0__library_gui_menumanager__["a" /* menuManager */].allowEventHandling = true;
                __WEBPACK_IMPORTED_MODULE_0__library_gui_menumanager__["a" /* menuManager */].activateTree(['pause_tree']);

                // Reset the elapsed time before entering the render loop
                __WEBPACK_IMPORTED_MODULE_1__library_utilities_highresolutiontimer__["a" /* highResTimer */].calcElapsedTime();

                requestAnimationFrame(this.callback);
            }

            // 
            //  DESC: Clean up after the startup state
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                __WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].freeGroup(['(run)']);

                __WEBPACK_IMPORTED_MODULE_4__library_physics_physicsworldmanager__["a" /* physicsWorldManager */].destroyWorld("(game)");
            }

            // 
            //  DESC: Handle the physics
            //

        }, {
            key: 'physics',
            value: function physics() {
                if (!__WEBPACK_IMPORTED_MODULE_0__library_gui_menumanager__["a" /* menuManager */].active) this.physicsWorld.variableTimeStep();
            }

            // 
            //  DESC: Update objects that require them
            //

        }, {
            key: 'update',
            value: function update() {
                _get(RunState.prototype.__proto__ || Object.getPrototypeOf(RunState.prototype), 'update', this).call(this);

                this.scriptComponent.update();

                if (!__WEBPACK_IMPORTED_MODULE_0__library_gui_menumanager__["a" /* menuManager */].active) {
                    for (var i = 0; i < this.fallObjects.length; ++i) {
                        this.fallObjects[i].physicsUpdate();

                        if (this.fallObjects[i].pos.y < -600) this.fallObjects[i].physicsComponent.setTransform(__WEBPACK_IMPORTED_MODULE_15__library_utilities_genfunc__["d" /* randomInt */](-700, 700), __WEBPACK_IMPORTED_MODULE_15__library_utilities_genfunc__["d" /* randomInt */](600, 1000), __WEBPACK_IMPORTED_MODULE_15__library_utilities_genfunc__["d" /* randomInt */](0, 360) * __WEBPACK_IMPORTED_MODULE_14__library_common_defs__["g" /* DEG_TO_RAD */], true);
                    }
                }
            }

            // 
            //  DESC: Transform the game objects
            //

        }, {
            key: 'transform',
            value: function transform() {
                _get(RunState.prototype.__proto__ || Object.getPrototypeOf(RunState.prototype), 'transform', this).call(this);

                for (var i = 0; i < this.fallObjects.length; ++i) {
                    this.fallObjects[i].transform();
                }
            }

            // 
            //  DESC: 2D/3D Render of game content
            //

        }, {
            key: 'preRender',
            value: function preRender() {
                _get(RunState.prototype.__proto__ || Object.getPrototypeOf(RunState.prototype), 'preRender', this).call(this);

                var matrix = __WEBPACK_IMPORTED_MODULE_11__library_system_device__["a" /* device */].orthographicMatrix;

                for (var i = 0; i < this.fallObjects.length; ++i) {
                    this.fallObjects[i].render(matrix);
                }for (var _i9 = 0; _i9 < this.pegAry.length; ++_i9) {
                    this.pegAry[_i9].render(matrix);
                }
            }

            // 
            //  DESC: 2D/3D Render of game content
            //

        }, {
            key: 'postRender',
            value: function postRender() {
                _get(RunState.prototype.__proto__ || Object.getPrototypeOf(RunState.prototype), 'postRender', this).call(this);
            }
        }]);

        return RunState;
    }(__WEBPACK_IMPORTED_MODULE_12__commonstate__["a" /* CommonState */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = RunState;

    // 
    //  DESC: Load files
    //
    function load() {
        // Load the xml group
        __WEBPACK_IMPORTED_MODULE_6__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadXMLGroup2D(['(run)'], callback);
        });

        // Load all the textures associated with this group
        __WEBPACK_IMPORTED_MODULE_6__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadTextureGroup2D(['(run)'], callback);
        });

        // Load all the meshes associated with this group
        __WEBPACK_IMPORTED_MODULE_6__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadMeshGroup2D(['(run)'], callback);
        });

        // Create OpenGL objects from the loaded data
        __WEBPACK_IMPORTED_MODULE_6__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_5__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].createFromData(['(run)'], callback);
        });

        // Load the physics list table and group
        __WEBPACK_IMPORTED_MODULE_6__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            __WEBPACK_IMPORTED_MODULE_15__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/objects/2d/physics/physicsListTable.lst', function (xmlNode) {
                // Load the object data list table
                __WEBPACK_IMPORTED_MODULE_4__library_physics_physicsworldmanager__["a" /* physicsWorldManager */].loadListTable(xmlNode);

                // Load the object data XML's
                __WEBPACK_IMPORTED_MODULE_4__library_physics_physicsworldmanager__["a" /* physicsWorldManager */].loadWorldGroup2D('(game)', callback);
            });
        });

        // Create the basic stage strategy
        __WEBPACK_IMPORTED_MODULE_6__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
            return __WEBPACK_IMPORTED_MODULE_8__library_managers_spritestrategymanager__["a" /* spriteStrategyManager */].load('(stage1)', new __WEBPACK_IMPORTED_MODULE_9__library_2d_basicstagestrategy2d__["a" /* BasicStageStrategy2D */](), callback);
        });
    }

    /***/
},
/* 51 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__game__ = __webpack_require__(55);

    // 
    //  FILE NAME: main.js
    //  DESC:      main function
    //


    __webpack_require__(52);

    // Create the game
    var game = new __WEBPACK_IMPORTED_MODULE_0__game__["a" /* Game */]();

    /***/
},
/* 52 */
/***/function (module, exports, __webpack_require__) {

    /* WEBPACK VAR INJECTION */(function (global, process) {
        var require;var require;!function e(t, n, r) {
            function s(o, u) {
                if (!n[o]) {
                    if (!t[o]) {
                        var c = "function" == typeof require && require;if (!u && c) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
                    }var a = n[o] = { exports: {} };t[o][0].call(a.exports, function (n) {
                        var r = t[o][1][n];return s(r ? r : n);
                    }, a, a.exports, e, t, n, r);
                }return n[o].exports;
            }for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) {
                s(r[o]);
            }return s;
        }({ 1: [function (t, n, r) {
                (function (n) {
                    "use strict";
                    function define(t, n, e) {
                        t[n] || Object[r](t, n, { writable: !0, configurable: !0, value: e });
                    }if (t(295), t(296), t(2), n._babelPolyfill) throw new Error("only one instance of babel-polyfill is allowed");n._babelPolyfill = !0;var r = "defineProperty";define(String.prototype, "padLeft", "".padStart), define(String.prototype, "padRight", "".padEnd), "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (t) {
                        [][t] && define(Array, t, Function.call.bind([][t]));
                    });
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
            }, { 2: 2, 295: 295, 296: 296 }], 2: [function (t, n, r) {
                t(119), n.exports = t(23).RegExp.escape;
            }, { 119: 119, 23: 23 }], 3: [function (t, n, r) {
                n.exports = function (t) {
                    if ("function" != typeof t) throw TypeError(t + " is not a function!");return t;
                };
            }, {}], 4: [function (t, n, r) {
                var e = t(18);n.exports = function (t, n) {
                    if ("number" != typeof t && "Number" != e(t)) throw TypeError(n);return +t;
                };
            }, { 18: 18 }], 5: [function (t, n, r) {
                var e = t(117)("unscopables"),
                    i = Array.prototype;void 0 == i[e] && t(40)(i, e, {}), n.exports = function (t) {
                    i[e][t] = !0;
                };
            }, { 117: 117, 40: 40 }], 6: [function (t, n, r) {
                n.exports = function (t, n, r, e) {
                    if (!(t instanceof n) || void 0 !== e && e in t) throw TypeError(r + ": incorrect invocation!");return t;
                };
            }, {}], 7: [function (t, n, r) {
                var e = t(49);n.exports = function (t) {
                    if (!e(t)) throw TypeError(t + " is not an object!");return t;
                };
            }, { 49: 49 }], 8: [function (t, n, r) {
                "use strict";
                var e = t(109),
                    i = t(105),
                    o = t(108);n.exports = [].copyWithin || function copyWithin(t, n) {
                    var r = e(this),
                        u = o(r.length),
                        c = i(t, u),
                        f = i(n, u),
                        a = arguments.length > 2 ? arguments[2] : void 0,
                        s = Math.min((void 0 === a ? u : i(a, u)) - f, u - c),
                        l = 1;for (f < c && c < f + s && (l = -1, f += s - 1, c += s - 1); s-- > 0;) {
                        f in r ? r[c] = r[f] : delete r[c], c += l, f += l;
                    }return r;
                };
            }, { 105: 105, 108: 108, 109: 109 }], 9: [function (t, n, r) {
                "use strict";
                var e = t(109),
                    i = t(105),
                    o = t(108);n.exports = function fill(t) {
                    for (var n = e(this), r = o(n.length), u = arguments.length, c = i(u > 1 ? arguments[1] : void 0, r), f = u > 2 ? arguments[2] : void 0, a = void 0 === f ? r : i(f, r); a > c;) {
                        n[c++] = t;
                    }return n;
                };
            }, { 105: 105, 108: 108, 109: 109 }], 10: [function (t, n, r) {
                var e = t(37);n.exports = function (t, n) {
                    var r = [];return e(t, !1, r.push, r, n), r;
                };
            }, { 37: 37 }], 11: [function (t, n, r) {
                var e = t(107),
                    i = t(108),
                    o = t(105);n.exports = function (t) {
                    return function (n, r, u) {
                        var c,
                            f = e(n),
                            a = i(f.length),
                            s = o(u, a);if (t && r != r) {
                            for (; a > s;) {
                                if (c = f[s++], c != c) return !0;
                            }
                        } else for (; a > s; s++) {
                            if ((t || s in f) && f[s] === r) return t || s || 0;
                        }return !t && -1;
                    };
                };
            }, { 105: 105, 107: 107, 108: 108 }], 12: [function (t, n, r) {
                var e = t(25),
                    i = t(45),
                    o = t(109),
                    u = t(108),
                    c = t(15);n.exports = function (t, n) {
                    var r = 1 == t,
                        f = 2 == t,
                        a = 3 == t,
                        s = 4 == t,
                        l = 6 == t,
                        h = 5 == t || l,
                        v = n || c;return function (n, c, p) {
                        for (var d, y, g = o(n), b = i(g), x = e(c, p, 3), m = u(b.length), w = 0, S = r ? v(n, m) : f ? v(n, 0) : void 0; m > w; w++) {
                            if ((h || w in b) && (d = b[w], y = x(d, w, g), t)) if (r) S[w] = y;else if (y) switch (t) {case 3:
                                    return !0;case 5:
                                    return d;case 6:
                                    return w;case 2:
                                    S.push(d);} else if (s) return !1;
                        }return l ? -1 : a || s ? s : S;
                    };
                };
            }, { 108: 108, 109: 109, 15: 15, 25: 25, 45: 45 }], 13: [function (t, n, r) {
                var e = t(3),
                    i = t(109),
                    o = t(45),
                    u = t(108);n.exports = function (t, n, r, c, f) {
                    e(n);var a = i(t),
                        s = o(a),
                        l = u(a.length),
                        h = f ? l - 1 : 0,
                        v = f ? -1 : 1;if (r < 2) for (;;) {
                        if (h in s) {
                            c = s[h], h += v;break;
                        }if (h += v, f ? h < 0 : l <= h) throw TypeError("Reduce of empty array with no initial value");
                    }for (; f ? h >= 0 : l > h; h += v) {
                        h in s && (c = n(c, s[h], h, a));
                    }return c;
                };
            }, { 108: 108, 109: 109, 3: 3, 45: 45 }], 14: [function (t, n, r) {
                var e = t(49),
                    i = t(47),
                    o = t(117)("species");n.exports = function (t) {
                    var n;return i(t) && (n = t.constructor, "function" != typeof n || n !== Array && !i(n.prototype) || (n = void 0), e(n) && (n = n[o], null === n && (n = void 0))), void 0 === n ? Array : n;
                };
            }, { 117: 117, 47: 47, 49: 49 }], 15: [function (t, n, r) {
                var e = t(14);n.exports = function (t, n) {
                    return new (e(t))(n);
                };
            }, { 14: 14 }], 16: [function (t, n, r) {
                "use strict";
                var e = t(3),
                    i = t(49),
                    o = t(44),
                    u = [].slice,
                    c = {},
                    f = function f(t, n, r) {
                    if (!(n in c)) {
                        for (var e = [], i = 0; i < n; i++) {
                            e[i] = "a[" + i + "]";
                        }c[n] = Function("F,a", "return new F(" + e.join(",") + ")");
                    }return c[n](t, r);
                };n.exports = Function.bind || function bind(t) {
                    var n = e(this),
                        r = u.call(arguments, 1),
                        c = function c() {
                        var e = r.concat(u.call(arguments));return this instanceof c ? f(n, e.length, e) : o(n, e, t);
                    };return i(n.prototype) && (c.prototype = n.prototype), c;
                };
            }, { 3: 3, 44: 44, 49: 49 }], 17: [function (t, n, r) {
                var e = t(18),
                    i = t(117)("toStringTag"),
                    o = "Arguments" == e(function () {
                    return arguments;
                }()),
                    u = function u(t, n) {
                    try {
                        return t[n];
                    } catch (t) {}
                };n.exports = function (t) {
                    var n, r, c;return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (r = u(n = Object(t), i)) ? r : o ? e(n) : "Object" == (c = e(n)) && "function" == typeof n.callee ? "Arguments" : c;
                };
            }, { 117: 117, 18: 18 }], 18: [function (t, n, r) {
                var e = {}.toString;n.exports = function (t) {
                    return e.call(t).slice(8, -1);
                };
            }, {}], 19: [function (t, n, r) {
                "use strict";
                var e = t(67).f,
                    i = t(66),
                    o = t(86),
                    u = t(25),
                    c = t(6),
                    f = t(27),
                    a = t(37),
                    s = t(53),
                    l = t(55),
                    h = t(91),
                    v = t(28),
                    p = t(62).fastKey,
                    d = v ? "_s" : "size",
                    y = function y(t, n) {
                    var r,
                        e = p(n);if ("F" !== e) return t._i[e];for (r = t._f; r; r = r.n) {
                        if (r.k == n) return r;
                    }
                };n.exports = { getConstructor: function getConstructor(t, n, r, s) {
                        var l = t(function (t, e) {
                            c(t, l, n, "_i"), t._i = i(null), t._f = void 0, t._l = void 0, t[d] = 0, void 0 != e && a(e, r, t[s], t);
                        });return o(l.prototype, { clear: function clear() {
                                for (var t = this, n = t._i, r = t._f; r; r = r.n) {
                                    r.r = !0, r.p && (r.p = r.p.n = void 0), delete n[r.i];
                                }t._f = t._l = void 0, t[d] = 0;
                            }, delete: function _delete(t) {
                                var n = this,
                                    r = y(n, t);if (r) {
                                    var e = r.n,
                                        i = r.p;delete n._i[r.i], r.r = !0, i && (i.n = e), e && (e.p = i), n._f == r && (n._f = e), n._l == r && (n._l = i), n[d]--;
                                }return !!r;
                            }, forEach: function forEach(t) {
                                c(this, l, "forEach");for (var n, r = u(t, arguments.length > 1 ? arguments[1] : void 0, 3); n = n ? n.n : this._f;) {
                                    for (r(n.v, n.k, this); n && n.r;) {
                                        n = n.p;
                                    }
                                }
                            }, has: function has(t) {
                                return !!y(this, t);
                            } }), v && e(l.prototype, "size", { get: function get() {
                                return f(this[d]);
                            } }), l;
                    }, def: function def(t, n, r) {
                        var e,
                            i,
                            o = y(t, n);return o ? o.v = r : (t._l = o = { i: i = p(n, !0), k: n, v: r, p: e = t._l, n: void 0, r: !1 }, t._f || (t._f = o), e && (e.n = o), t[d]++, "F" !== i && (t._i[i] = o)), t;
                    }, getEntry: y, setStrong: function setStrong(t, n, r) {
                        s(t, n, function (t, n) {
                            this._t = t, this._k = n, this._l = void 0;
                        }, function () {
                            for (var t = this, n = t._k, r = t._l; r && r.r;) {
                                r = r.p;
                            }return t._t && (t._l = r = r ? r.n : t._t._f) ? "keys" == n ? l(0, r.k) : "values" == n ? l(0, r.v) : l(0, [r.k, r.v]) : (t._t = void 0, l(1));
                        }, r ? "entries" : "values", !r, !0), h(n);
                    } };
            }, { 25: 25, 27: 27, 28: 28, 37: 37, 53: 53, 55: 55, 6: 6, 62: 62, 66: 66, 67: 67, 86: 86, 91: 91 }], 20: [function (t, n, r) {
                var e = t(17),
                    i = t(10);n.exports = function (t) {
                    return function toJSON() {
                        if (e(this) != t) throw TypeError(t + "#toJSON isn't generic");return i(this);
                    };
                };
            }, { 10: 10, 17: 17 }], 21: [function (t, n, r) {
                "use strict";
                var e = t(86),
                    i = t(62).getWeak,
                    o = t(7),
                    u = t(49),
                    c = t(6),
                    f = t(37),
                    a = t(12),
                    s = t(39),
                    l = a(5),
                    h = a(6),
                    v = 0,
                    p = function p(t) {
                    return t._l || (t._l = new d());
                },
                    d = function d() {
                    this.a = [];
                },
                    y = function y(t, n) {
                    return l(t.a, function (t) {
                        return t[0] === n;
                    });
                };d.prototype = { get: function get(t) {
                        var n = y(this, t);if (n) return n[1];
                    }, has: function has(t) {
                        return !!y(this, t);
                    }, set: function set(t, n) {
                        var r = y(this, t);r ? r[1] = n : this.a.push([t, n]);
                    }, delete: function _delete(t) {
                        var n = h(this.a, function (n) {
                            return n[0] === t;
                        });return ~n && this.a.splice(n, 1), !!~n;
                    } }, n.exports = { getConstructor: function getConstructor(t, n, r, o) {
                        var a = t(function (t, e) {
                            c(t, a, n, "_i"), t._i = v++, t._l = void 0, void 0 != e && f(e, r, t[o], t);
                        });return e(a.prototype, { delete: function _delete(t) {
                                if (!u(t)) return !1;var n = i(t);return n === !0 ? p(this).delete(t) : n && s(n, this._i) && delete n[this._i];
                            }, has: function has(t) {
                                if (!u(t)) return !1;var n = i(t);return n === !0 ? p(this).has(t) : n && s(n, this._i);
                            } }), a;
                    }, def: function def(t, n, r) {
                        var e = i(o(n), !0);return e === !0 ? p(t).set(n, r) : e[t._i] = r, t;
                    }, ufstore: p };
            }, { 12: 12, 37: 37, 39: 39, 49: 49, 6: 6, 62: 62, 7: 7, 86: 86 }], 22: [function (t, n, r) {
                "use strict";
                var e = t(38),
                    i = t(32),
                    o = t(87),
                    u = t(86),
                    c = t(62),
                    f = t(37),
                    a = t(6),
                    s = t(49),
                    l = t(34),
                    h = t(54),
                    v = t(92),
                    p = t(43);n.exports = function (t, n, r, d, y, g) {
                    var b = e[t],
                        x = b,
                        m = y ? "set" : "add",
                        w = x && x.prototype,
                        S = {},
                        _ = function _(t) {
                        var n = w[t];o(w, t, "delete" == t ? function (t) {
                            return !(g && !s(t)) && n.call(this, 0 === t ? 0 : t);
                        } : "has" == t ? function has(t) {
                            return !(g && !s(t)) && n.call(this, 0 === t ? 0 : t);
                        } : "get" == t ? function get(t) {
                            return g && !s(t) ? void 0 : n.call(this, 0 === t ? 0 : t);
                        } : "add" == t ? function add(t) {
                            return n.call(this, 0 === t ? 0 : t), this;
                        } : function set(t, r) {
                            return n.call(this, 0 === t ? 0 : t, r), this;
                        });
                    };if ("function" == typeof x && (g || w.forEach && !l(function () {
                        new x().entries().next();
                    }))) {
                        var E = new x(),
                            O = E[m](g ? {} : -0, 1) != E,
                            F = l(function () {
                            E.has(1);
                        }),
                            P = h(function (t) {
                            new x(t);
                        }),
                            M = !g && l(function () {
                            for (var t = new x(), n = 5; n--;) {
                                t[m](n, n);
                            }return !t.has(-0);
                        });P || (x = n(function (n, r) {
                            a(n, x, t);var e = p(new b(), n, x);return void 0 != r && f(r, y, e[m], e), e;
                        }), x.prototype = w, w.constructor = x), (F || M) && (_("delete"), _("has"), y && _("get")), (M || O) && _(m), g && w.clear && delete w.clear;
                    } else x = d.getConstructor(n, t, y, m), u(x.prototype, r), c.NEED = !0;return v(x, t), S[t] = x, i(i.G + i.W + i.F * (x != b), S), g || d.setStrong(x, t, y), x;
                };
            }, { 32: 32, 34: 34, 37: 37, 38: 38, 43: 43, 49: 49, 54: 54, 6: 6, 62: 62, 86: 86, 87: 87, 92: 92 }], 23: [function (t, n, r) {
                var e = n.exports = { version: "2.4.0" };"number" == typeof __e && (__e = e);
            }, {}], 24: [function (t, n, r) {
                "use strict";
                var e = t(67),
                    i = t(85);n.exports = function (t, n, r) {
                    n in t ? e.f(t, n, i(0, r)) : t[n] = r;
                };
            }, { 67: 67, 85: 85 }], 25: [function (t, n, r) {
                var e = t(3);n.exports = function (t, n, r) {
                    if (e(t), void 0 === n) return t;switch (r) {case 1:
                            return function (r) {
                                return t.call(n, r);
                            };case 2:
                            return function (r, e) {
                                return t.call(n, r, e);
                            };case 3:
                            return function (r, e, i) {
                                return t.call(n, r, e, i);
                            };}return function () {
                        return t.apply(n, arguments);
                    };
                };
            }, { 3: 3 }], 26: [function (t, n, r) {
                "use strict";
                var e = t(7),
                    i = t(110),
                    o = "number";n.exports = function (t) {
                    if ("string" !== t && t !== o && "default" !== t) throw TypeError("Incorrect hint");return i(e(this), t != o);
                };
            }, { 110: 110, 7: 7 }], 27: [function (t, n, r) {
                n.exports = function (t) {
                    if (void 0 == t) throw TypeError("Can't call method on  " + t);return t;
                };
            }, {}], 28: [function (t, n, r) {
                n.exports = !t(34)(function () {
                    return 7 != Object.defineProperty({}, "a", { get: function get() {
                            return 7;
                        } }).a;
                });
            }, { 34: 34 }], 29: [function (t, n, r) {
                var e = t(49),
                    i = t(38).document,
                    o = e(i) && e(i.createElement);n.exports = function (t) {
                    return o ? i.createElement(t) : {};
                };
            }, { 38: 38, 49: 49 }], 30: [function (t, n, r) {
                n.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
            }, {}], 31: [function (t, n, r) {
                var e = t(76),
                    i = t(73),
                    o = t(77);n.exports = function (t) {
                    var n = e(t),
                        r = i.f;if (r) for (var u, c = r(t), f = o.f, a = 0; c.length > a;) {
                        f.call(t, u = c[a++]) && n.push(u);
                    }return n;
                };
            }, { 73: 73, 76: 76, 77: 77 }], 32: [function (t, n, r) {
                var e = t(38),
                    i = t(23),
                    o = t(40),
                    u = t(87),
                    c = t(25),
                    f = "prototype",
                    a = function a(t, n, r) {
                    var s,
                        l,
                        h,
                        v,
                        p = t & a.F,
                        d = t & a.G,
                        y = t & a.S,
                        g = t & a.P,
                        b = t & a.B,
                        x = d ? e : y ? e[n] || (e[n] = {}) : (e[n] || {})[f],
                        m = d ? i : i[n] || (i[n] = {}),
                        w = m[f] || (m[f] = {});d && (r = n);for (s in r) {
                        l = !p && x && void 0 !== x[s], h = (l ? x : r)[s], v = b && l ? c(h, e) : g && "function" == typeof h ? c(Function.call, h) : h, x && u(x, s, h, t & a.U), m[s] != h && o(m, s, v), g && w[s] != h && (w[s] = h);
                    }
                };e.core = i, a.F = 1, a.G = 2, a.S = 4, a.P = 8, a.B = 16, a.W = 32, a.U = 64, a.R = 128, n.exports = a;
            }, { 23: 23, 25: 25, 38: 38, 40: 40, 87: 87 }], 33: [function (t, n, r) {
                var e = t(117)("match");n.exports = function (t) {
                    var n = /./;try {
                        "/./"[t](n);
                    } catch (r) {
                        try {
                            return n[e] = !1, !"/./"[t](n);
                        } catch (t) {}
                    }return !0;
                };
            }, { 117: 117 }], 34: [function (t, n, r) {
                n.exports = function (t) {
                    try {
                        return !!t();
                    } catch (t) {
                        return !0;
                    }
                };
            }, {}], 35: [function (t, n, r) {
                "use strict";
                var e = t(40),
                    i = t(87),
                    o = t(34),
                    u = t(27),
                    c = t(117);n.exports = function (t, n, r) {
                    var f = c(t),
                        a = r(u, f, ""[t]),
                        s = a[0],
                        l = a[1];o(function () {
                        var n = {};return n[f] = function () {
                            return 7;
                        }, 7 != ""[t](n);
                    }) && (i(String.prototype, t, s), e(RegExp.prototype, f, 2 == n ? function (t, n) {
                        return l.call(t, this, n);
                    } : function (t) {
                        return l.call(t, this);
                    }));
                };
            }, { 117: 117, 27: 27, 34: 34, 40: 40, 87: 87 }], 36: [function (t, n, r) {
                "use strict";
                var e = t(7);n.exports = function () {
                    var t = e(this),
                        n = "";return t.global && (n += "g"), t.ignoreCase && (n += "i"), t.multiline && (n += "m"), t.unicode && (n += "u"), t.sticky && (n += "y"), n;
                };
            }, { 7: 7 }], 37: [function (t, n, r) {
                var e = t(25),
                    i = t(51),
                    o = t(46),
                    u = t(7),
                    c = t(108),
                    f = t(118),
                    a = {},
                    s = {},
                    r = n.exports = function (t, n, r, l, h) {
                    var v,
                        p,
                        d,
                        y,
                        g = h ? function () {
                        return t;
                    } : f(t),
                        b = e(r, l, n ? 2 : 1),
                        x = 0;if ("function" != typeof g) throw TypeError(t + " is not iterable!");if (o(g)) {
                        for (v = c(t.length); v > x; x++) {
                            if (y = n ? b(u(p = t[x])[0], p[1]) : b(t[x]), y === a || y === s) return y;
                        }
                    } else for (d = g.call(t); !(p = d.next()).done;) {
                        if (y = i(d, b, p.value, n), y === a || y === s) return y;
                    }
                };r.BREAK = a, r.RETURN = s;
            }, { 108: 108, 118: 118, 25: 25, 46: 46, 51: 51, 7: 7 }], 38: [function (t, n, r) {
                var e = n.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();"number" == typeof __g && (__g = e);
            }, {}], 39: [function (t, n, r) {
                var e = {}.hasOwnProperty;n.exports = function (t, n) {
                    return e.call(t, n);
                };
            }, {}], 40: [function (t, n, r) {
                var e = t(67),
                    i = t(85);n.exports = t(28) ? function (t, n, r) {
                    return e.f(t, n, i(1, r));
                } : function (t, n, r) {
                    return t[n] = r, t;
                };
            }, { 28: 28, 67: 67, 85: 85 }], 41: [function (t, n, r) {
                n.exports = t(38).document && document.documentElement;
            }, { 38: 38 }], 42: [function (t, n, r) {
                n.exports = !t(28) && !t(34)(function () {
                    return 7 != Object.defineProperty(t(29)("div"), "a", { get: function get() {
                            return 7;
                        } }).a;
                });
            }, { 28: 28, 29: 29, 34: 34 }], 43: [function (t, n, r) {
                var e = t(49),
                    i = t(90).set;n.exports = function (t, n, r) {
                    var o,
                        u = n.constructor;return u !== r && "function" == typeof u && (o = u.prototype) !== r.prototype && e(o) && i && i(t, o), t;
                };
            }, { 49: 49, 90: 90 }], 44: [function (t, n, r) {
                n.exports = function (t, n, r) {
                    var e = void 0 === r;switch (n.length) {case 0:
                            return e ? t() : t.call(r);case 1:
                            return e ? t(n[0]) : t.call(r, n[0]);case 2:
                            return e ? t(n[0], n[1]) : t.call(r, n[0], n[1]);case 3:
                            return e ? t(n[0], n[1], n[2]) : t.call(r, n[0], n[1], n[2]);case 4:
                            return e ? t(n[0], n[1], n[2], n[3]) : t.call(r, n[0], n[1], n[2], n[3]);}return t.apply(r, n);
                };
            }, {}], 45: [function (t, n, r) {
                var e = t(18);n.exports = Object("z").propertyIsEnumerable(0) ? Object : function (t) {
                    return "String" == e(t) ? t.split("") : Object(t);
                };
            }, { 18: 18 }], 46: [function (t, n, r) {
                var e = t(56),
                    i = t(117)("iterator"),
                    o = Array.prototype;n.exports = function (t) {
                    return void 0 !== t && (e.Array === t || o[i] === t);
                };
            }, { 117: 117, 56: 56 }], 47: [function (t, n, r) {
                var e = t(18);n.exports = Array.isArray || function isArray(t) {
                    return "Array" == e(t);
                };
            }, { 18: 18 }], 48: [function (t, n, r) {
                var e = t(49),
                    i = Math.floor;n.exports = function isInteger(t) {
                    return !e(t) && isFinite(t) && i(t) === t;
                };
            }, { 49: 49 }], 49: [function (t, n, r) {
                n.exports = function (t) {
                    return "object" == (typeof t === 'undefined' ? 'undefined' : _typeof(t)) ? null !== t : "function" == typeof t;
                };
            }, {}], 50: [function (t, n, r) {
                var e = t(49),
                    i = t(18),
                    o = t(117)("match");n.exports = function (t) {
                    var n;return e(t) && (void 0 !== (n = t[o]) ? !!n : "RegExp" == i(t));
                };
            }, { 117: 117, 18: 18, 49: 49 }], 51: [function (t, n, r) {
                var e = t(7);n.exports = function (t, n, r, i) {
                    try {
                        return i ? n(e(r)[0], r[1]) : n(r);
                    } catch (n) {
                        var o = t.return;throw void 0 !== o && e(o.call(t)), n;
                    }
                };
            }, { 7: 7 }], 52: [function (t, n, r) {
                "use strict";
                var e = t(66),
                    i = t(85),
                    o = t(92),
                    u = {};t(40)(u, t(117)("iterator"), function () {
                    return this;
                }), n.exports = function (t, n, r) {
                    t.prototype = e(u, { next: i(1, r) }), o(t, n + " Iterator");
                };
            }, { 117: 117, 40: 40, 66: 66, 85: 85, 92: 92 }], 53: [function (t, n, r) {
                "use strict";
                var e = t(58),
                    i = t(32),
                    o = t(87),
                    u = t(40),
                    c = t(39),
                    f = t(56),
                    a = t(52),
                    s = t(92),
                    l = t(74),
                    h = t(117)("iterator"),
                    v = !([].keys && "next" in [].keys()),
                    p = "@@iterator",
                    d = "keys",
                    y = "values",
                    g = function g() {
                    return this;
                };n.exports = function (t, n, r, b, x, m, w) {
                    a(r, n, b);var S,
                        _,
                        E,
                        O = function O(t) {
                        if (!v && t in A) return A[t];switch (t) {case d:
                                return function keys() {
                                    return new r(this, t);
                                };case y:
                                return function values() {
                                    return new r(this, t);
                                };}return function entries() {
                            return new r(this, t);
                        };
                    },
                        F = n + " Iterator",
                        P = x == y,
                        M = !1,
                        A = t.prototype,
                        I = A[h] || A[p] || x && A[x],
                        j = I || O(x),
                        N = x ? P ? O("entries") : j : void 0,
                        k = "Array" == n ? A.entries || I : I;if (k && (E = l(k.call(new t())), E !== Object.prototype && (s(E, F, !0), e || c(E, h) || u(E, h, g))), P && I && I.name !== y && (M = !0, j = function values() {
                        return I.call(this);
                    }), e && !w || !v && !M && A[h] || u(A, h, j), f[n] = j, f[F] = g, x) if (S = { values: P ? j : O(y), keys: m ? j : O(d), entries: N }, w) for (_ in S) {
                        _ in A || o(A, _, S[_]);
                    } else i(i.P + i.F * (v || M), n, S);return S;
                };
            }, { 117: 117, 32: 32, 39: 39, 40: 40, 52: 52, 56: 56, 58: 58, 74: 74, 87: 87, 92: 92 }], 54: [function (t, n, r) {
                var e = t(117)("iterator"),
                    i = !1;try {
                    var o = [7][e]();o.return = function () {
                        i = !0;
                    }, Array.from(o, function () {
                        throw 2;
                    });
                } catch (t) {}n.exports = function (t, n) {
                    if (!n && !i) return !1;var r = !1;try {
                        var o = [7],
                            u = o[e]();u.next = function () {
                            return { done: r = !0 };
                        }, o[e] = function () {
                            return u;
                        }, t(o);
                    } catch (t) {}return r;
                };
            }, { 117: 117 }], 55: [function (t, n, r) {
                n.exports = function (t, n) {
                    return { value: n, done: !!t };
                };
            }, {}], 56: [function (t, n, r) {
                n.exports = {};
            }, {}], 57: [function (t, n, r) {
                var e = t(76),
                    i = t(107);n.exports = function (t, n) {
                    for (var r, o = i(t), u = e(o), c = u.length, f = 0; c > f;) {
                        if (o[r = u[f++]] === n) return r;
                    }
                };
            }, { 107: 107, 76: 76 }], 58: [function (t, n, r) {
                n.exports = !1;
            }, {}], 59: [function (t, n, r) {
                var e = Math.expm1;n.exports = !e || e(10) > 22025.465794806718 || e(10) < 22025.465794806718 || e(-2e-17) != -2e-17 ? function expm1(t) {
                    return 0 == (t = +t) ? t : t > -1e-6 && t < 1e-6 ? t + t * t / 2 : Math.exp(t) - 1;
                } : e;
            }, {}], 60: [function (t, n, r) {
                n.exports = Math.log1p || function log1p(t) {
                    return (t = +t) > -1e-8 && t < 1e-8 ? t - t * t / 2 : Math.log(1 + t);
                };
            }, {}], 61: [function (t, n, r) {
                n.exports = Math.sign || function sign(t) {
                    return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1;
                };
            }, {}], 62: [function (t, n, r) {
                var e = t(114)("meta"),
                    i = t(49),
                    o = t(39),
                    u = t(67).f,
                    c = 0,
                    f = Object.isExtensible || function () {
                    return !0;
                },
                    a = !t(34)(function () {
                    return f(Object.preventExtensions({}));
                }),
                    s = function s(t) {
                    u(t, e, { value: { i: "O" + ++c, w: {} } });
                },
                    l = function l(t, n) {
                    if (!i(t)) return "symbol" == (typeof t === 'undefined' ? 'undefined' : _typeof(t)) ? t : ("string" == typeof t ? "S" : "P") + t;if (!o(t, e)) {
                        if (!f(t)) return "F";if (!n) return "E";s(t);
                    }return t[e].i;
                },
                    h = function h(t, n) {
                    if (!o(t, e)) {
                        if (!f(t)) return !0;if (!n) return !1;s(t);
                    }return t[e].w;
                },
                    v = function v(t) {
                    return a && p.NEED && f(t) && !o(t, e) && s(t), t;
                },
                    p = n.exports = { KEY: e, NEED: !1, fastKey: l, getWeak: h, onFreeze: v };
            }, { 114: 114, 34: 34, 39: 39, 49: 49, 67: 67 }], 63: [function (t, n, r) {
                var e = t(149),
                    i = t(32),
                    o = t(94)("metadata"),
                    u = o.store || (o.store = new (t(255))()),
                    c = function c(t, n, r) {
                    var i = u.get(t);if (!i) {
                        if (!r) return;u.set(t, i = new e());
                    }var o = i.get(n);if (!o) {
                        if (!r) return;i.set(n, o = new e());
                    }return o;
                },
                    f = function f(t, n, r) {
                    var e = c(n, r, !1);return void 0 !== e && e.has(t);
                },
                    a = function a(t, n, r) {
                    var e = c(n, r, !1);return void 0 === e ? void 0 : e.get(t);
                },
                    s = function s(t, n, r, e) {
                    c(r, e, !0).set(t, n);
                },
                    l = function l(t, n) {
                    var r = c(t, n, !1),
                        e = [];return r && r.forEach(function (t, n) {
                        e.push(n);
                    }), e;
                },
                    h = function h(t) {
                    return void 0 === t || "symbol" == (typeof t === 'undefined' ? 'undefined' : _typeof(t)) ? t : String(t);
                },
                    v = function v(t) {
                    i(i.S, "Reflect", t);
                };n.exports = { store: u, map: c, has: f, get: a, set: s, keys: l, key: h, exp: v };
            }, { 149: 149, 255: 255, 32: 32, 94: 94 }], 64: [function (t, n, r) {
                var e = t(38),
                    i = t(104).set,
                    o = e.MutationObserver || e.WebKitMutationObserver,
                    u = e.process,
                    c = e.Promise,
                    f = "process" == t(18)(u);n.exports = function () {
                    var t,
                        n,
                        r,
                        a = function a() {
                        var e, i;for (f && (e = u.domain) && e.exit(); t;) {
                            i = t.fn, t = t.next;try {
                                i();
                            } catch (e) {
                                throw t ? r() : n = void 0, e;
                            }
                        }n = void 0, e && e.enter();
                    };if (f) r = function r() {
                        u.nextTick(a);
                    };else if (o) {
                        var s = !0,
                            l = document.createTextNode("");new o(a).observe(l, { characterData: !0 }), r = function r() {
                            l.data = s = !s;
                        };
                    } else if (c && c.resolve) {
                        var h = c.resolve();r = function r() {
                            h.then(a);
                        };
                    } else r = function r() {
                        i.call(e, a);
                    };return function (e) {
                        var i = { fn: e, next: void 0 };n && (n.next = i), t || (t = i, r()), n = i;
                    };
                };
            }, { 104: 104, 18: 18, 38: 38 }], 65: [function (t, n, r) {
                "use strict";
                var e = t(76),
                    i = t(73),
                    o = t(77),
                    u = t(109),
                    c = t(45),
                    f = Object.assign;n.exports = !f || t(34)(function () {
                    var t = {},
                        n = {},
                        r = Symbol(),
                        e = "abcdefghijklmnopqrst";return t[r] = 7, e.split("").forEach(function (t) {
                        n[t] = t;
                    }), 7 != f({}, t)[r] || Object.keys(f({}, n)).join("") != e;
                }) ? function assign(t, n) {
                    for (var r = u(t), f = arguments.length, a = 1, s = i.f, l = o.f; f > a;) {
                        for (var h, v = c(arguments[a++]), p = s ? e(v).concat(s(v)) : e(v), d = p.length, y = 0; d > y;) {
                            l.call(v, h = p[y++]) && (r[h] = v[h]);
                        }
                    }return r;
                } : f;
            }, { 109: 109, 34: 34, 45: 45, 73: 73, 76: 76, 77: 77 }], 66: [function (t, n, r) {
                var e = t(7),
                    i = t(68),
                    o = t(30),
                    u = t(93)("IE_PROTO"),
                    c = function c() {},
                    f = "prototype",
                    _a = function a() {
                    var n,
                        r = t(29)("iframe"),
                        e = o.length,
                        i = "<",
                        u = ">";for (r.style.display = "none", t(41).appendChild(r), r.src = "javascript:", n = r.contentWindow.document, n.open(), n.write(i + "script" + u + "document.F=Object" + i + "/script" + u), n.close(), _a = n.F; e--;) {
                        delete _a[f][o[e]];
                    }return _a();
                };n.exports = Object.create || function create(t, n) {
                    var r;return null !== t ? (c[f] = e(t), r = new c(), c[f] = null, r[u] = t) : r = _a(), void 0 === n ? r : i(r, n);
                };
            }, { 29: 29, 30: 30, 41: 41, 68: 68, 7: 7, 93: 93 }], 67: [function (t, n, r) {
                var e = t(7),
                    i = t(42),
                    o = t(110),
                    u = Object.defineProperty;r.f = t(28) ? Object.defineProperty : function defineProperty(t, n, r) {
                    if (e(t), n = o(n, !0), e(r), i) try {
                        return u(t, n, r);
                    } catch (t) {}if ("get" in r || "set" in r) throw TypeError("Accessors not supported!");return "value" in r && (t[n] = r.value), t;
                };
            }, { 110: 110, 28: 28, 42: 42, 7: 7 }], 68: [function (t, n, r) {
                var e = t(67),
                    i = t(7),
                    o = t(76);n.exports = t(28) ? Object.defineProperties : function defineProperties(t, n) {
                    i(t);for (var r, u = o(n), c = u.length, f = 0; c > f;) {
                        e.f(t, r = u[f++], n[r]);
                    }return t;
                };
            }, { 28: 28, 67: 67, 7: 7, 76: 76 }], 69: [function (t, n, r) {
                n.exports = t(58) || !t(34)(function () {
                    var n = Math.random();__defineSetter__.call(null, n, function () {}), delete t(38)[n];
                });
            }, { 34: 34, 38: 38, 58: 58 }], 70: [function (t, n, r) {
                var e = t(77),
                    i = t(85),
                    o = t(107),
                    u = t(110),
                    c = t(39),
                    f = t(42),
                    a = Object.getOwnPropertyDescriptor;r.f = t(28) ? a : function getOwnPropertyDescriptor(t, n) {
                    if (t = o(t), n = u(n, !0), f) try {
                        return a(t, n);
                    } catch (t) {}if (c(t, n)) return i(!e.f.call(t, n), t[n]);
                };
            }, { 107: 107, 110: 110, 28: 28, 39: 39, 42: 42, 77: 77, 85: 85 }], 71: [function (t, n, r) {
                var e = t(107),
                    i = t(72).f,
                    o = {}.toString,
                    u = "object" == (typeof window === 'undefined' ? 'undefined' : _typeof(window)) && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
                    c = function c(t) {
                    try {
                        return i(t);
                    } catch (t) {
                        return u.slice();
                    }
                };n.exports.f = function getOwnPropertyNames(t) {
                    return u && "[object Window]" == o.call(t) ? c(t) : i(e(t));
                };
            }, { 107: 107, 72: 72 }], 72: [function (t, n, r) {
                var e = t(75),
                    i = t(30).concat("length", "prototype");r.f = Object.getOwnPropertyNames || function getOwnPropertyNames(t) {
                    return e(t, i);
                };
            }, { 30: 30, 75: 75 }], 73: [function (t, n, r) {
                r.f = Object.getOwnPropertySymbols;
            }, {}], 74: [function (t, n, r) {
                var e = t(39),
                    i = t(109),
                    o = t(93)("IE_PROTO"),
                    u = Object.prototype;n.exports = Object.getPrototypeOf || function (t) {
                    return t = i(t), e(t, o) ? t[o] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null;
                };
            }, { 109: 109, 39: 39, 93: 93 }], 75: [function (t, n, r) {
                var e = t(39),
                    i = t(107),
                    o = t(11)(!1),
                    u = t(93)("IE_PROTO");n.exports = function (t, n) {
                    var r,
                        c = i(t),
                        f = 0,
                        a = [];for (r in c) {
                        r != u && e(c, r) && a.push(r);
                    }for (; n.length > f;) {
                        e(c, r = n[f++]) && (~o(a, r) || a.push(r));
                    }return a;
                };
            }, { 107: 107, 11: 11, 39: 39, 93: 93 }], 76: [function (t, n, r) {
                var e = t(75),
                    i = t(30);n.exports = Object.keys || function keys(t) {
                    return e(t, i);
                };
            }, { 30: 30, 75: 75 }], 77: [function (t, n, r) {
                r.f = {}.propertyIsEnumerable;
            }, {}], 78: [function (t, n, r) {
                var e = t(32),
                    i = t(23),
                    o = t(34);n.exports = function (t, n) {
                    var r = (i.Object || {})[t] || Object[t],
                        u = {};u[t] = n(r), e(e.S + e.F * o(function () {
                        r(1);
                    }), "Object", u);
                };
            }, { 23: 23, 32: 32, 34: 34 }], 79: [function (t, n, r) {
                var e = t(76),
                    i = t(107),
                    o = t(77).f;n.exports = function (t) {
                    return function (n) {
                        for (var r, u = i(n), c = e(u), f = c.length, a = 0, s = []; f > a;) {
                            o.call(u, r = c[a++]) && s.push(t ? [r, u[r]] : u[r]);
                        }return s;
                    };
                };
            }, { 107: 107, 76: 76, 77: 77 }], 80: [function (t, n, r) {
                var e = t(72),
                    i = t(73),
                    o = t(7),
                    u = t(38).Reflect;n.exports = u && u.ownKeys || function ownKeys(t) {
                    var n = e.f(o(t)),
                        r = i.f;return r ? n.concat(r(t)) : n;
                };
            }, { 38: 38, 7: 7, 72: 72, 73: 73 }], 81: [function (t, n, r) {
                var e = t(38).parseFloat,
                    i = t(102).trim;n.exports = 1 / e(t(103) + "-0") !== -(1 / 0) ? function parseFloat(t) {
                    var n = i(String(t), 3),
                        r = e(n);return 0 === r && "-" == n.charAt(0) ? -0 : r;
                } : e;
            }, { 102: 102, 103: 103, 38: 38 }], 82: [function (t, n, r) {
                var e = t(38).parseInt,
                    i = t(102).trim,
                    o = t(103),
                    u = /^[\-+]?0[xX]/;n.exports = 8 !== e(o + "08") || 22 !== e(o + "0x16") ? function parseInt(t, n) {
                    var r = i(String(t), 3);return e(r, n >>> 0 || (u.test(r) ? 16 : 10));
                } : e;
            }, { 102: 102, 103: 103, 38: 38 }], 83: [function (t, n, r) {
                "use strict";
                var e = t(84),
                    i = t(44),
                    o = t(3);n.exports = function () {
                    for (var t = o(this), n = arguments.length, r = Array(n), u = 0, c = e._, f = !1; n > u;) {
                        (r[u] = arguments[u++]) === c && (f = !0);
                    }return function () {
                        var e,
                            o = this,
                            u = arguments.length,
                            a = 0,
                            s = 0;if (!f && !u) return i(t, r, o);if (e = r.slice(), f) for (; n > a; a++) {
                            e[a] === c && (e[a] = arguments[s++]);
                        }for (; u > s;) {
                            e.push(arguments[s++]);
                        }return i(t, e, o);
                    };
                };
            }, { 3: 3, 44: 44, 84: 84 }], 84: [function (t, n, r) {
                n.exports = t(38);
            }, { 38: 38 }], 85: [function (t, n, r) {
                n.exports = function (t, n) {
                    return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: n };
                };
            }, {}], 86: [function (t, n, r) {
                var e = t(87);n.exports = function (t, n, r) {
                    for (var i in n) {
                        e(t, i, n[i], r);
                    }return t;
                };
            }, { 87: 87 }], 87: [function (t, n, r) {
                var e = t(38),
                    i = t(40),
                    o = t(39),
                    u = t(114)("src"),
                    c = "toString",
                    f = Function[c],
                    a = ("" + f).split(c);t(23).inspectSource = function (t) {
                    return f.call(t);
                }, (n.exports = function (t, n, r, c) {
                    var f = "function" == typeof r;f && (o(r, "name") || i(r, "name", n)), t[n] !== r && (f && (o(r, u) || i(r, u, t[n] ? "" + t[n] : a.join(String(n)))), t === e ? t[n] = r : c ? t[n] ? t[n] = r : i(t, n, r) : (delete t[n], i(t, n, r)));
                })(Function.prototype, c, function toString() {
                    return "function" == typeof this && this[u] || f.call(this);
                });
            }, { 114: 114, 23: 23, 38: 38, 39: 39, 40: 40 }], 88: [function (t, n, r) {
                n.exports = function (t, n) {
                    var r = n === Object(n) ? function (t) {
                        return n[t];
                    } : n;return function (n) {
                        return String(n).replace(t, r);
                    };
                };
            }, {}], 89: [function (t, n, r) {
                n.exports = Object.is || function is(t, n) {
                    return t === n ? 0 !== t || 1 / t === 1 / n : t != t && n != n;
                };
            }, {}], 90: [function (t, n, r) {
                var e = t(49),
                    i = t(7),
                    o = function o(t, n) {
                    if (i(t), !e(n) && null !== n) throw TypeError(n + ": can't set as prototype!");
                };n.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function (n, r, e) {
                        try {
                            e = t(25)(Function.call, t(70).f(Object.prototype, "__proto__").set, 2), e(n, []), r = !(n instanceof Array);
                        } catch (t) {
                            r = !0;
                        }return function setPrototypeOf(t, n) {
                            return o(t, n), r ? t.__proto__ = n : e(t, n), t;
                        };
                    }({}, !1) : void 0), check: o };
            }, { 25: 25, 49: 49, 7: 7, 70: 70 }], 91: [function (t, n, r) {
                "use strict";
                var e = t(38),
                    i = t(67),
                    o = t(28),
                    u = t(117)("species");n.exports = function (t) {
                    var n = e[t];o && n && !n[u] && i.f(n, u, { configurable: !0, get: function get() {
                            return this;
                        } });
                };
            }, { 117: 117, 28: 28, 38: 38, 67: 67 }], 92: [function (t, n, r) {
                var e = t(67).f,
                    i = t(39),
                    o = t(117)("toStringTag");n.exports = function (t, n, r) {
                    t && !i(t = r ? t : t.prototype, o) && e(t, o, { configurable: !0, value: n });
                };
            }, { 117: 117, 39: 39, 67: 67 }], 93: [function (t, n, r) {
                var e = t(94)("keys"),
                    i = t(114);n.exports = function (t) {
                    return e[t] || (e[t] = i(t));
                };
            }, { 114: 114, 94: 94 }], 94: [function (t, n, r) {
                var e = t(38),
                    i = "__core-js_shared__",
                    o = e[i] || (e[i] = {});n.exports = function (t) {
                    return o[t] || (o[t] = {});
                };
            }, { 38: 38 }], 95: [function (t, n, r) {
                var e = t(7),
                    i = t(3),
                    o = t(117)("species");n.exports = function (t, n) {
                    var r,
                        u = e(t).constructor;return void 0 === u || void 0 == (r = e(u)[o]) ? n : i(r);
                };
            }, { 117: 117, 3: 3, 7: 7 }], 96: [function (t, n, r) {
                var e = t(34);n.exports = function (t, n) {
                    return !!t && e(function () {
                        n ? t.call(null, function () {}, 1) : t.call(null);
                    });
                };
            }, { 34: 34 }], 97: [function (t, n, r) {
                var e = t(106),
                    i = t(27);n.exports = function (t) {
                    return function (n, r) {
                        var o,
                            u,
                            c = String(i(n)),
                            f = e(r),
                            a = c.length;return f < 0 || f >= a ? t ? "" : void 0 : (o = c.charCodeAt(f), o < 55296 || o > 56319 || f + 1 === a || (u = c.charCodeAt(f + 1)) < 56320 || u > 57343 ? t ? c.charAt(f) : o : t ? c.slice(f, f + 2) : (o - 55296 << 10) + (u - 56320) + 65536);
                    };
                };
            }, { 106: 106, 27: 27 }], 98: [function (t, n, r) {
                var e = t(50),
                    i = t(27);n.exports = function (t, n, r) {
                    if (e(n)) throw TypeError("String#" + r + " doesn't accept regex!");return String(i(t));
                };
            }, { 27: 27, 50: 50 }], 99: [function (t, n, r) {
                var e = t(32),
                    i = t(34),
                    o = t(27),
                    u = /"/g,
                    c = function c(t, n, r, e) {
                    var i = String(o(t)),
                        c = "<" + n;return "" !== r && (c += " " + r + '="' + String(e).replace(u, "&quot;") + '"'), c + ">" + i + "</" + n + ">";
                };n.exports = function (t, n) {
                    var r = {};r[t] = n(c), e(e.P + e.F * i(function () {
                        var n = ""[t]('"');return n !== n.toLowerCase() || n.split('"').length > 3;
                    }), "String", r);
                };
            }, { 27: 27, 32: 32, 34: 34 }], 100: [function (t, n, r) {
                var e = t(108),
                    i = t(101),
                    o = t(27);n.exports = function (t, n, r, u) {
                    var c = String(o(t)),
                        f = c.length,
                        a = void 0 === r ? " " : String(r),
                        s = e(n);if (s <= f || "" == a) return c;var l = s - f,
                        h = i.call(a, Math.ceil(l / a.length));return h.length > l && (h = h.slice(0, l)), u ? h + c : c + h;
                };
            }, { 101: 101, 108: 108, 27: 27 }], 101: [function (t, n, r) {
                "use strict";
                var e = t(106),
                    i = t(27);n.exports = function repeat(t) {
                    var n = String(i(this)),
                        r = "",
                        o = e(t);if (o < 0 || o == 1 / 0) throw RangeError("Count can't be negative");for (; o > 0; (o >>>= 1) && (n += n)) {
                        1 & o && (r += n);
                    }return r;
                };
            }, { 106: 106, 27: 27 }], 102: [function (t, n, r) {
                var e = t(32),
                    i = t(27),
                    o = t(34),
                    u = t(103),
                    c = "[" + u + "]",
                    f = "​",
                    a = RegExp("^" + c + c + "*"),
                    s = RegExp(c + c + "*$"),
                    l = function l(t, n, r) {
                    var i = {},
                        c = o(function () {
                        return !!u[t]() || f[t]() != f;
                    }),
                        a = i[t] = c ? n(h) : u[t];r && (i[r] = a), e(e.P + e.F * c, "String", i);
                },
                    h = l.trim = function (t, n) {
                    return t = String(i(t)), 1 & n && (t = t.replace(a, "")), 2 & n && (t = t.replace(s, "")), t;
                };n.exports = l;
            }, { 103: 103, 27: 27, 32: 32, 34: 34 }], 103: [function (t, n, r) {
                n.exports = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
            }, {}], 104: [function (t, n, r) {
                var e,
                    i,
                    o,
                    u = t(25),
                    c = t(44),
                    f = t(41),
                    a = t(29),
                    s = t(38),
                    l = s.process,
                    h = s.setImmediate,
                    v = s.clearImmediate,
                    p = s.MessageChannel,
                    d = 0,
                    y = {},
                    g = "onreadystatechange",
                    b = function b() {
                    var t = +this;if (y.hasOwnProperty(t)) {
                        var n = y[t];delete y[t], n();
                    }
                },
                    x = function x(t) {
                    b.call(t.data);
                };h && v || (h = function setImmediate(t) {
                    for (var n = [], r = 1; arguments.length > r;) {
                        n.push(arguments[r++]);
                    }return y[++d] = function () {
                        c("function" == typeof t ? t : Function(t), n);
                    }, e(d), d;
                }, v = function clearImmediate(t) {
                    delete y[t];
                }, "process" == t(18)(l) ? e = function e(t) {
                    l.nextTick(u(b, t, 1));
                } : p ? (i = new p(), o = i.port2, i.port1.onmessage = x, e = u(o.postMessage, o, 1)) : s.addEventListener && "function" == typeof postMessage && !s.importScripts ? (e = function e(t) {
                    s.postMessage(t + "", "*");
                }, s.addEventListener("message", x, !1)) : e = g in a("script") ? function (t) {
                    f.appendChild(a("script"))[g] = function () {
                        f.removeChild(this), b.call(t);
                    };
                } : function (t) {
                    setTimeout(u(b, t, 1), 0);
                }), n.exports = { set: h, clear: v };
            }, { 18: 18, 25: 25, 29: 29, 38: 38, 41: 41, 44: 44 }], 105: [function (t, n, r) {
                var e = t(106),
                    i = Math.max,
                    o = Math.min;n.exports = function (t, n) {
                    return t = e(t), t < 0 ? i(t + n, 0) : o(t, n);
                };
            }, { 106: 106 }], 106: [function (t, n, r) {
                var e = Math.ceil,
                    i = Math.floor;n.exports = function (t) {
                    return isNaN(t = +t) ? 0 : (t > 0 ? i : e)(t);
                };
            }, {}], 107: [function (t, n, r) {
                var e = t(45),
                    i = t(27);n.exports = function (t) {
                    return e(i(t));
                };
            }, { 27: 27, 45: 45 }], 108: [function (t, n, r) {
                var e = t(106),
                    i = Math.min;n.exports = function (t) {
                    return t > 0 ? i(e(t), 9007199254740991) : 0;
                };
            }, { 106: 106 }], 109: [function (t, n, r) {
                var e = t(27);n.exports = function (t) {
                    return Object(e(t));
                };
            }, { 27: 27 }], 110: [function (t, n, r) {
                var e = t(49);n.exports = function (t, n) {
                    if (!e(t)) return t;var r, i;if (n && "function" == typeof (r = t.toString) && !e(i = r.call(t))) return i;if ("function" == typeof (r = t.valueOf) && !e(i = r.call(t))) return i;if (!n && "function" == typeof (r = t.toString) && !e(i = r.call(t))) return i;throw TypeError("Can't convert object to primitive value");
                };
            }, { 49: 49 }], 111: [function (t, n, r) {
                "use strict";
                if (t(28)) {
                    var e = t(58),
                        i = t(38),
                        o = t(34),
                        u = t(32),
                        c = t(113),
                        f = t(112),
                        a = t(25),
                        s = t(6),
                        l = t(85),
                        h = t(40),
                        v = t(86),
                        p = t(106),
                        d = t(108),
                        y = t(105),
                        g = t(110),
                        b = t(39),
                        x = t(89),
                        m = t(17),
                        w = t(49),
                        S = t(109),
                        _ = t(46),
                        E = t(66),
                        O = t(74),
                        F = t(72).f,
                        P = t(118),
                        M = t(114),
                        A = t(117),
                        I = t(12),
                        j = t(11),
                        N = t(95),
                        k = t(130),
                        R = t(56),
                        T = t(54),
                        L = t(91),
                        C = t(9),
                        U = t(8),
                        G = t(67),
                        D = t(70),
                        W = G.f,
                        B = D.f,
                        V = i.RangeError,
                        z = i.TypeError,
                        K = i.Uint8Array,
                        J = "ArrayBuffer",
                        Y = "Shared" + J,
                        q = "BYTES_PER_ELEMENT",
                        X = "prototype",
                        $ = Array[X],
                        H = f.ArrayBuffer,
                        Z = f.DataView,
                        Q = I(0),
                        tt = I(2),
                        nt = I(3),
                        rt = I(4),
                        et = I(5),
                        it = I(6),
                        ot = j(!0),
                        ut = j(!1),
                        ct = k.values,
                        ft = k.keys,
                        at = k.entries,
                        st = $.lastIndexOf,
                        lt = $.reduce,
                        ht = $.reduceRight,
                        vt = $.join,
                        pt = $.sort,
                        dt = $.slice,
                        yt = $.toString,
                        gt = $.toLocaleString,
                        bt = A("iterator"),
                        xt = A("toStringTag"),
                        mt = M("typed_constructor"),
                        wt = M("def_constructor"),
                        St = c.CONSTR,
                        _t = c.TYPED,
                        Et = c.VIEW,
                        Ot = "Wrong length!",
                        Ft = I(1, function (t, n) {
                        return Nt(N(t, t[wt]), n);
                    }),
                        Pt = o(function () {
                        return 1 === new K(new Uint16Array([1]).buffer)[0];
                    }),
                        Mt = !!K && !!K[X].set && o(function () {
                        new K(1).set({});
                    }),
                        At = function At(t, n) {
                        if (void 0 === t) throw z(Ot);var r = +t,
                            e = d(t);if (n && !x(r, e)) throw V(Ot);return e;
                    },
                        It = function It(t, n) {
                        var r = p(t);if (r < 0 || r % n) throw V("Wrong offset!");return r;
                    },
                        jt = function jt(t) {
                        if (w(t) && _t in t) return t;throw z(t + " is not a typed array!");
                    },
                        Nt = function Nt(t, n) {
                        if (!(w(t) && mt in t)) throw z("It is not a typed array constructor!");return new t(n);
                    },
                        kt = function kt(t, n) {
                        return Rt(N(t, t[wt]), n);
                    },
                        Rt = function Rt(t, n) {
                        for (var r = 0, e = n.length, i = Nt(t, e); e > r;) {
                            i[r] = n[r++];
                        }return i;
                    },
                        Tt = function Tt(t, n, r) {
                        W(t, n, { get: function get() {
                                return this._d[r];
                            } });
                    },
                        Lt = function from(t) {
                        var n,
                            r,
                            e,
                            i,
                            o,
                            u,
                            c = S(t),
                            f = arguments.length,
                            s = f > 1 ? arguments[1] : void 0,
                            l = void 0 !== s,
                            h = P(c);if (void 0 != h && !_(h)) {
                            for (u = h.call(c), e = [], n = 0; !(o = u.next()).done; n++) {
                                e.push(o.value);
                            }c = e;
                        }for (l && f > 2 && (s = a(s, arguments[2], 2)), n = 0, r = d(c.length), i = Nt(this, r); r > n; n++) {
                            i[n] = l ? s(c[n], n) : c[n];
                        }return i;
                    },
                        Ct = function of() {
                        for (var t = 0, n = arguments.length, r = Nt(this, n); n > t;) {
                            r[t] = arguments[t++];
                        }return r;
                    },
                        Ut = !!K && o(function () {
                        gt.call(new K(1));
                    }),
                        Gt = function toLocaleString() {
                        return gt.apply(Ut ? dt.call(jt(this)) : jt(this), arguments);
                    },
                        Dt = { copyWithin: function copyWithin(t, n) {
                            return U.call(jt(this), t, n, arguments.length > 2 ? arguments[2] : void 0);
                        }, every: function every(t) {
                            return rt(jt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                        }, fill: function fill(t) {
                            return C.apply(jt(this), arguments);
                        }, filter: function filter(t) {
                            return kt(this, tt(jt(this), t, arguments.length > 1 ? arguments[1] : void 0));
                        }, find: function find(t) {
                            return et(jt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                        }, findIndex: function findIndex(t) {
                            return it(jt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                        }, forEach: function forEach(t) {
                            Q(jt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                        }, indexOf: function indexOf(t) {
                            return ut(jt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                        }, includes: function includes(t) {
                            return ot(jt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                        }, join: function join(t) {
                            return vt.apply(jt(this), arguments);
                        }, lastIndexOf: function lastIndexOf(t) {
                            return st.apply(jt(this), arguments);
                        }, map: function map(t) {
                            return Ft(jt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                        }, reduce: function reduce(t) {
                            return lt.apply(jt(this), arguments);
                        }, reduceRight: function reduceRight(t) {
                            return ht.apply(jt(this), arguments);
                        }, reverse: function reverse() {
                            for (var t, n = this, r = jt(n).length, e = Math.floor(r / 2), i = 0; i < e;) {
                                t = n[i], n[i++] = n[--r], n[r] = t;
                            }return n;
                        }, some: function some(t) {
                            return nt(jt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                        }, sort: function sort(t) {
                            return pt.call(jt(this), t);
                        }, subarray: function subarray(t, n) {
                            var r = jt(this),
                                e = r.length,
                                i = y(t, e);return new (N(r, r[wt]))(r.buffer, r.byteOffset + i * r.BYTES_PER_ELEMENT, d((void 0 === n ? e : y(n, e)) - i));
                        } },
                        Wt = function slice(t, n) {
                        return kt(this, dt.call(jt(this), t, n));
                    },
                        Bt = function set(t) {
                        jt(this);var n = It(arguments[1], 1),
                            r = this.length,
                            e = S(t),
                            i = d(e.length),
                            o = 0;if (i + n > r) throw V(Ot);for (; o < i;) {
                            this[n + o] = e[o++];
                        }
                    },
                        Vt = { entries: function entries() {
                            return at.call(jt(this));
                        }, keys: function keys() {
                            return ft.call(jt(this));
                        }, values: function values() {
                            return ct.call(jt(this));
                        } },
                        zt = function zt(t, n) {
                        return w(t) && t[_t] && "symbol" != (typeof n === 'undefined' ? 'undefined' : _typeof(n)) && n in t && String(+n) == String(n);
                    },
                        Kt = function getOwnPropertyDescriptor(t, n) {
                        return zt(t, n = g(n, !0)) ? l(2, t[n]) : B(t, n);
                    },
                        Jt = function defineProperty(t, n, r) {
                        return !(zt(t, n = g(n, !0)) && w(r) && b(r, "value")) || b(r, "get") || b(r, "set") || r.configurable || b(r, "writable") && !r.writable || b(r, "enumerable") && !r.enumerable ? W(t, n, r) : (t[n] = r.value, t);
                    };St || (D.f = Kt, G.f = Jt), u(u.S + u.F * !St, "Object", { getOwnPropertyDescriptor: Kt, defineProperty: Jt }), o(function () {
                        yt.call({});
                    }) && (yt = gt = function toString() {
                        return vt.call(this);
                    });var Yt = v({}, Dt);v(Yt, Vt), h(Yt, bt, Vt.values), v(Yt, { slice: Wt, set: Bt, constructor: function constructor() {}, toString: yt, toLocaleString: Gt }), Tt(Yt, "buffer", "b"), Tt(Yt, "byteOffset", "o"), Tt(Yt, "byteLength", "l"), Tt(Yt, "length", "e"), W(Yt, xt, { get: function get() {
                            return this[_t];
                        } }), n.exports = function (t, n, r, f) {
                        f = !!f;var a = t + (f ? "Clamped" : "") + "Array",
                            l = "Uint8Array" != a,
                            v = "get" + t,
                            p = "set" + t,
                            y = i[a],
                            g = y || {},
                            b = y && O(y),
                            x = !y || !c.ABV,
                            S = {},
                            _ = y && y[X],
                            P = function P(t, r) {
                            var e = t._d;return e.v[v](r * n + e.o, Pt);
                        },
                            M = function M(t, r, e) {
                            var i = t._d;f && (e = (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 : 255 & e), i.v[p](r * n + i.o, e, Pt);
                        },
                            A = function A(t, n) {
                            W(t, n, { get: function get() {
                                    return P(this, n);
                                }, set: function set(t) {
                                    return M(this, n, t);
                                }, enumerable: !0 });
                        };x ? (y = r(function (t, r, e, i) {
                            s(t, y, a, "_d");var o,
                                u,
                                c,
                                f,
                                l = 0,
                                v = 0;if (w(r)) {
                                if (!(r instanceof H || (f = m(r)) == J || f == Y)) return _t in r ? Rt(y, r) : Lt.call(y, r);o = r, v = It(e, n);var p = r.byteLength;if (void 0 === i) {
                                    if (p % n) throw V(Ot);if (u = p - v, u < 0) throw V(Ot);
                                } else if (u = d(i) * n, u + v > p) throw V(Ot);c = u / n;
                            } else c = At(r, !0), u = c * n, o = new H(u);for (h(t, "_d", { b: o, o: v, l: u, e: c, v: new Z(o) }); l < c;) {
                                A(t, l++);
                            }
                        }), _ = y[X] = E(Yt), h(_, "constructor", y)) : T(function (t) {
                            new y(null), new y(t);
                        }, !0) || (y = r(function (t, r, e, i) {
                            s(t, y, a);var o;return w(r) ? r instanceof H || (o = m(r)) == J || o == Y ? void 0 !== i ? new g(r, It(e, n), i) : void 0 !== e ? new g(r, It(e, n)) : new g(r) : _t in r ? Rt(y, r) : Lt.call(y, r) : new g(At(r, l));
                        }), Q(b !== Function.prototype ? F(g).concat(F(b)) : F(g), function (t) {
                            t in y || h(y, t, g[t]);
                        }), y[X] = _, e || (_.constructor = y));var I = _[bt],
                            j = !!I && ("values" == I.name || void 0 == I.name),
                            N = Vt.values;h(y, mt, !0), h(_, _t, a), h(_, Et, !0), h(_, wt, y), (f ? new y(1)[xt] == a : xt in _) || W(_, xt, { get: function get() {
                                return a;
                            } }), S[a] = y, u(u.G + u.W + u.F * (y != g), S), u(u.S, a, { BYTES_PER_ELEMENT: n, from: Lt, of: Ct }), q in _ || h(_, q, n), u(u.P, a, Dt), L(a), u(u.P + u.F * Mt, a, { set: Bt }), u(u.P + u.F * !j, a, Vt), u(u.P + u.F * (_.toString != yt), a, { toString: yt }), u(u.P + u.F * o(function () {
                            new y(1).slice();
                        }), a, { slice: Wt }), u(u.P + u.F * (o(function () {
                            return [1, 2].toLocaleString() != new y([1, 2]).toLocaleString();
                        }) || !o(function () {
                            _.toLocaleString.call([1, 2]);
                        })), a, { toLocaleString: Gt }), R[a] = j ? I : N, e || j || h(_, bt, N);
                    };
                } else n.exports = function () {};
            }, { 105: 105, 106: 106, 108: 108, 109: 109, 11: 11, 110: 110, 112: 112, 113: 113, 114: 114, 117: 117, 118: 118, 12: 12, 130: 130, 17: 17, 25: 25, 28: 28, 32: 32, 34: 34, 38: 38, 39: 39, 40: 40, 46: 46, 49: 49, 54: 54, 56: 56, 58: 58, 6: 6, 66: 66, 67: 67, 70: 70, 72: 72, 74: 74, 8: 8, 85: 85, 86: 86, 89: 89, 9: 9, 91: 91, 95: 95 }], 112: [function (t, n, r) {
                "use strict";
                var e = t(38),
                    i = t(28),
                    o = t(58),
                    u = t(113),
                    c = t(40),
                    f = t(86),
                    a = t(34),
                    s = t(6),
                    l = t(106),
                    h = t(108),
                    v = t(72).f,
                    p = t(67).f,
                    d = t(9),
                    y = t(92),
                    g = "ArrayBuffer",
                    b = "DataView",
                    x = "prototype",
                    m = "Wrong length!",
                    w = "Wrong index!",
                    S = e[g],
                    _ = e[b],
                    E = e.Math,
                    O = e.RangeError,
                    F = e.Infinity,
                    P = S,
                    M = E.abs,
                    A = E.pow,
                    I = E.floor,
                    j = E.log,
                    N = E.LN2,
                    k = "buffer",
                    R = "byteLength",
                    T = "byteOffset",
                    L = i ? "_b" : k,
                    C = i ? "_l" : R,
                    U = i ? "_o" : T,
                    G = function G(t, n, r) {
                    var e,
                        i,
                        o,
                        u = Array(r),
                        c = 8 * r - n - 1,
                        f = (1 << c) - 1,
                        a = f >> 1,
                        s = 23 === n ? A(2, -24) - A(2, -77) : 0,
                        l = 0,
                        h = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;for (t = M(t), t != t || t === F ? (i = t != t ? 1 : 0, e = f) : (e = I(j(t) / N), t * (o = A(2, -e)) < 1 && (e--, o *= 2), t += e + a >= 1 ? s / o : s * A(2, 1 - a), t * o >= 2 && (e++, o /= 2), e + a >= f ? (i = 0, e = f) : e + a >= 1 ? (i = (t * o - 1) * A(2, n), e += a) : (i = t * A(2, a - 1) * A(2, n), e = 0)); n >= 8; u[l++] = 255 & i, i /= 256, n -= 8) {}for (e = e << n | i, c += n; c > 0; u[l++] = 255 & e, e /= 256, c -= 8) {}return u[--l] |= 128 * h, u;
                },
                    D = function D(t, n, r) {
                    var e,
                        i = 8 * r - n - 1,
                        o = (1 << i) - 1,
                        u = o >> 1,
                        c = i - 7,
                        f = r - 1,
                        a = t[f--],
                        s = 127 & a;for (a >>= 7; c > 0; s = 256 * s + t[f], f--, c -= 8) {}for (e = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; e = 256 * e + t[f], f--, c -= 8) {}if (0 === s) s = 1 - u;else {
                        if (s === o) return e ? NaN : a ? -F : F;e += A(2, n), s -= u;
                    }return (a ? -1 : 1) * e * A(2, s - n);
                },
                    W = function W(t) {
                    return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0];
                },
                    B = function B(t) {
                    return [255 & t];
                },
                    V = function V(t) {
                    return [255 & t, t >> 8 & 255];
                },
                    z = function z(t) {
                    return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255];
                },
                    K = function K(t) {
                    return G(t, 52, 8);
                },
                    J = function J(t) {
                    return G(t, 23, 4);
                },
                    Y = function Y(t, n, r) {
                    p(t[x], n, { get: function get() {
                            return this[r];
                        } });
                },
                    q = function q(t, n, r, e) {
                    var i = +r,
                        o = l(i);if (i != o || o < 0 || o + n > t[C]) throw O(w);var u = t[L]._b,
                        c = o + t[U],
                        f = u.slice(c, c + n);return e ? f : f.reverse();
                },
                    X = function X(t, n, r, e, i, o) {
                    var u = +r,
                        c = l(u);if (u != c || c < 0 || c + n > t[C]) throw O(w);for (var f = t[L]._b, a = c + t[U], s = e(+i), h = 0; h < n; h++) {
                        f[a + h] = s[o ? h : n - h - 1];
                    }
                },
                    $ = function $(t, n) {
                    s(t, S, g);var r = +n,
                        e = h(r);if (r != e) throw O(m);return e;
                };if (u.ABV) {
                    if (!a(function () {
                        new S();
                    }) || !a(function () {
                        new S(.5);
                    })) {
                        S = function ArrayBuffer(t) {
                            return new P($(this, t));
                        };for (var H, Z = S[x] = P[x], Q = v(P), tt = 0; Q.length > tt;) {
                            (H = Q[tt++]) in S || c(S, H, P[H]);
                        }o || (Z.constructor = S);
                    }var nt = new _(new S(2)),
                        rt = _[x].setInt8;nt.setInt8(0, 2147483648), nt.setInt8(1, 2147483649), !nt.getInt8(0) && nt.getInt8(1) || f(_[x], { setInt8: function setInt8(t, n) {
                            rt.call(this, t, n << 24 >> 24);
                        }, setUint8: function setUint8(t, n) {
                            rt.call(this, t, n << 24 >> 24);
                        } }, !0);
                } else S = function ArrayBuffer(t) {
                    var n = $(this, t);this._b = d.call(Array(n), 0), this[C] = n;
                }, _ = function DataView(t, n, r) {
                    s(this, _, b), s(t, S, b);var e = t[C],
                        i = l(n);if (i < 0 || i > e) throw O("Wrong offset!");if (r = void 0 === r ? e - i : h(r), i + r > e) throw O(m);this[L] = t, this[U] = i, this[C] = r;
                }, i && (Y(S, R, "_l"), Y(_, k, "_b"), Y(_, R, "_l"), Y(_, T, "_o")), f(_[x], { getInt8: function getInt8(t) {
                        return q(this, 1, t)[0] << 24 >> 24;
                    }, getUint8: function getUint8(t) {
                        return q(this, 1, t)[0];
                    }, getInt16: function getInt16(t) {
                        var n = q(this, 2, t, arguments[1]);return (n[1] << 8 | n[0]) << 16 >> 16;
                    }, getUint16: function getUint16(t) {
                        var n = q(this, 2, t, arguments[1]);return n[1] << 8 | n[0];
                    }, getInt32: function getInt32(t) {
                        return W(q(this, 4, t, arguments[1]));
                    }, getUint32: function getUint32(t) {
                        return W(q(this, 4, t, arguments[1])) >>> 0;
                    }, getFloat32: function getFloat32(t) {
                        return D(q(this, 4, t, arguments[1]), 23, 4);
                    }, getFloat64: function getFloat64(t) {
                        return D(q(this, 8, t, arguments[1]), 52, 8);
                    }, setInt8: function setInt8(t, n) {
                        X(this, 1, t, B, n);
                    }, setUint8: function setUint8(t, n) {
                        X(this, 1, t, B, n);
                    }, setInt16: function setInt16(t, n) {
                        X(this, 2, t, V, n, arguments[2]);
                    }, setUint16: function setUint16(t, n) {
                        X(this, 2, t, V, n, arguments[2]);
                    }, setInt32: function setInt32(t, n) {
                        X(this, 4, t, z, n, arguments[2]);
                    }, setUint32: function setUint32(t, n) {
                        X(this, 4, t, z, n, arguments[2]);
                    }, setFloat32: function setFloat32(t, n) {
                        X(this, 4, t, J, n, arguments[2]);
                    }, setFloat64: function setFloat64(t, n) {
                        X(this, 8, t, K, n, arguments[2]);
                    } });y(S, g), y(_, b), c(_[x], u.VIEW, !0), r[g] = S, r[b] = _;
            }, { 106: 106, 108: 108, 113: 113, 28: 28, 34: 34, 38: 38, 40: 40, 58: 58, 6: 6, 67: 67, 72: 72, 86: 86, 9: 9, 92: 92 }], 113: [function (t, n, r) {
                for (var e, i = t(38), o = t(40), u = t(114), c = u("typed_array"), f = u("view"), a = !(!i.ArrayBuffer || !i.DataView), s = a, l = 0, h = 9, v = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); l < h;) {
                    (e = i[v[l++]]) ? (o(e.prototype, c, !0), o(e.prototype, f, !0)) : s = !1;
                }n.exports = { ABV: a, CONSTR: s, TYPED: c, VIEW: f };
            }, { 114: 114, 38: 38, 40: 40 }], 114: [function (t, n, r) {
                var e = 0,
                    i = Math.random();n.exports = function (t) {
                    return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++e + i).toString(36));
                };
            }, {}], 115: [function (t, n, r) {
                var e = t(38),
                    i = t(23),
                    o = t(58),
                    u = t(116),
                    c = t(67).f;n.exports = function (t) {
                    var n = i.Symbol || (i.Symbol = o ? {} : e.Symbol || {});"_" == t.charAt(0) || t in n || c(n, t, { value: u.f(t) });
                };
            }, { 116: 116, 23: 23, 38: 38, 58: 58, 67: 67 }], 116: [function (t, n, r) {
                r.f = t(117);
            }, { 117: 117 }], 117: [function (t, n, r) {
                var e = t(94)("wks"),
                    i = t(114),
                    o = t(38).Symbol,
                    u = "function" == typeof o,
                    c = n.exports = function (t) {
                    return e[t] || (e[t] = u && o[t] || (u ? o : i)("Symbol." + t));
                };c.store = e;
            }, { 114: 114, 38: 38, 94: 94 }], 118: [function (t, n, r) {
                var e = t(17),
                    i = t(117)("iterator"),
                    o = t(56);n.exports = t(23).getIteratorMethod = function (t) {
                    if (void 0 != t) return t[i] || t["@@iterator"] || o[e(t)];
                };
            }, { 117: 117, 17: 17, 23: 23, 56: 56 }], 119: [function (t, n, r) {
                var e = t(32),
                    i = t(88)(/[\\^$*+?.()|[\]{}]/g, "\\$&");e(e.S, "RegExp", { escape: function escape(t) {
                        return i(t);
                    } });
            }, { 32: 32, 88: 88 }], 120: [function (t, n, r) {
                var e = t(32);e(e.P, "Array", { copyWithin: t(8) }), t(5)("copyWithin");
            }, { 32: 32, 5: 5, 8: 8 }], 121: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(12)(4);e(e.P + e.F * !t(96)([].every, !0), "Array", { every: function every(t) {
                        return i(this, t, arguments[1]);
                    } });
            }, { 12: 12, 32: 32, 96: 96 }], 122: [function (t, n, r) {
                var e = t(32);e(e.P, "Array", { fill: t(9) }), t(5)("fill");
            }, { 32: 32, 5: 5, 9: 9 }], 123: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(12)(2);e(e.P + e.F * !t(96)([].filter, !0), "Array", { filter: function filter(t) {
                        return i(this, t, arguments[1]);
                    } });
            }, { 12: 12, 32: 32, 96: 96 }], 124: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(12)(6),
                    o = "findIndex",
                    u = !0;o in [] && Array(1)[o](function () {
                    u = !1;
                }), e(e.P + e.F * u, "Array", { findIndex: function findIndex(t) {
                        return i(this, t, arguments.length > 1 ? arguments[1] : void 0);
                    } }), t(5)(o);
            }, { 12: 12, 32: 32, 5: 5 }], 125: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(12)(5),
                    o = "find",
                    u = !0;o in [] && Array(1)[o](function () {
                    u = !1;
                }), e(e.P + e.F * u, "Array", { find: function find(t) {
                        return i(this, t, arguments.length > 1 ? arguments[1] : void 0);
                    } }), t(5)(o);
            }, { 12: 12, 32: 32, 5: 5 }], 126: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(12)(0),
                    o = t(96)([].forEach, !0);e(e.P + e.F * !o, "Array", { forEach: function forEach(t) {
                        return i(this, t, arguments[1]);
                    } });
            }, { 12: 12, 32: 32, 96: 96 }], 127: [function (t, n, r) {
                "use strict";
                var e = t(25),
                    i = t(32),
                    o = t(109),
                    u = t(51),
                    c = t(46),
                    f = t(108),
                    a = t(24),
                    s = t(118);i(i.S + i.F * !t(54)(function (t) {
                    Array.from(t);
                }), "Array", { from: function from(t) {
                        var n,
                            r,
                            i,
                            l,
                            h = o(t),
                            v = "function" == typeof this ? this : Array,
                            p = arguments.length,
                            d = p > 1 ? arguments[1] : void 0,
                            y = void 0 !== d,
                            g = 0,
                            b = s(h);if (y && (d = e(d, p > 2 ? arguments[2] : void 0, 2)), void 0 == b || v == Array && c(b)) for (n = f(h.length), r = new v(n); n > g; g++) {
                            a(r, g, y ? d(h[g], g) : h[g]);
                        } else for (l = b.call(h), r = new v(); !(i = l.next()).done; g++) {
                            a(r, g, y ? u(l, d, [i.value, g], !0) : i.value);
                        }return r.length = g, r;
                    } });
            }, { 108: 108, 109: 109, 118: 118, 24: 24, 25: 25, 32: 32, 46: 46, 51: 51, 54: 54 }], 128: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(11)(!1),
                    o = [].indexOf,
                    u = !!o && 1 / [1].indexOf(1, -0) < 0;e(e.P + e.F * (u || !t(96)(o)), "Array", { indexOf: function indexOf(t) {
                        return u ? o.apply(this, arguments) || 0 : i(this, t, arguments[1]);
                    } });
            }, { 11: 11, 32: 32, 96: 96 }], 129: [function (t, n, r) {
                var e = t(32);e(e.S, "Array", { isArray: t(47) });
            }, { 32: 32, 47: 47 }], 130: [function (t, n, r) {
                "use strict";
                var e = t(5),
                    i = t(55),
                    o = t(56),
                    u = t(107);n.exports = t(53)(Array, "Array", function (t, n) {
                    this._t = u(t), this._i = 0, this._k = n;
                }, function () {
                    var t = this._t,
                        n = this._k,
                        r = this._i++;return !t || r >= t.length ? (this._t = void 0, i(1)) : "keys" == n ? i(0, r) : "values" == n ? i(0, t[r]) : i(0, [r, t[r]]);
                }, "values"), o.Arguments = o.Array, e("keys"), e("values"), e("entries");
            }, { 107: 107, 5: 5, 53: 53, 55: 55, 56: 56 }], 131: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(107),
                    o = [].join;e(e.P + e.F * (t(45) != Object || !t(96)(o)), "Array", { join: function join(t) {
                        return o.call(i(this), void 0 === t ? "," : t);
                    } });
            }, { 107: 107, 32: 32, 45: 45, 96: 96 }], 132: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(107),
                    o = t(106),
                    u = t(108),
                    c = [].lastIndexOf,
                    f = !!c && 1 / [1].lastIndexOf(1, -0) < 0;e(e.P + e.F * (f || !t(96)(c)), "Array", { lastIndexOf: function lastIndexOf(t) {
                        if (f) return c.apply(this, arguments) || 0;var n = i(this),
                            r = u(n.length),
                            e = r - 1;for (arguments.length > 1 && (e = Math.min(e, o(arguments[1]))), e < 0 && (e = r + e); e >= 0; e--) {
                            if (e in n && n[e] === t) return e || 0;
                        }return -1;
                    } });
            }, { 106: 106, 107: 107, 108: 108, 32: 32, 96: 96 }], 133: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(12)(1);e(e.P + e.F * !t(96)([].map, !0), "Array", { map: function map(t) {
                        return i(this, t, arguments[1]);
                    } });
            }, { 12: 12, 32: 32, 96: 96 }], 134: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(24);e(e.S + e.F * t(34)(function () {
                    function F() {}return !(Array.of.call(F) instanceof F);
                }), "Array", { of: function of() {
                        for (var t = 0, n = arguments.length, r = new ("function" == typeof this ? this : Array)(n); n > t;) {
                            i(r, t, arguments[t++]);
                        }return r.length = n, r;
                    } });
            }, { 24: 24, 32: 32, 34: 34 }], 135: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(13);e(e.P + e.F * !t(96)([].reduceRight, !0), "Array", { reduceRight: function reduceRight(t) {
                        return i(this, t, arguments.length, arguments[1], !0);
                    } });
            }, { 13: 13, 32: 32, 96: 96 }], 136: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(13);e(e.P + e.F * !t(96)([].reduce, !0), "Array", { reduce: function reduce(t) {
                        return i(this, t, arguments.length, arguments[1], !1);
                    } });
            }, { 13: 13, 32: 32, 96: 96 }], 137: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(41),
                    o = t(18),
                    u = t(105),
                    c = t(108),
                    f = [].slice;e(e.P + e.F * t(34)(function () {
                    i && f.call(i);
                }), "Array", { slice: function slice(t, n) {
                        var r = c(this.length),
                            e = o(this);if (n = void 0 === n ? r : n, "Array" == e) return f.call(this, t, n);for (var i = u(t, r), a = u(n, r), s = c(a - i), l = Array(s), h = 0; h < s; h++) {
                            l[h] = "String" == e ? this.charAt(i + h) : this[i + h];
                        }return l;
                    } });
            }, { 105: 105, 108: 108, 18: 18, 32: 32, 34: 34, 41: 41 }], 138: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(12)(3);e(e.P + e.F * !t(96)([].some, !0), "Array", { some: function some(t) {
                        return i(this, t, arguments[1]);
                    } });
            }, { 12: 12, 32: 32, 96: 96 }], 139: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(3),
                    o = t(109),
                    u = t(34),
                    c = [].sort,
                    f = [1, 2, 3];e(e.P + e.F * (u(function () {
                    f.sort(void 0);
                }) || !u(function () {
                    f.sort(null);
                }) || !t(96)(c)), "Array", { sort: function sort(t) {
                        return void 0 === t ? c.call(o(this)) : c.call(o(this), i(t));
                    } });
            }, { 109: 109, 3: 3, 32: 32, 34: 34, 96: 96 }], 140: [function (t, n, r) {
                t(91)("Array");
            }, { 91: 91 }], 141: [function (t, n, r) {
                var e = t(32);e(e.S, "Date", { now: function now() {
                        return new Date().getTime();
                    } });
            }, { 32: 32 }], 142: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(34),
                    o = Date.prototype.getTime,
                    u = function u(t) {
                    return t > 9 ? t : "0" + t;
                };e(e.P + e.F * (i(function () {
                    return "0385-07-25T07:06:39.999Z" != new Date(-5e13 - 1).toISOString();
                }) || !i(function () {
                    new Date(NaN).toISOString();
                })), "Date", { toISOString: function toISOString() {
                        if (!isFinite(o.call(this))) throw RangeError("Invalid time value");var t = this,
                            n = t.getUTCFullYear(),
                            r = t.getUTCMilliseconds(),
                            e = n < 0 ? "-" : n > 9999 ? "+" : "";return e + ("00000" + Math.abs(n)).slice(e ? -6 : -4) + "-" + u(t.getUTCMonth() + 1) + "-" + u(t.getUTCDate()) + "T" + u(t.getUTCHours()) + ":" + u(t.getUTCMinutes()) + ":" + u(t.getUTCSeconds()) + "." + (r > 99 ? r : "0" + u(r)) + "Z";
                    } });
            }, { 32: 32, 34: 34 }], 143: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(109),
                    o = t(110);e(e.P + e.F * t(34)(function () {
                    return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({ toISOString: function toISOString() {
                            return 1;
                        } });
                }), "Date", { toJSON: function toJSON(t) {
                        var n = i(this),
                            r = o(n);return "number" != typeof r || isFinite(r) ? n.toISOString() : null;
                    } });
            }, { 109: 109, 110: 110, 32: 32, 34: 34 }], 144: [function (t, n, r) {
                var e = t(117)("toPrimitive"),
                    i = Date.prototype;e in i || t(40)(i, e, t(26));
            }, { 117: 117, 26: 26, 40: 40 }], 145: [function (t, n, r) {
                var e = Date.prototype,
                    i = "Invalid Date",
                    o = "toString",
                    u = e[o],
                    c = e.getTime;new Date(NaN) + "" != i && t(87)(e, o, function toString() {
                    var t = c.call(this);return t === t ? u.call(this) : i;
                });
            }, { 87: 87 }], 146: [function (t, n, r) {
                var e = t(32);e(e.P, "Function", { bind: t(16) });
            }, { 16: 16, 32: 32 }], 147: [function (t, n, r) {
                "use strict";
                var e = t(49),
                    i = t(74),
                    o = t(117)("hasInstance"),
                    u = Function.prototype;o in u || t(67).f(u, o, { value: function value(t) {
                        if ("function" != typeof this || !e(t)) return !1;if (!e(this.prototype)) return t instanceof this;for (; t = i(t);) {
                            if (this.prototype === t) return !0;
                        }return !1;
                    } });
            }, { 117: 117, 49: 49, 67: 67, 74: 74 }], 148: [function (t, n, r) {
                var e = t(67).f,
                    i = t(85),
                    o = t(39),
                    u = Function.prototype,
                    c = /^\s*function ([^ (]*)/,
                    f = "name",
                    a = Object.isExtensible || function () {
                    return !0;
                };f in u || t(28) && e(u, f, { configurable: !0, get: function get() {
                        try {
                            var t = this,
                                n = ("" + t).match(c)[1];return o(t, f) || !a(t) || e(t, f, i(5, n)), n;
                        } catch (t) {
                            return "";
                        }
                    } });
            }, { 28: 28, 39: 39, 67: 67, 85: 85 }], 149: [function (t, n, r) {
                "use strict";
                var e = t(19);n.exports = t(22)("Map", function (t) {
                    return function Map() {
                        return t(this, arguments.length > 0 ? arguments[0] : void 0);
                    };
                }, { get: function get(t) {
                        var n = e.getEntry(this, t);return n && n.v;
                    }, set: function set(t, n) {
                        return e.def(this, 0 === t ? 0 : t, n);
                    } }, e, !0);
            }, { 19: 19, 22: 22 }], 150: [function (t, n, r) {
                var e = t(32),
                    i = t(60),
                    o = Math.sqrt,
                    u = Math.acosh;e(e.S + e.F * !(u && 710 == Math.floor(u(Number.MAX_VALUE)) && u(1 / 0) == 1 / 0), "Math", { acosh: function acosh(t) {
                        return (t = +t) < 1 ? NaN : t > 94906265.62425156 ? Math.log(t) + Math.LN2 : i(t - 1 + o(t - 1) * o(t + 1));
                    } });
            }, { 32: 32, 60: 60 }], 151: [function (t, n, r) {
                function asinh(t) {
                    return isFinite(t = +t) && 0 != t ? t < 0 ? -asinh(-t) : Math.log(t + Math.sqrt(t * t + 1)) : t;
                }var e = t(32),
                    i = Math.asinh;e(e.S + e.F * !(i && 1 / i(0) > 0), "Math", { asinh: asinh });
            }, { 32: 32 }], 152: [function (t, n, r) {
                var e = t(32),
                    i = Math.atanh;e(e.S + e.F * !(i && 1 / i(-0) < 0), "Math", { atanh: function atanh(t) {
                        return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2;
                    } });
            }, { 32: 32 }], 153: [function (t, n, r) {
                var e = t(32),
                    i = t(61);e(e.S, "Math", { cbrt: function cbrt(t) {
                        return i(t = +t) * Math.pow(Math.abs(t), 1 / 3);
                    } });
            }, { 32: 32, 61: 61 }], 154: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { clz32: function clz32(t) {
                        return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) * Math.LOG2E) : 32;
                    } });
            }, { 32: 32 }], 155: [function (t, n, r) {
                var e = t(32),
                    i = Math.exp;e(e.S, "Math", { cosh: function cosh(t) {
                        return (i(t = +t) + i(-t)) / 2;
                    } });
            }, { 32: 32 }], 156: [function (t, n, r) {
                var e = t(32),
                    i = t(59);e(e.S + e.F * (i != Math.expm1), "Math", { expm1: i });
            }, { 32: 32, 59: 59 }], 157: [function (t, n, r) {
                var e = t(32),
                    i = t(61),
                    o = Math.pow,
                    u = o(2, -52),
                    c = o(2, -23),
                    f = o(2, 127) * (2 - c),
                    a = o(2, -126),
                    s = function s(t) {
                    return t + 1 / u - 1 / u;
                };e(e.S, "Math", { fround: function fround(t) {
                        var n,
                            r,
                            e = Math.abs(t),
                            o = i(t);return e < a ? o * s(e / a / c) * a * c : (n = (1 + c / u) * e, r = n - (n - e), r > f || r != r ? o * (1 / 0) : o * r);
                    } });
            }, { 32: 32, 61: 61 }], 158: [function (t, n, r) {
                var e = t(32),
                    i = Math.abs;e(e.S, "Math", { hypot: function hypot(t, n) {
                        for (var r, e, o = 0, u = 0, c = arguments.length, f = 0; u < c;) {
                            r = i(arguments[u++]), f < r ? (e = f / r, o = o * e * e + 1, f = r) : r > 0 ? (e = r / f, o += e * e) : o += r;
                        }return f === 1 / 0 ? 1 / 0 : f * Math.sqrt(o);
                    } });
            }, { 32: 32 }], 159: [function (t, n, r) {
                var e = t(32),
                    i = Math.imul;e(e.S + e.F * t(34)(function () {
                    return i(4294967295, 5) != -5 || 2 != i.length;
                }), "Math", { imul: function imul(t, n) {
                        var r = 65535,
                            e = +t,
                            i = +n,
                            o = r & e,
                            u = r & i;return 0 | o * u + ((r & e >>> 16) * u + o * (r & i >>> 16) << 16 >>> 0);
                    } });
            }, { 32: 32, 34: 34 }], 160: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { log10: function log10(t) {
                        return Math.log(t) / Math.LN10;
                    } });
            }, { 32: 32 }], 161: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { log1p: t(60) });
            }, { 32: 32, 60: 60 }], 162: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { log2: function log2(t) {
                        return Math.log(t) / Math.LN2;
                    } });
            }, { 32: 32 }], 163: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { sign: t(61) });
            }, { 32: 32, 61: 61 }], 164: [function (t, n, r) {
                var e = t(32),
                    i = t(59),
                    o = Math.exp;e(e.S + e.F * t(34)(function () {
                    return !Math.sinh(-2e-17) != -2e-17;
                }), "Math", { sinh: function sinh(t) {
                        return Math.abs(t = +t) < 1 ? (i(t) - i(-t)) / 2 : (o(t - 1) - o(-t - 1)) * (Math.E / 2);
                    } });
            }, { 32: 32, 34: 34, 59: 59 }], 165: [function (t, n, r) {
                var e = t(32),
                    i = t(59),
                    o = Math.exp;e(e.S, "Math", { tanh: function tanh(t) {
                        var n = i(t = +t),
                            r = i(-t);return n == 1 / 0 ? 1 : r == 1 / 0 ? -1 : (n - r) / (o(t) + o(-t));
                    } });
            }, { 32: 32, 59: 59 }], 166: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { trunc: function trunc(t) {
                        return (t > 0 ? Math.floor : Math.ceil)(t);
                    } });
            }, { 32: 32 }], 167: [function (t, n, r) {
                "use strict";
                var e = t(38),
                    i = t(39),
                    o = t(18),
                    u = t(43),
                    c = t(110),
                    f = t(34),
                    a = t(72).f,
                    s = t(70).f,
                    l = t(67).f,
                    h = t(102).trim,
                    v = "Number",
                    p = e[v],
                    d = p,
                    y = p.prototype,
                    g = o(t(66)(y)) == v,
                    b = "trim" in String.prototype,
                    x = function x(t) {
                    var n = c(t, !1);if ("string" == typeof n && n.length > 2) {
                        n = b ? n.trim() : h(n, 3);var r,
                            e,
                            i,
                            o = n.charCodeAt(0);if (43 === o || 45 === o) {
                            if (r = n.charCodeAt(2), 88 === r || 120 === r) return NaN;
                        } else if (48 === o) {
                            switch (n.charCodeAt(1)) {case 66:case 98:
                                    e = 2, i = 49;break;case 79:case 111:
                                    e = 8, i = 55;break;default:
                                    return +n;}for (var u, f = n.slice(2), a = 0, s = f.length; a < s; a++) {
                                if (u = f.charCodeAt(a), u < 48 || u > i) return NaN;
                            }return parseInt(f, e);
                        }
                    }return +n;
                };if (!p(" 0o1") || !p("0b1") || p("+0x1")) {
                    p = function Number(t) {
                        var n = arguments.length < 1 ? 0 : t,
                            r = this;return r instanceof p && (g ? f(function () {
                            y.valueOf.call(r);
                        }) : o(r) != v) ? u(new d(x(n)), r, p) : x(n);
                    };for (var m, w = t(28) ? a(d) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), S = 0; w.length > S; S++) {
                        i(d, m = w[S]) && !i(p, m) && l(p, m, s(d, m));
                    }p.prototype = y, y.constructor = p, t(87)(e, v, p);
                }
            }, { 102: 102, 110: 110, 18: 18, 28: 28, 34: 34, 38: 38, 39: 39, 43: 43, 66: 66, 67: 67, 70: 70, 72: 72, 87: 87 }], 168: [function (t, n, r) {
                var e = t(32);e(e.S, "Number", { EPSILON: Math.pow(2, -52) });
            }, { 32: 32 }], 169: [function (t, n, r) {
                var e = t(32),
                    i = t(38).isFinite;e(e.S, "Number", { isFinite: function isFinite(t) {
                        return "number" == typeof t && i(t);
                    } });
            }, { 32: 32, 38: 38 }], 170: [function (t, n, r) {
                var e = t(32);e(e.S, "Number", { isInteger: t(48) });
            }, { 32: 32, 48: 48 }], 171: [function (t, n, r) {
                var e = t(32);e(e.S, "Number", { isNaN: function isNaN(t) {
                        return t != t;
                    } });
            }, { 32: 32 }], 172: [function (t, n, r) {
                var e = t(32),
                    i = t(48),
                    o = Math.abs;e(e.S, "Number", { isSafeInteger: function isSafeInteger(t) {
                        return i(t) && o(t) <= 9007199254740991;
                    } });
            }, { 32: 32, 48: 48 }], 173: [function (t, n, r) {
                var e = t(32);e(e.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 });
            }, { 32: 32 }], 174: [function (t, n, r) {
                var e = t(32);e(e.S, "Number", { MIN_SAFE_INTEGER: -9007199254740991 });
            }, { 32: 32 }], 175: [function (t, n, r) {
                var e = t(32),
                    i = t(81);e(e.S + e.F * (Number.parseFloat != i), "Number", { parseFloat: i });
            }, { 32: 32, 81: 81 }], 176: [function (t, n, r) {
                var e = t(32),
                    i = t(82);e(e.S + e.F * (Number.parseInt != i), "Number", { parseInt: i });
            }, { 32: 32, 82: 82 }], 177: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(106),
                    o = t(4),
                    u = t(101),
                    c = 1..toFixed,
                    f = Math.floor,
                    a = [0, 0, 0, 0, 0, 0],
                    s = "Number.toFixed: incorrect invocation!",
                    l = "0",
                    h = function h(t, n) {
                    for (var r = -1, e = n; ++r < 6;) {
                        e += t * a[r], a[r] = e % 1e7, e = f(e / 1e7);
                    }
                },
                    v = function v(t) {
                    for (var n = 6, r = 0; --n >= 0;) {
                        r += a[n], a[n] = f(r / t), r = r % t * 1e7;
                    }
                },
                    p = function p() {
                    for (var t = 6, n = ""; --t >= 0;) {
                        if ("" !== n || 0 === t || 0 !== a[t]) {
                            var r = String(a[t]);n = "" === n ? r : n + u.call(l, 7 - r.length) + r;
                        }
                    }return n;
                },
                    d = function d(t, n, r) {
                    return 0 === n ? r : n % 2 === 1 ? d(t, n - 1, r * t) : d(t * t, n / 2, r);
                },
                    y = function y(t) {
                    for (var n = 0, r = t; r >= 4096;) {
                        n += 12, r /= 4096;
                    }for (; r >= 2;) {
                        n += 1, r /= 2;
                    }return n;
                };e(e.P + e.F * (!!c && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== 0xde0b6b3a7640080.toFixed(0)) || !t(34)(function () {
                    c.call({});
                })), "Number", { toFixed: function toFixed(t) {
                        var n,
                            r,
                            e,
                            c,
                            f = o(this, s),
                            a = i(t),
                            g = "",
                            b = l;if (a < 0 || a > 20) throw RangeError(s);if (f != f) return "NaN";if (f <= -1e21 || f >= 1e21) return String(f);if (f < 0 && (g = "-", f = -f), f > 1e-21) if (n = y(f * d(2, 69, 1)) - 69, r = n < 0 ? f * d(2, -n, 1) : f / d(2, n, 1), r *= 4503599627370496, n = 52 - n, n > 0) {
                            for (h(0, r), e = a; e >= 7;) {
                                h(1e7, 0), e -= 7;
                            }for (h(d(10, e, 1), 0), e = n - 1; e >= 23;) {
                                v(1 << 23), e -= 23;
                            }v(1 << e), h(1, 1), v(2), b = p();
                        } else h(0, r), h(1 << -n, 0), b = p() + u.call(l, a);return a > 0 ? (c = b.length, b = g + (c <= a ? "0." + u.call(l, a - c) + b : b.slice(0, c - a) + "." + b.slice(c - a))) : b = g + b, b;
                    } });
            }, { 101: 101, 106: 106, 32: 32, 34: 34, 4: 4 }], 178: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(34),
                    o = t(4),
                    u = 1..toPrecision;e(e.P + e.F * (i(function () {
                    return "1" !== u.call(1, void 0);
                }) || !i(function () {
                    u.call({});
                })), "Number", { toPrecision: function toPrecision(t) {
                        var n = o(this, "Number#toPrecision: incorrect invocation!");return void 0 === t ? u.call(n) : u.call(n, t);
                    } });
            }, { 32: 32, 34: 34, 4: 4 }], 179: [function (t, n, r) {
                var e = t(32);e(e.S + e.F, "Object", { assign: t(65) });
            }, { 32: 32, 65: 65 }], 180: [function (t, n, r) {
                var e = t(32);e(e.S, "Object", { create: t(66) });
            }, { 32: 32, 66: 66 }], 181: [function (t, n, r) {
                var e = t(32);e(e.S + e.F * !t(28), "Object", { defineProperties: t(68) });
            }, { 28: 28, 32: 32, 68: 68 }], 182: [function (t, n, r) {
                var e = t(32);e(e.S + e.F * !t(28), "Object", { defineProperty: t(67).f });
            }, { 28: 28, 32: 32, 67: 67 }], 183: [function (t, n, r) {
                var e = t(49),
                    i = t(62).onFreeze;t(78)("freeze", function (t) {
                    return function freeze(n) {
                        return t && e(n) ? t(i(n)) : n;
                    };
                });
            }, { 49: 49, 62: 62, 78: 78 }], 184: [function (t, n, r) {
                var e = t(107),
                    i = t(70).f;t(78)("getOwnPropertyDescriptor", function () {
                    return function getOwnPropertyDescriptor(t, n) {
                        return i(e(t), n);
                    };
                });
            }, { 107: 107, 70: 70, 78: 78 }], 185: [function (t, n, r) {
                t(78)("getOwnPropertyNames", function () {
                    return t(71).f;
                });
            }, { 71: 71, 78: 78 }], 186: [function (t, n, r) {
                var e = t(109),
                    i = t(74);t(78)("getPrototypeOf", function () {
                    return function getPrototypeOf(t) {
                        return i(e(t));
                    };
                });
            }, { 109: 109, 74: 74, 78: 78 }], 187: [function (t, n, r) {
                var e = t(49);t(78)("isExtensible", function (t) {
                    return function isExtensible(n) {
                        return !!e(n) && (!t || t(n));
                    };
                });
            }, { 49: 49, 78: 78 }], 188: [function (t, n, r) {
                var e = t(49);t(78)("isFrozen", function (t) {
                    return function isFrozen(n) {
                        return !e(n) || !!t && t(n);
                    };
                });
            }, { 49: 49, 78: 78 }], 189: [function (t, n, r) {
                var e = t(49);t(78)("isSealed", function (t) {
                    return function isSealed(n) {
                        return !e(n) || !!t && t(n);
                    };
                });
            }, { 49: 49, 78: 78 }], 190: [function (t, n, r) {
                var e = t(32);e(e.S, "Object", { is: t(89) });
            }, { 32: 32, 89: 89 }], 191: [function (t, n, r) {
                var e = t(109),
                    i = t(76);t(78)("keys", function () {
                    return function keys(t) {
                        return i(e(t));
                    };
                });
            }, { 109: 109, 76: 76, 78: 78 }], 192: [function (t, n, r) {
                var e = t(49),
                    i = t(62).onFreeze;t(78)("preventExtensions", function (t) {
                    return function preventExtensions(n) {
                        return t && e(n) ? t(i(n)) : n;
                    };
                });
            }, { 49: 49, 62: 62, 78: 78 }], 193: [function (t, n, r) {
                var e = t(49),
                    i = t(62).onFreeze;t(78)("seal", function (t) {
                    return function seal(n) {
                        return t && e(n) ? t(i(n)) : n;
                    };
                });
            }, { 49: 49, 62: 62, 78: 78 }], 194: [function (t, n, r) {
                var e = t(32);e(e.S, "Object", { setPrototypeOf: t(90).set });
            }, { 32: 32, 90: 90 }], 195: [function (t, n, r) {
                "use strict";
                var e = t(17),
                    i = {};i[t(117)("toStringTag")] = "z", i + "" != "[object z]" && t(87)(Object.prototype, "toString", function toString() {
                    return "[object " + e(this) + "]";
                }, !0);
            }, { 117: 117, 17: 17, 87: 87 }], 196: [function (t, n, r) {
                var e = t(32),
                    i = t(81);e(e.G + e.F * (parseFloat != i), { parseFloat: i });
            }, { 32: 32, 81: 81 }], 197: [function (t, n, r) {
                var e = t(32),
                    i = t(82);e(e.G + e.F * (parseInt != i), { parseInt: i });
            }, { 32: 32, 82: 82 }], 198: [function (t, n, r) {
                "use strict";
                var e,
                    i,
                    o,
                    u = t(58),
                    c = t(38),
                    f = t(25),
                    a = t(17),
                    s = t(32),
                    l = t(49),
                    h = t(3),
                    v = t(6),
                    p = t(37),
                    d = t(95),
                    y = t(104).set,
                    g = t(64)(),
                    b = "Promise",
                    x = c.TypeError,
                    m = c.process,
                    w = c[b],
                    m = c.process,
                    S = "process" == a(m),
                    _ = function _() {},
                    E = !!function () {
                    try {
                        var n = w.resolve(1),
                            r = (n.constructor = {})[t(117)("species")] = function (t) {
                            t(_, _);
                        };return (S || "function" == typeof PromiseRejectionEvent) && n.then(_) instanceof r;
                    } catch (t) {}
                }(),
                    O = function O(t, n) {
                    return t === n || t === w && n === o;
                },
                    F = function F(t) {
                    var n;return !(!l(t) || "function" != typeof (n = t.then)) && n;
                },
                    P = function P(t) {
                    return O(w, t) ? new M(t) : new i(t);
                },
                    M = i = function i(t) {
                    var n, r;this.promise = new t(function (t, e) {
                        if (void 0 !== n || void 0 !== r) throw x("Bad Promise constructor");n = t, r = e;
                    }), this.resolve = h(n), this.reject = h(r);
                },
                    A = function A(t) {
                    try {
                        t();
                    } catch (t) {
                        return { error: t };
                    }
                },
                    I = function I(t, n) {
                    if (!t._n) {
                        t._n = !0;var r = t._c;g(function () {
                            for (var e = t._v, i = 1 == t._s, o = 0, u = function u(n) {
                                var r,
                                    o,
                                    u = i ? n.ok : n.fail,
                                    c = n.resolve,
                                    f = n.reject,
                                    a = n.domain;try {
                                    u ? (i || (2 == t._h && k(t), t._h = 1), u === !0 ? r = e : (a && a.enter(), r = u(e), a && a.exit()), r === n.promise ? f(x("Promise-chain cycle")) : (o = F(r)) ? o.call(r, c, f) : c(r)) : f(e);
                                } catch (t) {
                                    f(t);
                                }
                            }; r.length > o;) {
                                u(r[o++]);
                            }t._c = [], t._n = !1, n && !t._h && j(t);
                        });
                    }
                },
                    j = function j(t) {
                    y.call(c, function () {
                        var n,
                            r,
                            e,
                            i = t._v;if (N(t) && (n = A(function () {
                            S ? m.emit("unhandledRejection", i, t) : (r = c.onunhandledrejection) ? r({ promise: t, reason: i }) : (e = c.console) && e.error && e.error("Unhandled promise rejection", i);
                        }), t._h = S || N(t) ? 2 : 1), t._a = void 0, n) throw n.error;
                    });
                },
                    N = function N(t) {
                    if (1 == t._h) return !1;for (var n, r = t._a || t._c, e = 0; r.length > e;) {
                        if (n = r[e++], n.fail || !N(n.promise)) return !1;
                    }return !0;
                },
                    k = function k(t) {
                    y.call(c, function () {
                        var n;S ? m.emit("rejectionHandled", t) : (n = c.onrejectionhandled) && n({ promise: t, reason: t._v });
                    });
                },
                    R = function R(t) {
                    var n = this;n._d || (n._d = !0, n = n._w || n, n._v = t, n._s = 2, n._a || (n._a = n._c.slice()), I(n, !0));
                },
                    T = function T(t) {
                    var n,
                        r = this;if (!r._d) {
                        r._d = !0, r = r._w || r;try {
                            if (r === t) throw x("Promise can't be resolved itself");(n = F(t)) ? g(function () {
                                var e = { _w: r, _d: !1 };try {
                                    n.call(t, f(T, e, 1), f(R, e, 1));
                                } catch (t) {
                                    R.call(e, t);
                                }
                            }) : (r._v = t, r._s = 1, I(r, !1));
                        } catch (t) {
                            R.call({ _w: r, _d: !1 }, t);
                        }
                    }
                };E || (w = function Promise(t) {
                    v(this, w, b, "_h"), h(t), e.call(this);try {
                        t(f(T, this, 1), f(R, this, 1));
                    } catch (t) {
                        R.call(this, t);
                    }
                }, e = function Promise(t) {
                    this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
                }, e.prototype = t(86)(w.prototype, { then: function then(t, n) {
                        var r = P(d(this, w));return r.ok = "function" != typeof t || t, r.fail = "function" == typeof n && n, r.domain = S ? m.domain : void 0, this._c.push(r), this._a && this._a.push(r), this._s && I(this, !1), r.promise;
                    }, catch: function _catch(t) {
                        return this.then(void 0, t);
                    } }), M = function M() {
                    var t = new e();this.promise = t, this.resolve = f(T, t, 1), this.reject = f(R, t, 1);
                }), s(s.G + s.W + s.F * !E, { Promise: w }), t(92)(w, b), t(91)(b), o = t(23)[b], s(s.S + s.F * !E, b, { reject: function reject(t) {
                        var n = P(this),
                            r = n.reject;return r(t), n.promise;
                    } }), s(s.S + s.F * (u || !E), b, { resolve: function resolve(t) {
                        if (t instanceof w && O(t.constructor, this)) return t;var n = P(this),
                            r = n.resolve;return r(t), n.promise;
                    } }), s(s.S + s.F * !(E && t(54)(function (t) {
                    w.all(t).catch(_);
                })), b, { all: function all(t) {
                        var n = this,
                            r = P(n),
                            e = r.resolve,
                            i = r.reject,
                            o = A(function () {
                            var r = [],
                                o = 0,
                                u = 1;p(t, !1, function (t) {
                                var c = o++,
                                    f = !1;r.push(void 0), u++, n.resolve(t).then(function (t) {
                                    f || (f = !0, r[c] = t, --u || e(r));
                                }, i);
                            }), --u || e(r);
                        });return o && i(o.error), r.promise;
                    }, race: function race(t) {
                        var n = this,
                            r = P(n),
                            e = r.reject,
                            i = A(function () {
                            p(t, !1, function (t) {
                                n.resolve(t).then(r.resolve, e);
                            });
                        });return i && e(i.error), r.promise;
                    } });
            }, { 104: 104, 117: 117, 17: 17, 23: 23, 25: 25, 3: 3, 32: 32, 37: 37, 38: 38, 49: 49, 54: 54, 58: 58, 6: 6, 64: 64, 86: 86, 91: 91, 92: 92, 95: 95 }], 199: [function (t, n, r) {
                var e = t(32),
                    i = t(3),
                    o = t(7),
                    u = (t(38).Reflect || {}).apply,
                    c = Function.apply;e(e.S + e.F * !t(34)(function () {
                    u(function () {});
                }), "Reflect", { apply: function apply(t, n, r) {
                        var e = i(t),
                            f = o(r);return u ? u(e, n, f) : c.call(e, n, f);
                    } });
            }, { 3: 3, 32: 32, 34: 34, 38: 38, 7: 7 }], 200: [function (t, n, r) {
                var e = t(32),
                    i = t(66),
                    o = t(3),
                    u = t(7),
                    c = t(49),
                    f = t(34),
                    a = t(16),
                    s = (t(38).Reflect || {}).construct,
                    l = f(function () {
                    function F() {}return !(s(function () {}, [], F) instanceof F);
                }),
                    h = !f(function () {
                    s(function () {});
                });e(e.S + e.F * (l || h), "Reflect", { construct: function construct(t, n) {
                        o(t), u(n);var r = arguments.length < 3 ? t : o(arguments[2]);if (h && !l) return s(t, n, r);if (t == r) {
                            switch (n.length) {case 0:
                                    return new t();case 1:
                                    return new t(n[0]);case 2:
                                    return new t(n[0], n[1]);case 3:
                                    return new t(n[0], n[1], n[2]);case 4:
                                    return new t(n[0], n[1], n[2], n[3]);}var e = [null];return e.push.apply(e, n), new (a.apply(t, e))();
                        }var f = r.prototype,
                            v = i(c(f) ? f : Object.prototype),
                            p = Function.apply.call(t, v, n);return c(p) ? p : v;
                    } });
            }, { 16: 16, 3: 3, 32: 32, 34: 34, 38: 38, 49: 49, 66: 66, 7: 7 }], 201: [function (t, n, r) {
                var e = t(67),
                    i = t(32),
                    o = t(7),
                    u = t(110);i(i.S + i.F * t(34)(function () {
                    Reflect.defineProperty(e.f({}, 1, { value: 1 }), 1, { value: 2 });
                }), "Reflect", { defineProperty: function defineProperty(t, n, r) {
                        o(t), n = u(n, !0), o(r);try {
                            return e.f(t, n, r), !0;
                        } catch (t) {
                            return !1;
                        }
                    } });
            }, { 110: 110, 32: 32, 34: 34, 67: 67, 7: 7 }], 202: [function (t, n, r) {
                var e = t(32),
                    i = t(70).f,
                    o = t(7);e(e.S, "Reflect", { deleteProperty: function deleteProperty(t, n) {
                        var r = i(o(t), n);return !(r && !r.configurable) && delete t[n];
                    } });
            }, { 32: 32, 7: 7, 70: 70 }], 203: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(7),
                    o = function o(t) {
                    this._t = i(t), this._i = 0;var n,
                        r = this._k = [];for (n in t) {
                        r.push(n);
                    }
                };t(52)(o, "Object", function () {
                    var t,
                        n = this,
                        r = n._k;do {
                        if (n._i >= r.length) return { value: void 0, done: !0 };
                    } while (!((t = r[n._i++]) in n._t));return { value: t, done: !1 };
                }), e(e.S, "Reflect", { enumerate: function enumerate(t) {
                        return new o(t);
                    } });
            }, { 32: 32, 52: 52, 7: 7 }], 204: [function (t, n, r) {
                var e = t(70),
                    i = t(32),
                    o = t(7);i(i.S, "Reflect", { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(t, n) {
                        return e.f(o(t), n);
                    } });
            }, { 32: 32, 7: 7, 70: 70 }], 205: [function (t, n, r) {
                var e = t(32),
                    i = t(74),
                    o = t(7);e(e.S, "Reflect", { getPrototypeOf: function getPrototypeOf(t) {
                        return i(o(t));
                    } });
            }, { 32: 32, 7: 7, 74: 74 }], 206: [function (t, n, r) {
                function get(t, n) {
                    var r,
                        u,
                        a = arguments.length < 3 ? t : arguments[2];return f(t) === a ? t[n] : (r = e.f(t, n)) ? o(r, "value") ? r.value : void 0 !== r.get ? r.get.call(a) : void 0 : c(u = i(t)) ? get(u, n, a) : void 0;
                }var e = t(70),
                    i = t(74),
                    o = t(39),
                    u = t(32),
                    c = t(49),
                    f = t(7);u(u.S, "Reflect", { get: get });
            }, { 32: 32, 39: 39, 49: 49, 7: 7, 70: 70, 74: 74 }], 207: [function (t, n, r) {
                var e = t(32);e(e.S, "Reflect", { has: function has(t, n) {
                        return n in t;
                    } });
            }, { 32: 32 }], 208: [function (t, n, r) {
                var e = t(32),
                    i = t(7),
                    o = Object.isExtensible;e(e.S, "Reflect", { isExtensible: function isExtensible(t) {
                        return i(t), !o || o(t);
                    } });
            }, { 32: 32, 7: 7 }], 209: [function (t, n, r) {
                var e = t(32);e(e.S, "Reflect", { ownKeys: t(80) });
            }, { 32: 32, 80: 80 }], 210: [function (t, n, r) {
                var e = t(32),
                    i = t(7),
                    o = Object.preventExtensions;e(e.S, "Reflect", { preventExtensions: function preventExtensions(t) {
                        i(t);try {
                            return o && o(t), !0;
                        } catch (t) {
                            return !1;
                        }
                    } });
            }, { 32: 32, 7: 7 }], 211: [function (t, n, r) {
                var e = t(32),
                    i = t(90);i && e(e.S, "Reflect", { setPrototypeOf: function setPrototypeOf(t, n) {
                        i.check(t, n);try {
                            return i.set(t, n), !0;
                        } catch (t) {
                            return !1;
                        }
                    } });
            }, { 32: 32, 90: 90 }], 212: [function (t, n, r) {
                function set(t, n, r) {
                    var c,
                        l,
                        h = arguments.length < 4 ? t : arguments[3],
                        v = i.f(a(t), n);if (!v) {
                        if (s(l = o(t))) return set(l, n, r, h);v = f(0);
                    }return u(v, "value") ? !(v.writable === !1 || !s(h)) && (c = i.f(h, n) || f(0), c.value = r, e.f(h, n, c), !0) : void 0 !== v.set && (v.set.call(h, r), !0);
                }var e = t(67),
                    i = t(70),
                    o = t(74),
                    u = t(39),
                    c = t(32),
                    f = t(85),
                    a = t(7),
                    s = t(49);c(c.S, "Reflect", { set: set });
            }, { 32: 32, 39: 39, 49: 49, 67: 67, 7: 7, 70: 70, 74: 74, 85: 85 }], 213: [function (t, n, r) {
                var e = t(38),
                    i = t(43),
                    o = t(67).f,
                    u = t(72).f,
                    c = t(50),
                    f = t(36),
                    a = e.RegExp,
                    s = a,
                    l = a.prototype,
                    h = /a/g,
                    v = /a/g,
                    p = new a(h) !== h;if (t(28) && (!p || t(34)(function () {
                    return v[t(117)("match")] = !1, a(h) != h || a(v) == v || "/a/i" != a(h, "i");
                }))) {
                    a = function RegExp(t, n) {
                        var r = this instanceof a,
                            e = c(t),
                            o = void 0 === n;return !r && e && t.constructor === a && o ? t : i(p ? new s(e && !o ? t.source : t, n) : s((e = t instanceof a) ? t.source : t, e && o ? f.call(t) : n), r ? this : l, a);
                    };for (var d = function d(t) {
                        (t in a) || o(a, t, { configurable: !0, get: function get() {
                                return s[t];
                            }, set: function set(n) {
                                s[t] = n;
                            } });
                    }, y = u(s), g = 0; y.length > g;) {
                        d(y[g++]);
                    }l.constructor = a, a.prototype = l, t(87)(e, "RegExp", a);
                }t(91)("RegExp");
            }, { 117: 117, 28: 28, 34: 34, 36: 36, 38: 38, 43: 43, 50: 50, 67: 67, 72: 72, 87: 87, 91: 91 }], 214: [function (t, n, r) {
                t(28) && "g" != /./g.flags && t(67).f(RegExp.prototype, "flags", { configurable: !0, get: t(36) });
            }, { 28: 28, 36: 36, 67: 67 }], 215: [function (t, n, r) {
                t(35)("match", 1, function (t, n, r) {
                    return [function match(r) {
                        "use strict";
                        var e = t(this),
                            i = void 0 == r ? void 0 : r[n];return void 0 !== i ? i.call(r, e) : new RegExp(r)[n](String(e));
                    }, r];
                });
            }, { 35: 35 }], 216: [function (t, n, r) {
                t(35)("replace", 2, function (t, n, r) {
                    return [function replace(e, i) {
                        "use strict";
                        var o = t(this),
                            u = void 0 == e ? void 0 : e[n];return void 0 !== u ? u.call(e, o, i) : r.call(String(o), e, i);
                    }, r];
                });
            }, { 35: 35 }], 217: [function (t, n, r) {
                t(35)("search", 1, function (t, n, r) {
                    return [function search(r) {
                        "use strict";
                        var e = t(this),
                            i = void 0 == r ? void 0 : r[n];return void 0 !== i ? i.call(r, e) : new RegExp(r)[n](String(e));
                    }, r];
                });
            }, { 35: 35 }], 218: [function (t, n, r) {
                t(35)("split", 2, function (n, r, e) {
                    "use strict";
                    var i = t(50),
                        o = e,
                        u = [].push,
                        c = "split",
                        f = "length",
                        a = "lastIndex";if ("c" == "abbc"[c](/(b)*/)[1] || 4 != "test"[c](/(?:)/, -1)[f] || 2 != "ab"[c](/(?:ab)*/)[f] || 4 != "."[c](/(.?)(.?)/)[f] || "."[c](/()()/)[f] > 1 || ""[c](/.?/)[f]) {
                        var s = void 0 === /()??/.exec("")[1];e = function e(t, n) {
                            var r = String(this);if (void 0 === t && 0 === n) return [];if (!i(t)) return o.call(r, t, n);var e,
                                c,
                                l,
                                h,
                                v,
                                p = [],
                                d = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""),
                                y = 0,
                                g = void 0 === n ? 4294967295 : n >>> 0,
                                b = new RegExp(t.source, d + "g");for (s || (e = new RegExp("^" + b.source + "$(?!\\s)", d)); (c = b.exec(r)) && (l = c.index + c[0][f], !(l > y && (p.push(r.slice(y, c.index)), !s && c[f] > 1 && c[0].replace(e, function () {
                                for (v = 1; v < arguments[f] - 2; v++) {
                                    void 0 === arguments[v] && (c[v] = void 0);
                                }
                            }), c[f] > 1 && c.index < r[f] && u.apply(p, c.slice(1)), h = c[0][f], y = l, p[f] >= g)));) {
                                b[a] === c.index && b[a]++;
                            }return y === r[f] ? !h && b.test("") || p.push("") : p.push(r.slice(y)), p[f] > g ? p.slice(0, g) : p;
                        };
                    } else "0"[c](void 0, 0)[f] && (e = function e(t, n) {
                        return void 0 === t && 0 === n ? [] : o.call(this, t, n);
                    });return [function split(t, i) {
                        var o = n(this),
                            u = void 0 == t ? void 0 : t[r];return void 0 !== u ? u.call(t, o, i) : e.call(String(o), t, i);
                    }, e];
                });
            }, { 35: 35, 50: 50 }], 219: [function (t, n, r) {
                "use strict";
                t(214);var e = t(7),
                    i = t(36),
                    o = t(28),
                    u = "toString",
                    c = /./[u],
                    f = function f(n) {
                    t(87)(RegExp.prototype, u, n, !0);
                };t(34)(function () {
                    return "/a/b" != c.call({ source: "a", flags: "b" });
                }) ? f(function toString() {
                    var t = e(this);return "/".concat(t.source, "/", "flags" in t ? t.flags : !o && t instanceof RegExp ? i.call(t) : void 0);
                }) : c.name != u && f(function toString() {
                    return c.call(this);
                });
            }, { 214: 214, 28: 28, 34: 34, 36: 36, 7: 7, 87: 87 }], 220: [function (t, n, r) {
                "use strict";
                var e = t(19);n.exports = t(22)("Set", function (t) {
                    return function Set() {
                        return t(this, arguments.length > 0 ? arguments[0] : void 0);
                    };
                }, { add: function add(t) {
                        return e.def(this, t = 0 === t ? 0 : t, t);
                    } }, e);
            }, { 19: 19, 22: 22 }], 221: [function (t, n, r) {
                "use strict";
                t(99)("anchor", function (t) {
                    return function anchor(n) {
                        return t(this, "a", "name", n);
                    };
                });
            }, { 99: 99 }], 222: [function (t, n, r) {
                "use strict";
                t(99)("big", function (t) {
                    return function big() {
                        return t(this, "big", "", "");
                    };
                });
            }, { 99: 99 }], 223: [function (t, n, r) {
                "use strict";
                t(99)("blink", function (t) {
                    return function blink() {
                        return t(this, "blink", "", "");
                    };
                });
            }, { 99: 99 }], 224: [function (t, n, r) {
                "use strict";
                t(99)("bold", function (t) {
                    return function bold() {
                        return t(this, "b", "", "");
                    };
                });
            }, { 99: 99 }], 225: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(97)(!1);e(e.P, "String", { codePointAt: function codePointAt(t) {
                        return i(this, t);
                    } });
            }, { 32: 32, 97: 97 }], 226: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(108),
                    o = t(98),
                    u = "endsWith",
                    c = ""[u];e(e.P + e.F * t(33)(u), "String", { endsWith: function endsWith(t) {
                        var n = o(this, t, u),
                            r = arguments.length > 1 ? arguments[1] : void 0,
                            e = i(n.length),
                            f = void 0 === r ? e : Math.min(i(r), e),
                            a = String(t);return c ? c.call(n, a, f) : n.slice(f - a.length, f) === a;
                    } });
            }, { 108: 108, 32: 32, 33: 33, 98: 98 }], 227: [function (t, n, r) {
                "use strict";
                t(99)("fixed", function (t) {
                    return function fixed() {
                        return t(this, "tt", "", "");
                    };
                });
            }, { 99: 99 }], 228: [function (t, n, r) {
                "use strict";
                t(99)("fontcolor", function (t) {
                    return function fontcolor(n) {
                        return t(this, "font", "color", n);
                    };
                });
            }, { 99: 99 }], 229: [function (t, n, r) {
                "use strict";
                t(99)("fontsize", function (t) {
                    return function fontsize(n) {
                        return t(this, "font", "size", n);
                    };
                });
            }, { 99: 99 }], 230: [function (t, n, r) {
                var e = t(32),
                    i = t(105),
                    o = String.fromCharCode,
                    u = String.fromCodePoint;e(e.S + e.F * (!!u && 1 != u.length), "String", { fromCodePoint: function fromCodePoint(t) {
                        for (var n, r = [], e = arguments.length, u = 0; e > u;) {
                            if (n = +arguments[u++], i(n, 1114111) !== n) throw RangeError(n + " is not a valid code point");r.push(n < 65536 ? o(n) : o(((n -= 65536) >> 10) + 55296, n % 1024 + 56320));
                        }return r.join("");
                    } });
            }, { 105: 105, 32: 32 }], 231: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(98),
                    o = "includes";e(e.P + e.F * t(33)(o), "String", { includes: function includes(t) {
                        return !!~i(this, t, o).indexOf(t, arguments.length > 1 ? arguments[1] : void 0);
                    } });
            }, { 32: 32, 33: 33, 98: 98 }], 232: [function (t, n, r) {
                "use strict";
                t(99)("italics", function (t) {
                    return function italics() {
                        return t(this, "i", "", "");
                    };
                });
            }, { 99: 99 }], 233: [function (t, n, r) {
                "use strict";
                var e = t(97)(!0);t(53)(String, "String", function (t) {
                    this._t = String(t), this._i = 0;
                }, function () {
                    var t,
                        n = this._t,
                        r = this._i;return r >= n.length ? { value: void 0, done: !0 } : (t = e(n, r), this._i += t.length, { value: t, done: !1 });
                });
            }, { 53: 53, 97: 97 }], 234: [function (t, n, r) {
                "use strict";
                t(99)("link", function (t) {
                    return function link(n) {
                        return t(this, "a", "href", n);
                    };
                });
            }, { 99: 99 }], 235: [function (t, n, r) {
                var e = t(32),
                    i = t(107),
                    o = t(108);e(e.S, "String", { raw: function raw(t) {
                        for (var n = i(t.raw), r = o(n.length), e = arguments.length, u = [], c = 0; r > c;) {
                            u.push(String(n[c++])), c < e && u.push(String(arguments[c]));
                        }return u.join("");
                    } });
            }, { 107: 107, 108: 108, 32: 32 }], 236: [function (t, n, r) {
                var e = t(32);e(e.P, "String", { repeat: t(101) });
            }, { 101: 101, 32: 32 }], 237: [function (t, n, r) {
                "use strict";
                t(99)("small", function (t) {
                    return function small() {
                        return t(this, "small", "", "");
                    };
                });
            }, { 99: 99 }], 238: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(108),
                    o = t(98),
                    u = "startsWith",
                    c = ""[u];e(e.P + e.F * t(33)(u), "String", { startsWith: function startsWith(t) {
                        var n = o(this, t, u),
                            r = i(Math.min(arguments.length > 1 ? arguments[1] : void 0, n.length)),
                            e = String(t);return c ? c.call(n, e, r) : n.slice(r, r + e.length) === e;
                    } });
            }, { 108: 108, 32: 32, 33: 33, 98: 98 }], 239: [function (t, n, r) {
                "use strict";
                t(99)("strike", function (t) {
                    return function strike() {
                        return t(this, "strike", "", "");
                    };
                });
            }, { 99: 99 }], 240: [function (t, n, r) {
                "use strict";
                t(99)("sub", function (t) {
                    return function sub() {
                        return t(this, "sub", "", "");
                    };
                });
            }, { 99: 99 }], 241: [function (t, n, r) {
                "use strict";
                t(99)("sup", function (t) {
                    return function sup() {
                        return t(this, "sup", "", "");
                    };
                });
            }, { 99: 99 }], 242: [function (t, n, r) {
                "use strict";
                t(102)("trim", function (t) {
                    return function trim() {
                        return t(this, 3);
                    };
                });
            }, { 102: 102 }], 243: [function (t, n, r) {
                "use strict";
                var e = t(38),
                    i = t(39),
                    o = t(28),
                    u = t(32),
                    c = t(87),
                    f = t(62).KEY,
                    a = t(34),
                    s = t(94),
                    l = t(92),
                    h = t(114),
                    v = t(117),
                    p = t(116),
                    d = t(115),
                    y = t(57),
                    g = t(31),
                    b = t(47),
                    x = t(7),
                    m = t(107),
                    w = t(110),
                    S = t(85),
                    _ = t(66),
                    E = t(71),
                    O = t(70),
                    F = t(67),
                    P = t(76),
                    M = O.f,
                    A = F.f,
                    I = E.f,
                    j = e.Symbol,
                    N = e.JSON,
                    k = N && N.stringify,
                    R = "prototype",
                    T = v("_hidden"),
                    L = v("toPrimitive"),
                    C = {}.propertyIsEnumerable,
                    U = s("symbol-registry"),
                    G = s("symbols"),
                    D = s("op-symbols"),
                    W = Object[R],
                    B = "function" == typeof j,
                    V = e.QObject,
                    z = !V || !V[R] || !V[R].findChild,
                    K = o && a(function () {
                    return 7 != _(A({}, "a", { get: function get() {
                            return A(this, "a", { value: 7 }).a;
                        } })).a;
                }) ? function (t, n, r) {
                    var e = M(W, n);e && delete W[n], A(t, n, r), e && t !== W && A(W, n, e);
                } : A,
                    J = function J(t) {
                    var n = G[t] = _(j[R]);return n._k = t, n;
                },
                    Y = B && "symbol" == _typeof(j.iterator) ? function (t) {
                    return "symbol" == (typeof t === 'undefined' ? 'undefined' : _typeof(t));
                } : function (t) {
                    return t instanceof j;
                },
                    q = function defineProperty(t, n, r) {
                    return t === W && q(D, n, r), x(t), n = w(n, !0), x(r), i(G, n) ? (r.enumerable ? (i(t, T) && t[T][n] && (t[T][n] = !1), r = _(r, { enumerable: S(0, !1) })) : (i(t, T) || A(t, T, S(1, {})), t[T][n] = !0), K(t, n, r)) : A(t, n, r);
                },
                    X = function defineProperties(t, n) {
                    x(t);for (var r, e = g(n = m(n)), i = 0, o = e.length; o > i;) {
                        q(t, r = e[i++], n[r]);
                    }return t;
                },
                    $ = function create(t, n) {
                    return void 0 === n ? _(t) : X(_(t), n);
                },
                    H = function propertyIsEnumerable(t) {
                    var n = C.call(this, t = w(t, !0));return !(this === W && i(G, t) && !i(D, t)) && (!(n || !i(this, t) || !i(G, t) || i(this, T) && this[T][t]) || n);
                },
                    Z = function getOwnPropertyDescriptor(t, n) {
                    if (t = m(t), n = w(n, !0), t !== W || !i(G, n) || i(D, n)) {
                        var r = M(t, n);return !r || !i(G, n) || i(t, T) && t[T][n] || (r.enumerable = !0), r;
                    }
                },
                    Q = function getOwnPropertyNames(t) {
                    for (var n, r = I(m(t)), e = [], o = 0; r.length > o;) {
                        i(G, n = r[o++]) || n == T || n == f || e.push(n);
                    }return e;
                },
                    tt = function getOwnPropertySymbols(t) {
                    for (var n, r = t === W, e = I(r ? D : m(t)), o = [], u = 0; e.length > u;) {
                        !i(G, n = e[u++]) || r && !i(W, n) || o.push(G[n]);
                    }return o;
                };B || (j = function _Symbol() {
                    if (this instanceof j) throw TypeError("Symbol is not a constructor!");var t = h(arguments.length > 0 ? arguments[0] : void 0),
                        n = function n(r) {
                        this === W && n.call(D, r), i(this, T) && i(this[T], t) && (this[T][t] = !1), K(this, t, S(1, r));
                    };return o && z && K(W, t, { configurable: !0, set: n }), J(t);
                }, c(j[R], "toString", function toString() {
                    return this._k;
                }), O.f = Z, F.f = q, t(72).f = E.f = Q, t(77).f = H, t(73).f = tt, o && !t(58) && c(W, "propertyIsEnumerable", H, !0), p.f = function (t) {
                    return J(v(t));
                }), u(u.G + u.W + u.F * !B, { Symbol: j });for (var nt = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), rt = 0; nt.length > rt;) {
                    v(nt[rt++]);
                }for (var nt = P(v.store), rt = 0; nt.length > rt;) {
                    d(nt[rt++]);
                }u(u.S + u.F * !B, "Symbol", { for: function _for(t) {
                        return i(U, t += "") ? U[t] : U[t] = j(t);
                    }, keyFor: function keyFor(t) {
                        if (Y(t)) return y(U, t);throw TypeError(t + " is not a symbol!");
                    }, useSetter: function useSetter() {
                        z = !0;
                    }, useSimple: function useSimple() {
                        z = !1;
                    } }), u(u.S + u.F * !B, "Object", { create: $, defineProperty: q, defineProperties: X, getOwnPropertyDescriptor: Z, getOwnPropertyNames: Q, getOwnPropertySymbols: tt }), N && u(u.S + u.F * (!B || a(function () {
                    var t = j();return "[null]" != k([t]) || "{}" != k({ a: t }) || "{}" != k(Object(t));
                })), "JSON", { stringify: function stringify(t) {
                        if (void 0 !== t && !Y(t)) {
                            for (var n, r, e = [t], i = 1; arguments.length > i;) {
                                e.push(arguments[i++]);
                            }return n = e[1], "function" == typeof n && (r = n), !r && b(n) || (n = function n(t, _n) {
                                if (r && (_n = r.call(this, t, _n)), !Y(_n)) return _n;
                            }), e[1] = n, k.apply(N, e);
                        }
                    } }), j[R][L] || t(40)(j[R], L, j[R].valueOf), l(j, "Symbol"), l(Math, "Math", !0), l(e.JSON, "JSON", !0);
            }, { 107: 107, 110: 110, 114: 114, 115: 115, 116: 116, 117: 117, 28: 28, 31: 31, 32: 32, 34: 34, 38: 38, 39: 39, 40: 40, 47: 47, 57: 57, 58: 58, 62: 62, 66: 66, 67: 67, 7: 7, 70: 70, 71: 71, 72: 72, 73: 73, 76: 76, 77: 77, 85: 85, 87: 87, 92: 92, 94: 94 }], 244: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(113),
                    o = t(112),
                    u = t(7),
                    c = t(105),
                    f = t(108),
                    a = t(49),
                    s = t(38).ArrayBuffer,
                    l = t(95),
                    h = o.ArrayBuffer,
                    v = o.DataView,
                    p = i.ABV && s.isView,
                    d = h.prototype.slice,
                    y = i.VIEW,
                    g = "ArrayBuffer";e(e.G + e.W + e.F * (s !== h), { ArrayBuffer: h }), e(e.S + e.F * !i.CONSTR, g, { isView: function isView(t) {
                        return p && p(t) || a(t) && y in t;
                    } }), e(e.P + e.U + e.F * t(34)(function () {
                    return !new h(2).slice(1, void 0).byteLength;
                }), g, { slice: function slice(t, n) {
                        if (void 0 !== d && void 0 === n) return d.call(u(this), t);for (var r = u(this).byteLength, e = c(t, r), i = c(void 0 === n ? r : n, r), o = new (l(this, h))(f(i - e)), a = new v(this), s = new v(o), p = 0; e < i;) {
                            s.setUint8(p++, a.getUint8(e++));
                        }return o;
                    } }), t(91)(g);
            }, { 105: 105, 108: 108, 112: 112, 113: 113, 32: 32, 34: 34, 38: 38, 49: 49, 7: 7, 91: 91, 95: 95 }], 245: [function (t, n, r) {
                var e = t(32);e(e.G + e.W + e.F * !t(113).ABV, { DataView: t(112).DataView });
            }, { 112: 112, 113: 113, 32: 32 }], 246: [function (t, n, r) {
                t(111)("Float32", 4, function (t) {
                    return function Float32Array(n, r, e) {
                        return t(this, n, r, e);
                    };
                });
            }, { 111: 111 }], 247: [function (t, n, r) {
                t(111)("Float64", 8, function (t) {
                    return function Float64Array(n, r, e) {
                        return t(this, n, r, e);
                    };
                });
            }, { 111: 111 }], 248: [function (t, n, r) {
                t(111)("Int16", 2, function (t) {
                    return function Int16Array(n, r, e) {
                        return t(this, n, r, e);
                    };
                });
            }, { 111: 111 }], 249: [function (t, n, r) {
                t(111)("Int32", 4, function (t) {
                    return function Int32Array(n, r, e) {
                        return t(this, n, r, e);
                    };
                });
            }, { 111: 111 }], 250: [function (t, n, r) {
                t(111)("Int8", 1, function (t) {
                    return function Int8Array(n, r, e) {
                        return t(this, n, r, e);
                    };
                });
            }, { 111: 111 }], 251: [function (t, n, r) {
                t(111)("Uint16", 2, function (t) {
                    return function Uint16Array(n, r, e) {
                        return t(this, n, r, e);
                    };
                });
            }, { 111: 111 }], 252: [function (t, n, r) {
                t(111)("Uint32", 4, function (t) {
                    return function Uint32Array(n, r, e) {
                        return t(this, n, r, e);
                    };
                });
            }, { 111: 111 }], 253: [function (t, n, r) {
                t(111)("Uint8", 1, function (t) {
                    return function Uint8Array(n, r, e) {
                        return t(this, n, r, e);
                    };
                });
            }, { 111: 111 }], 254: [function (t, n, r) {
                t(111)("Uint8", 1, function (t) {
                    return function Uint8ClampedArray(n, r, e) {
                        return t(this, n, r, e);
                    };
                }, !0);
            }, { 111: 111 }], 255: [function (t, n, r) {
                "use strict";
                var e,
                    i = t(12)(0),
                    o = t(87),
                    u = t(62),
                    c = t(65),
                    f = t(21),
                    a = t(49),
                    s = u.getWeak,
                    l = Object.isExtensible,
                    h = f.ufstore,
                    v = {},
                    p = function p(t) {
                    return function WeakMap() {
                        return t(this, arguments.length > 0 ? arguments[0] : void 0);
                    };
                },
                    d = { get: function get(t) {
                        if (a(t)) {
                            var n = s(t);return n === !0 ? h(this).get(t) : n ? n[this._i] : void 0;
                        }
                    }, set: function set(t, n) {
                        return f.def(this, t, n);
                    } },
                    y = n.exports = t(22)("WeakMap", p, d, f, !0, !0);7 != new y().set((Object.freeze || Object)(v), 7).get(v) && (e = f.getConstructor(p), c(e.prototype, d), u.NEED = !0, i(["delete", "has", "get", "set"], function (t) {
                    var n = y.prototype,
                        r = n[t];o(n, t, function (n, i) {
                        if (a(n) && !l(n)) {
                            this._f || (this._f = new e());var o = this._f[t](n, i);return "set" == t ? this : o;
                        }return r.call(this, n, i);
                    });
                }));
            }, { 12: 12, 21: 21, 22: 22, 49: 49, 62: 62, 65: 65, 87: 87 }], 256: [function (t, n, r) {
                "use strict";
                var e = t(21);t(22)("WeakSet", function (t) {
                    return function WeakSet() {
                        return t(this, arguments.length > 0 ? arguments[0] : void 0);
                    };
                }, { add: function add(t) {
                        return e.def(this, t, !0);
                    } }, e, !1, !0);
            }, { 21: 21, 22: 22 }], 257: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(11)(!0);e(e.P, "Array", { includes: function includes(t) {
                        return i(this, t, arguments.length > 1 ? arguments[1] : void 0);
                    } }), t(5)("includes");
            }, { 11: 11, 32: 32, 5: 5 }], 258: [function (t, n, r) {
                var e = t(32),
                    i = t(64)(),
                    o = t(38).process,
                    u = "process" == t(18)(o);e(e.G, { asap: function asap(t) {
                        var n = u && o.domain;i(n ? n.bind(t) : t);
                    } });
            }, { 18: 18, 32: 32, 38: 38, 64: 64 }], 259: [function (t, n, r) {
                var e = t(32),
                    i = t(18);e(e.S, "Error", { isError: function isError(t) {
                        return "Error" === i(t);
                    } });
            }, { 18: 18, 32: 32 }], 260: [function (t, n, r) {
                var e = t(32);e(e.P + e.R, "Map", { toJSON: t(20)("Map") });
            }, { 20: 20, 32: 32 }], 261: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { iaddh: function iaddh(t, n, r, e) {
                        var i = t >>> 0,
                            o = n >>> 0,
                            u = r >>> 0;return o + (e >>> 0) + ((i & u | (i | u) & ~(i + u >>> 0)) >>> 31) | 0;
                    } });
            }, { 32: 32 }], 262: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { imulh: function imulh(t, n) {
                        var r = 65535,
                            e = +t,
                            i = +n,
                            o = e & r,
                            u = i & r,
                            c = e >> 16,
                            f = i >> 16,
                            a = (c * u >>> 0) + (o * u >>> 16);return c * f + (a >> 16) + ((o * f >>> 0) + (a & r) >> 16);
                    } });
            }, { 32: 32 }], 263: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { isubh: function isubh(t, n, r, e) {
                        var i = t >>> 0,
                            o = n >>> 0,
                            u = r >>> 0;return o - (e >>> 0) - ((~i & u | ~(i ^ u) & i - u >>> 0) >>> 31) | 0;
                    } });
            }, { 32: 32 }], 264: [function (t, n, r) {
                var e = t(32);e(e.S, "Math", { umulh: function umulh(t, n) {
                        var r = 65535,
                            e = +t,
                            i = +n,
                            o = e & r,
                            u = i & r,
                            c = e >>> 16,
                            f = i >>> 16,
                            a = (c * u >>> 0) + (o * u >>> 16);return c * f + (a >>> 16) + ((o * f >>> 0) + (a & r) >>> 16);
                    } });
            }, { 32: 32 }], 265: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(109),
                    o = t(3),
                    u = t(67);t(28) && e(e.P + t(69), "Object", { __defineGetter__: function __defineGetter__(t, n) {
                        u.f(i(this), t, { get: o(n), enumerable: !0, configurable: !0 });
                    } });
            }, { 109: 109, 28: 28, 3: 3, 32: 32, 67: 67, 69: 69 }], 266: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(109),
                    o = t(3),
                    u = t(67);t(28) && e(e.P + t(69), "Object", { __defineSetter__: function __defineSetter__(t, n) {
                        u.f(i(this), t, { set: o(n), enumerable: !0, configurable: !0 });
                    } });
            }, { 109: 109, 28: 28, 3: 3, 32: 32, 67: 67, 69: 69 }], 267: [function (t, n, r) {
                var e = t(32),
                    i = t(79)(!0);e(e.S, "Object", { entries: function entries(t) {
                        return i(t);
                    } });
            }, { 32: 32, 79: 79 }], 268: [function (t, n, r) {
                var e = t(32),
                    i = t(80),
                    o = t(107),
                    u = t(70),
                    c = t(24);e(e.S, "Object", { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(t) {
                        for (var n, r = o(t), e = u.f, f = i(r), a = {}, s = 0; f.length > s;) {
                            c(a, n = f[s++], e(r, n));
                        }return a;
                    } });
            }, { 107: 107, 24: 24, 32: 32, 70: 70, 80: 80 }], 269: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(109),
                    o = t(110),
                    u = t(74),
                    c = t(70).f;t(28) && e(e.P + t(69), "Object", { __lookupGetter__: function __lookupGetter__(t) {
                        var n,
                            r = i(this),
                            e = o(t, !0);do {
                            if (n = c(r, e)) return n.get;
                        } while (r = u(r));
                    } });
            }, { 109: 109, 110: 110, 28: 28, 32: 32, 69: 69, 70: 70, 74: 74 }], 270: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(109),
                    o = t(110),
                    u = t(74),
                    c = t(70).f;t(28) && e(e.P + t(69), "Object", { __lookupSetter__: function __lookupSetter__(t) {
                        var n,
                            r = i(this),
                            e = o(t, !0);do {
                            if (n = c(r, e)) return n.set;
                        } while (r = u(r));
                    } });
            }, { 109: 109, 110: 110, 28: 28, 32: 32, 69: 69, 70: 70, 74: 74 }], 271: [function (t, n, r) {
                var e = t(32),
                    i = t(79)(!1);e(e.S, "Object", { values: function values(t) {
                        return i(t);
                    } });
            }, { 32: 32, 79: 79 }], 272: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(38),
                    o = t(23),
                    u = t(64)(),
                    c = t(117)("observable"),
                    f = t(3),
                    a = t(7),
                    s = t(6),
                    l = t(86),
                    h = t(40),
                    v = t(37),
                    p = v.RETURN,
                    d = function d(t) {
                    return null == t ? void 0 : f(t);
                },
                    y = function y(t) {
                    var n = t._c;n && (t._c = void 0, n());
                },
                    g = function g(t) {
                    return void 0 === t._o;
                },
                    b = function b(t) {
                    g(t) || (t._o = void 0, y(t));
                },
                    x = function x(t, n) {
                    a(t), this._c = void 0, this._o = t, t = new m(this);try {
                        var r = n(t),
                            e = r;null != r && ("function" == typeof r.unsubscribe ? r = function r() {
                            e.unsubscribe();
                        } : f(r), this._c = r);
                    } catch (n) {
                        return void t.error(n);
                    }g(this) && y(this);
                };x.prototype = l({}, { unsubscribe: function unsubscribe() {
                        b(this);
                    } });var m = function m(t) {
                    this._s = t;
                };m.prototype = l({}, { next: function next(t) {
                        var n = this._s;if (!g(n)) {
                            var r = n._o;try {
                                var e = d(r.next);if (e) return e.call(r, t);
                            } catch (t) {
                                try {
                                    b(n);
                                } finally {
                                    throw t;
                                }
                            }
                        }
                    }, error: function error(t) {
                        var n = this._s;if (g(n)) throw t;var r = n._o;n._o = void 0;try {
                            var e = d(r.error);if (!e) throw t;t = e.call(r, t);
                        } catch (t) {
                            try {
                                y(n);
                            } finally {
                                throw t;
                            }
                        }return y(n), t;
                    }, complete: function complete(t) {
                        var n = this._s;if (!g(n)) {
                            var r = n._o;n._o = void 0;try {
                                var e = d(r.complete);t = e ? e.call(r, t) : void 0;
                            } catch (t) {
                                try {
                                    y(n);
                                } finally {
                                    throw t;
                                }
                            }return y(n), t;
                        }
                    } });var w = function Observable(t) {
                    s(this, w, "Observable", "_f")._f = f(t);
                };l(w.prototype, { subscribe: function subscribe(t) {
                        return new x(t, this._f);
                    }, forEach: function forEach(t) {
                        var n = this;return new (o.Promise || i.Promise)(function (r, e) {
                            f(t);var i = n.subscribe({ next: function next(n) {
                                    try {
                                        return t(n);
                                    } catch (t) {
                                        e(t), i.unsubscribe();
                                    }
                                }, error: e, complete: r });
                        });
                    } }), l(w, { from: function from(t) {
                        var n = "function" == typeof this ? this : w,
                            r = d(a(t)[c]);if (r) {
                            var e = a(r.call(t));return e.constructor === n ? e : new n(function (t) {
                                return e.subscribe(t);
                            });
                        }return new n(function (n) {
                            var r = !1;return u(function () {
                                if (!r) {
                                    try {
                                        if (v(t, !1, function (t) {
                                            if (n.next(t), r) return p;
                                        }) === p) return;
                                    } catch (t) {
                                        if (r) throw t;return void n.error(t);
                                    }n.complete();
                                }
                            }), function () {
                                r = !0;
                            };
                        });
                    }, of: function of() {
                        for (var t = 0, n = arguments.length, r = Array(n); t < n;) {
                            r[t] = arguments[t++];
                        }return new ("function" == typeof this ? this : w)(function (t) {
                            var n = !1;return u(function () {
                                if (!n) {
                                    for (var e = 0; e < r.length; ++e) {
                                        if (t.next(r[e]), n) return;
                                    }t.complete();
                                }
                            }), function () {
                                n = !0;
                            };
                        });
                    } }), h(w.prototype, c, function () {
                    return this;
                }), e(e.G, { Observable: w }), t(91)("Observable");
            }, { 117: 117, 23: 23, 3: 3, 32: 32, 37: 37, 38: 38, 40: 40, 6: 6, 64: 64, 7: 7, 86: 86, 91: 91 }], 273: [function (t, n, r) {
                var e = t(63),
                    i = t(7),
                    o = e.key,
                    u = e.set;e.exp({ defineMetadata: function defineMetadata(t, n, r, e) {
                        u(t, n, i(r), o(e));
                    } });
            }, { 63: 63, 7: 7 }], 274: [function (t, n, r) {
                var e = t(63),
                    i = t(7),
                    o = e.key,
                    u = e.map,
                    c = e.store;e.exp({ deleteMetadata: function deleteMetadata(t, n) {
                        var r = arguments.length < 3 ? void 0 : o(arguments[2]),
                            e = u(i(n), r, !1);if (void 0 === e || !e.delete(t)) return !1;if (e.size) return !0;var f = c.get(n);return f.delete(r), !!f.size || c.delete(n);
                    } });
            }, { 63: 63, 7: 7 }], 275: [function (t, n, r) {
                var e = t(220),
                    i = t(10),
                    o = t(63),
                    u = t(7),
                    c = t(74),
                    f = o.keys,
                    a = o.key,
                    s = function s(t, n) {
                    var r = f(t, n),
                        o = c(t);if (null === o) return r;var u = s(o, n);return u.length ? r.length ? i(new e(r.concat(u))) : u : r;
                };o.exp({ getMetadataKeys: function getMetadataKeys(t) {
                        return s(u(t), arguments.length < 2 ? void 0 : a(arguments[1]));
                    } });
            }, { 10: 10, 220: 220, 63: 63, 7: 7, 74: 74 }], 276: [function (t, n, r) {
                var e = t(63),
                    i = t(7),
                    o = t(74),
                    u = e.has,
                    c = e.get,
                    f = e.key,
                    a = function a(t, n, r) {
                    var e = u(t, n, r);if (e) return c(t, n, r);var i = o(n);return null !== i ? a(t, i, r) : void 0;
                };e.exp({ getMetadata: function getMetadata(t, n) {
                        return a(t, i(n), arguments.length < 3 ? void 0 : f(arguments[2]));
                    } });
            }, { 63: 63, 7: 7, 74: 74 }], 277: [function (t, n, r) {
                var e = t(63),
                    i = t(7),
                    o = e.keys,
                    u = e.key;e.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(t) {
                        return o(i(t), arguments.length < 2 ? void 0 : u(arguments[1]));
                    } });
            }, { 63: 63, 7: 7 }], 278: [function (t, n, r) {
                var e = t(63),
                    i = t(7),
                    o = e.get,
                    u = e.key;e.exp({ getOwnMetadata: function getOwnMetadata(t, n) {
                        return o(t, i(n), arguments.length < 3 ? void 0 : u(arguments[2]));
                    } });
            }, { 63: 63, 7: 7 }], 279: [function (t, n, r) {
                var e = t(63),
                    i = t(7),
                    o = t(74),
                    u = e.has,
                    c = e.key,
                    f = function f(t, n, r) {
                    var e = u(t, n, r);if (e) return !0;var i = o(n);return null !== i && f(t, i, r);
                };e.exp({ hasMetadata: function hasMetadata(t, n) {
                        return f(t, i(n), arguments.length < 3 ? void 0 : c(arguments[2]));
                    } });
            }, { 63: 63, 7: 7, 74: 74 }], 280: [function (t, n, r) {
                var e = t(63),
                    i = t(7),
                    o = e.has,
                    u = e.key;e.exp({ hasOwnMetadata: function hasOwnMetadata(t, n) {
                        return o(t, i(n), arguments.length < 3 ? void 0 : u(arguments[2]));
                    } });
            }, { 63: 63, 7: 7 }], 281: [function (t, n, r) {
                var e = t(63),
                    i = t(7),
                    o = t(3),
                    u = e.key,
                    c = e.set;e.exp({ metadata: function metadata(t, n) {
                        return function decorator(r, e) {
                            c(t, n, (void 0 !== e ? i : o)(r), u(e));
                        };
                    } });
            }, { 3: 3, 63: 63, 7: 7 }], 282: [function (t, n, r) {
                var e = t(32);e(e.P + e.R, "Set", { toJSON: t(20)("Set") });
            }, { 20: 20, 32: 32 }], 283: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(97)(!0);e(e.P, "String", { at: function at(t) {
                        return i(this, t);
                    } });
            }, { 32: 32, 97: 97 }], 284: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(27),
                    o = t(108),
                    u = t(50),
                    c = t(36),
                    f = RegExp.prototype,
                    a = function a(t, n) {
                    this._r = t, this._s = n;
                };t(52)(a, "RegExp String", function next() {
                    var t = this._r.exec(this._s);return { value: t, done: null === t };
                }), e(e.P, "String", { matchAll: function matchAll(t) {
                        if (i(this), !u(t)) throw TypeError(t + " is not a regexp!");var n = String(this),
                            r = "flags" in f ? String(t.flags) : c.call(t),
                            e = new RegExp(t.source, ~r.indexOf("g") ? r : "g" + r);return e.lastIndex = o(t.lastIndex), new a(e, n);
                    } });
            }, { 108: 108, 27: 27, 32: 32, 36: 36, 50: 50, 52: 52 }], 285: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(100);e(e.P, "String", { padEnd: function padEnd(t) {
                        return i(this, t, arguments.length > 1 ? arguments[1] : void 0, !1);
                    } });
            }, { 100: 100, 32: 32 }], 286: [function (t, n, r) {
                "use strict";
                var e = t(32),
                    i = t(100);e(e.P, "String", { padStart: function padStart(t) {
                        return i(this, t, arguments.length > 1 ? arguments[1] : void 0, !0);
                    } });
            }, { 100: 100, 32: 32 }], 287: [function (t, n, r) {
                "use strict";
                t(102)("trimLeft", function (t) {
                    return function trimLeft() {
                        return t(this, 1);
                    };
                }, "trimStart");
            }, { 102: 102 }], 288: [function (t, n, r) {
                "use strict";
                t(102)("trimRight", function (t) {
                    return function trimRight() {
                        return t(this, 2);
                    };
                }, "trimEnd");
            }, { 102: 102 }], 289: [function (t, n, r) {
                t(115)("asyncIterator");
            }, { 115: 115 }], 290: [function (t, n, r) {
                t(115)("observable");
            }, { 115: 115 }], 291: [function (t, n, r) {
                var e = t(32);e(e.S, "System", { global: t(38) });
            }, { 32: 32, 38: 38 }], 292: [function (t, n, r) {
                for (var e = t(130), i = t(87), o = t(38), u = t(40), c = t(56), f = t(117), a = f("iterator"), s = f("toStringTag"), l = c.Array, h = ["NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList"], v = 0; v < 5; v++) {
                    var p,
                        d = h[v],
                        y = o[d],
                        g = y && y.prototype;if (g) {
                        g[a] || u(g, a, l), g[s] || u(g, s, d), c[d] = l;for (p in e) {
                            g[p] || i(g, p, e[p], !0);
                        }
                    }
                }
            }, { 117: 117, 130: 130, 38: 38, 40: 40, 56: 56, 87: 87 }], 293: [function (t, n, r) {
                var e = t(32),
                    i = t(104);e(e.G + e.B, { setImmediate: i.set, clearImmediate: i.clear });
            }, { 104: 104, 32: 32 }], 294: [function (t, n, r) {
                var e = t(38),
                    i = t(32),
                    o = t(44),
                    u = t(83),
                    c = e.navigator,
                    f = !!c && /MSIE .\./.test(c.userAgent),
                    a = function a(t) {
                    return f ? function (n, r) {
                        return t(o(u, [].slice.call(arguments, 2), "function" == typeof n ? n : Function(n)), r);
                    } : t;
                };i(i.G + i.B + i.F * f, { setTimeout: a(e.setTimeout), setInterval: a(e.setInterval) });
            }, { 32: 32, 38: 38, 44: 44, 83: 83 }], 295: [function (t, n, r) {
                t(243), t(180), t(182), t(181), t(184), t(186), t(191), t(185), t(183), t(193), t(192), t(188), t(189), t(187), t(179), t(190), t(194), t(195), t(146), t(148), t(147), t(197), t(196), t(167), t(177), t(178), t(168), t(169), t(170), t(171), t(172), t(173), t(174), t(175), t(176), t(150), t(151), t(152), t(153), t(154), t(155), t(156), t(157), t(158), t(159), t(160), t(161), t(162), t(163), t(164), t(165), t(166), t(230), t(235), t(242), t(233), t(225), t(226), t(231), t(236), t(238), t(221), t(222), t(223), t(224), t(227), t(228), t(229), t(232), t(234), t(237), t(239), t(240), t(241), t(141), t(143), t(142), t(145), t(144), t(129), t(127), t(134), t(131), t(137), t(139), t(126), t(133), t(123), t(138), t(121), t(136), t(135), t(128), t(132), t(120), t(122), t(125), t(124), t(140), t(130), t(213), t(219), t(214), t(215), t(216), t(217), t(218), t(198), t(149), t(220), t(255), t(256), t(244), t(245), t(250), t(253), t(254), t(248), t(251), t(249), t(252), t(246), t(247), t(199), t(200), t(201), t(202), t(203), t(206), t(204), t(205), t(207), t(208), t(209), t(210), t(212), t(211), t(257), t(283), t(286), t(285), t(287), t(288), t(284), t(289), t(290), t(268), t(271), t(267), t(265), t(266), t(269), t(270), t(260), t(282), t(291), t(259), t(261), t(263), t(262), t(264), t(273), t(274), t(276), t(275), t(278), t(277), t(279), t(280), t(281), t(258), t(272), t(294), t(293), t(292), n.exports = t(23);
            }, { 120: 120, 121: 121, 122: 122, 123: 123, 124: 124, 125: 125, 126: 126, 127: 127, 128: 128, 129: 129, 130: 130, 131: 131, 132: 132, 133: 133, 134: 134, 135: 135, 136: 136, 137: 137, 138: 138, 139: 139, 140: 140, 141: 141, 142: 142, 143: 143, 144: 144, 145: 145, 146: 146, 147: 147, 148: 148, 149: 149, 150: 150, 151: 151, 152: 152, 153: 153, 154: 154, 155: 155, 156: 156, 157: 157, 158: 158, 159: 159, 160: 160, 161: 161, 162: 162, 163: 163, 164: 164, 165: 165, 166: 166, 167: 167, 168: 168, 169: 169, 170: 170, 171: 171, 172: 172, 173: 173, 174: 174, 175: 175, 176: 176, 177: 177, 178: 178, 179: 179, 180: 180, 181: 181, 182: 182, 183: 183, 184: 184, 185: 185, 186: 186, 187: 187, 188: 188, 189: 189, 190: 190, 191: 191, 192: 192, 193: 193, 194: 194, 195: 195, 196: 196, 197: 197, 198: 198, 199: 199, 200: 200, 201: 201, 202: 202, 203: 203, 204: 204, 205: 205, 206: 206, 207: 207, 208: 208, 209: 209, 210: 210, 211: 211, 212: 212, 213: 213, 214: 214, 215: 215, 216: 216, 217: 217, 218: 218, 219: 219, 220: 220, 221: 221, 222: 222, 223: 223, 224: 224, 225: 225, 226: 226, 227: 227, 228: 228, 229: 229, 23: 23, 230: 230, 231: 231, 232: 232, 233: 233, 234: 234, 235: 235, 236: 236, 237: 237, 238: 238, 239: 239, 240: 240, 241: 241, 242: 242, 243: 243, 244: 244, 245: 245, 246: 246, 247: 247, 248: 248, 249: 249, 250: 250, 251: 251, 252: 252, 253: 253, 254: 254, 255: 255, 256: 256, 257: 257, 258: 258, 259: 259, 260: 260, 261: 261, 262: 262, 263: 263, 264: 264, 265: 265, 266: 266, 267: 267, 268: 268, 269: 269, 270: 270, 271: 271, 272: 272, 273: 273, 274: 274, 275: 275, 276: 276, 277: 277, 278: 278, 279: 279, 280: 280, 281: 281, 282: 282, 283: 283, 284: 284, 285: 285, 286: 286, 287: 287, 288: 288, 289: 289, 290: 290, 291: 291, 292: 292, 293: 293, 294: 294 }], 296: [function (t, n, r) {
                (function (t) {
                    !function (t) {
                        "use strict";
                        function wrap(t, n, r, e) {
                            var i = n && n.prototype instanceof Generator ? n : Generator,
                                o = Object.create(i.prototype),
                                u = new Context(e || []);return o._invoke = makeInvokeMethod(t, r, u), o;
                        }function tryCatch(t, n, r) {
                            try {
                                return { type: "normal", arg: t.call(n, r) };
                            } catch (t) {
                                return { type: "throw", arg: t };
                            }
                        }function Generator() {}function GeneratorFunction() {}function GeneratorFunctionPrototype() {}function defineIteratorMethods(t) {
                            ["next", "throw", "return"].forEach(function (n) {
                                t[n] = function (t) {
                                    return this._invoke(n, t);
                                };
                            });
                        }function AsyncIterator(t) {
                            function invoke(n, r, e, o) {
                                var u = tryCatch(t[n], t, r);if ("throw" !== u.type) {
                                    var c = u.arg,
                                        f = c.value;return f && "object" == (typeof f === 'undefined' ? 'undefined' : _typeof(f)) && i.call(f, "__await") ? Promise.resolve(f.__await).then(function (t) {
                                        invoke("next", t, e, o);
                                    }, function (t) {
                                        invoke("throw", t, e, o);
                                    }) : Promise.resolve(f).then(function (t) {
                                        c.value = t, e(c);
                                    }, o);
                                }o(u.arg);
                            }function enqueue(t, r) {
                                function callInvokeWithMethodAndArg() {
                                    return new Promise(function (n, e) {
                                        invoke(t, r, n, e);
                                    });
                                }return n = n ? n.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                            }"object" == (typeof process === 'undefined' ? 'undefined' : _typeof(process)) && process.domain && (invoke = process.domain.bind(invoke));var n;this._invoke = enqueue;
                        }function makeInvokeMethod(t, n, e) {
                            var i = s;return function invoke(o, u) {
                                if (i === h) throw new Error("Generator is already running");if (i === v) {
                                    if ("throw" === o) throw u;return doneResult();
                                }for (;;) {
                                    var c = e.delegate;if (c) {
                                        if ("return" === o || "throw" === o && c.iterator[o] === r) {
                                            e.delegate = null;var f = c.iterator.return;if (f) {
                                                var a = tryCatch(f, c.iterator, u);if ("throw" === a.type) {
                                                    o = "throw", u = a.arg;continue;
                                                }
                                            }if ("return" === o) continue;
                                        }var a = tryCatch(c.iterator[o], c.iterator, u);if ("throw" === a.type) {
                                            e.delegate = null, o = "throw", u = a.arg;continue;
                                        }o = "next", u = r;var d = a.arg;if (!d.done) return i = l, d;e[c.resultName] = d.value, e.next = c.nextLoc, e.delegate = null;
                                    }if ("next" === o) e.sent = e._sent = u;else if ("throw" === o) {
                                        if (i === s) throw i = v, u;e.dispatchException(u) && (o = "next", u = r);
                                    } else "return" === o && e.abrupt("return", u);i = h;var a = tryCatch(t, n, e);if ("normal" === a.type) {
                                        i = e.done ? v : l;var d = { value: a.arg, done: e.done };if (a.arg !== p) return d;e.delegate && "next" === o && (u = r);
                                    } else "throw" === a.type && (i = v, o = "throw", u = a.arg);
                                }
                            };
                        }function pushTryEntry(t) {
                            var n = { tryLoc: t[0] };1 in t && (n.catchLoc = t[1]), 2 in t && (n.finallyLoc = t[2], n.afterLoc = t[3]), this.tryEntries.push(n);
                        }function resetTryEntry(t) {
                            var n = t.completion || {};n.type = "normal", delete n.arg, t.completion = n;
                        }function Context(t) {
                            this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0);
                        }function values(t) {
                            if (t) {
                                var n = t[u];if (n) return n.call(t);if ("function" == typeof t.next) return t;if (!isNaN(t.length)) {
                                    var e = -1,
                                        o = function next() {
                                        for (; ++e < t.length;) {
                                            if (i.call(t, e)) return next.value = t[e], next.done = !1, next;
                                        }return next.value = r, next.done = !0, next;
                                    };return o.next = o;
                                }
                            }return { next: doneResult };
                        }function doneResult() {
                            return { value: r, done: !0 };
                        }var r,
                            e = Object.prototype,
                            i = e.hasOwnProperty,
                            o = "function" == typeof Symbol ? Symbol : {},
                            u = o.iterator || "@@iterator",
                            c = o.toStringTag || "@@toStringTag",
                            f = "object" == (typeof n === 'undefined' ? 'undefined' : _typeof(n)),
                            a = t.regeneratorRuntime;if (a) return void (f && (n.exports = a));a = t.regeneratorRuntime = f ? n.exports : {}, a.wrap = wrap;var s = "suspendedStart",
                            l = "suspendedYield",
                            h = "executing",
                            v = "completed",
                            p = {},
                            d = {};d[u] = function () {
                            return this;
                        };var y = Object.getPrototypeOf,
                            g = y && y(y(values([])));g && g !== e && i.call(g, u) && (d = g);var b = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(d);GeneratorFunction.prototype = b.constructor = GeneratorFunctionPrototype, GeneratorFunctionPrototype.constructor = GeneratorFunction, GeneratorFunctionPrototype[c] = GeneratorFunction.displayName = "GeneratorFunction", a.isGeneratorFunction = function (t) {
                            var n = "function" == typeof t && t.constructor;return !!n && (n === GeneratorFunction || "GeneratorFunction" === (n.displayName || n.name));
                        }, a.mark = function (t) {
                            return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c in t || (t[c] = "GeneratorFunction")), t.prototype = Object.create(b), t;
                        }, a.awrap = function (t) {
                            return { __await: t };
                        }, defineIteratorMethods(AsyncIterator.prototype), a.AsyncIterator = AsyncIterator, a.async = function (t, n, r, e) {
                            var i = new AsyncIterator(wrap(t, n, r, e));return a.isGeneratorFunction(n) ? i : i.next().then(function (t) {
                                return t.done ? t.value : i.next();
                            });
                        }, defineIteratorMethods(b), b[c] = "Generator", b.toString = function () {
                            return "[object Generator]";
                        }, a.keys = function (t) {
                            var n = [];for (var r in t) {
                                n.push(r);
                            }return n.reverse(), function next() {
                                for (; n.length;) {
                                    var r = n.pop();if (r in t) return next.value = r, next.done = !1, next;
                                }return next.done = !0, next;
                            };
                        }, a.values = values, Context.prototype = { constructor: Context, reset: function reset(t) {
                                if (this.prev = 0, this.next = 0, this.sent = this._sent = r, this.done = !1, this.delegate = null, this.tryEntries.forEach(resetTryEntry), !t) for (var n in this) {
                                    "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = r);
                                }
                            }, stop: function stop() {
                                this.done = !0;var t = this.tryEntries[0],
                                    n = t.completion;if ("throw" === n.type) throw n.arg;return this.rval;
                            }, dispatchException: function dispatchException(t) {
                                function handle(r, e) {
                                    return o.type = "throw", o.arg = t, n.next = r, !!e;
                                }if (this.done) throw t;for (var n = this, r = this.tryEntries.length - 1; r >= 0; --r) {
                                    var e = this.tryEntries[r],
                                        o = e.completion;
                                    if ("root" === e.tryLoc) return handle("end");if (e.tryLoc <= this.prev) {
                                        var u = i.call(e, "catchLoc"),
                                            c = i.call(e, "finallyLoc");if (u && c) {
                                            if (this.prev < e.catchLoc) return handle(e.catchLoc, !0);if (this.prev < e.finallyLoc) return handle(e.finallyLoc);
                                        } else if (u) {
                                            if (this.prev < e.catchLoc) return handle(e.catchLoc, !0);
                                        } else {
                                            if (!c) throw new Error("try statement without catch or finally");if (this.prev < e.finallyLoc) return handle(e.finallyLoc);
                                        }
                                    }
                                }
                            }, abrupt: function abrupt(t, n) {
                                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                                    var e = this.tryEntries[r];if (e.tryLoc <= this.prev && i.call(e, "finallyLoc") && this.prev < e.finallyLoc) {
                                        var o = e;break;
                                    }
                                }o && ("break" === t || "continue" === t) && o.tryLoc <= n && n <= o.finallyLoc && (o = null);var u = o ? o.completion : {};return u.type = t, u.arg = n, o ? this.next = o.finallyLoc : this.complete(u), p;
                            }, complete: function complete(t, n) {
                                if ("throw" === t.type) throw t.arg;"break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = t.arg, this.next = "end") : "normal" === t.type && n && (this.next = n);
                            }, finish: function finish(t) {
                                for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                    var r = this.tryEntries[n];if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), p;
                                }
                            }, catch: function _catch(t) {
                                for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                    var r = this.tryEntries[n];if (r.tryLoc === t) {
                                        var e = r.completion;if ("throw" === e.type) {
                                            var i = e.arg;resetTryEntry(r);
                                        }return i;
                                    }
                                }throw new Error("illegal catch attempt");
                            }, delegateYield: function delegateYield(t, n, r) {
                                return this.delegate = { iterator: values(t), resultName: n, nextLoc: r }, p;
                            } };
                    }("object" == (typeof t === 'undefined' ? 'undefined' : _typeof(t)) ? t : "object" == (typeof window === 'undefined' ? 'undefined' : _typeof(window)) ? window : "object" == (typeof self === 'undefined' ? 'undefined' : _typeof(self)) ? self : this);
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
            }, {}] }, {}, [1]);

        /* WEBPACK VAR INJECTION */
    }).call(exports, __webpack_require__(53), __webpack_require__(54));

    /***/
},
/* 53 */
/***/function (module, exports) {

    var g;

    // This works in non-strict mode
    g = function () {
        return this;
    }();

    try {
        // This works if eval is allowed (see CSP)
        g = g || Function("return this")() || (1, eval)("this");
    } catch (e) {
        // This works if the window reference is available
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === "object") g = window;
    }

    // g can still be undefined, but nothing to do about it...
    // We return undefined, instead of nothing here, so it's
    // easier to handle this case. if(!global) { ...}

    module.exports = g;

    /***/
},
/* 54 */
/***/function (module, exports) {

    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    })();
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) {
        return [];
    };

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };

    /***/
},
/* 55 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (binding) */
    __webpack_require__.d(__webpack_exports__, "a", function () {
        return Game;
    });
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__library_managers_signalmanager__ = __webpack_require__(18);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__library_system_basegame__ = __webpack_require__(56);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__library_utilities_settings__ = __webpack_require__(9);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__library_utilities_genfunc__ = __webpack_require__(3);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__library_managers_shadermanager__ = __webpack_require__(15);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__state_startupstate__ = __webpack_require__(62);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__state_titlescreenstate__ = __webpack_require__(36);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__state_loadstate__ = __webpack_require__(97);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__state_runstate__ = __webpack_require__(50);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__smartGUI_smartconfirmbtn__ = __webpack_require__(101);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__state_gamestate__ = __webpack_require__(22);

    // 
    //  FILE NAME: game.js
    //  DESC:      CGame class
    //


    var Game = function (_WEBPACK_IMPORTED_MO15) {
        _inherits(Game, _WEBPACK_IMPORTED_MO15);

        function Game() {
            _classCallCheck(this, Game);

            // Set the shader init callback
            var _this28 = _possibleConstructorReturn(this, (Game.__proto__ || Object.getPrototypeOf(Game)).call(this));

            __WEBPACK_IMPORTED_MODULE_4__library_managers_shadermanager__["a" /* shaderManager */].initShaderCallback = _this28.shaderInitCallBack.bind(_this28);

            // Set the smart gui call back
            __WEBPACK_IMPORTED_MODULE_0__library_managers_signalmanager__["a" /* signalManager */].connect_smartGui(_this28.smartGuiControlCreateCallBack.bind(_this28));

            // Load the settings
            Object(__WEBPACK_IMPORTED_MODULE_3__library_utilities_genfunc__["b" /* downloadFile */])('xml', 'data/settings/settings.cfg', function (xmlNode) {
                __WEBPACK_IMPORTED_MODULE_2__library_utilities_settings__["a" /* settings */].load(xmlNode);
                _this28.init();
            });
            return _this28;
        }

        // 
        //  DESC: Init the game
        //


        _createClass(Game, [{
            key: 'init',
            value: function init() {
                _get(Game.prototype.__proto__ || Object.getPrototypeOf(Game.prototype), 'init', this).call(this);

                // Create the startup state
                this.gameState = new __WEBPACK_IMPORTED_MODULE_5__state_startupstate__["a" /* StartUpState */](this.gameLoop.bind(this));
                this.gameState.init();
            }

            // 
            //  DESC: Callback for when a smart gui control is created
            //

        }, {
            key: 'smartGuiControlCreateCallBack',
            value: function smartGuiControlCreateCallBack(control) {
                if (control.faction === "decision_btn") control.smartGui = new __WEBPACK_IMPORTED_MODULE_9__smartGUI_smartconfirmbtn__["a" /* SmartConfirmBtn */](control);
            }

            // 
            //  DESC: Callback for shader init
            //

        }, {
            key: 'shaderInitCallBack',
            value: function shaderInitCallBack(shaderId) {
                __WEBPACK_IMPORTED_MODULE_4__library_managers_shadermanager__["a" /* shaderManager */].setShaderValue4fv(shaderId, 'additive', [0, 0, 0, 1]);
            }

            // 
            //  DESC: Handle the state change
            //

        }, {
            key: 'doStateChange',
            value: function doStateChange() {
                if (this.gameState.doStateChange()) {
                    this.gameState.cleanUp();

                    if (this.gameState.nextState === __WEBPACK_IMPORTED_MODULE_10__state_gamestate__["d" /* GAME_STATE_TITLESCREEN */]) this.gameState = new __WEBPACK_IMPORTED_MODULE_6__state_titlescreenstate__["a" /* TitleScreenState */](this.gameLoop.bind(this));else if (this.gameState.nextState === __WEBPACK_IMPORTED_MODULE_10__state_gamestate__["a" /* GAME_STATE_LOAD */]) this.gameState = new __WEBPACK_IMPORTED_MODULE_7__state_loadstate__["a" /* LoadState */](this.gameState.stateMessage, this.doStateChange.bind(this));else if (this.gameState.nextState === __WEBPACK_IMPORTED_MODULE_10__state_gamestate__["b" /* GAME_STATE_RUN */]) this.gameState = new __WEBPACK_IMPORTED_MODULE_8__state_runstate__["a" /* RunState */](this.gameLoop.bind(this));

                    // Do any pre-game loop init's
                    this.gameState.init();

                    return true;
                }

                return false;
            }

            // 
            //  DESC: Handle events
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                this.gameState.handleEvent(event);
            }

            // 
            //  DESC: Handle the physics
            //

        }, {
            key: 'physics',
            value: function physics() {
                this.gameState.physics();
            }

            // 
            //  DESC: Update animations
            //

        }, {
            key: 'update',
            value: function update() {
                this.gameState.update();
            }

            // 
            //  DESC: Transform game objects
            //

        }, {
            key: 'transform',
            value: function transform() {
                this.gameState.transform();
            }

            // 
            //  DESC: Render of game content
            //

        }, {
            key: 'preRender',
            value: function preRender() {
                this.gameState.preRender();
            }

            // 
            //  DESC: Render of content after post process effects
            //

        }, {
            key: 'postRender',
            value: function postRender() {
                this.gameState.postRender();
            }
        }]);

        return Game;
    }(__WEBPACK_IMPORTED_MODULE_1__library_system_basegame__["a" /* Basegame */]);

    /***/
},
/* 56 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__ = __webpack_require__(6);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__managers_meshmanager__ = __webpack_require__(29);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__managers_vertexbuffermanager__ = __webpack_require__(19);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__managers_shadermanager__ = __webpack_require__(15);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__utilities_settings__ = __webpack_require__(9);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__utilities_highresolutiontimer__ = __webpack_require__(8);

    // 
    //  FILE NAME: basegame.js
    //  DESC:      base game class
    //


    var Basegame = function () {
        function Basegame() {
            _classCallCheck(this, Basegame);

            this.clearBufferMask = 0;
        }

        // 
        //  DESC: Init the game
        //


        _createClass(Basegame, [{
            key: 'init',
            value: function init() {
                // Create the projection matrixes
                __WEBPACK_IMPORTED_MODULE_0__device__["a" /* device */].createProjMatrix();

                // Do we add stencil buffer
                if (__WEBPACK_IMPORTED_MODULE_6__utilities_settings__["a" /* settings */].createStencilBuffer) __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].stencilOp(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].KEEP, __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].KEEP, __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].REPLACE);

                // Depth testing is off by default. Enable it?
                if (__WEBPACK_IMPORTED_MODULE_6__utilities_settings__["a" /* settings */].enableDepthBuffer) __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].enable(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].DEPTH_TEST);

                // Init the clear color
                __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].clearColor(0.0, 0.0, 0.0, 1.0);

                // Init the stencil clear mask based on the bit size of the mask
                // Stencil buffer can only be 1 or 8 bits per pixel
                if (__WEBPACK_IMPORTED_MODULE_6__utilities_settings__["a" /* settings */].stencilBufferBitSize === 1) {
                    __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].stencilFunc(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].ALWAYS, 1, 0x1);
                    __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].stencilMask(0x1);
                } else if (__WEBPACK_IMPORTED_MODULE_6__utilities_settings__["a" /* settings */].stencilBufferBitSize === 8) {
                    __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].stencilFunc(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].ALWAYS, 1, 0xFF);
                    __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].stencilMask(0xff);
                }

                // Cull the back face
                __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].frontFace(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].CCW);
                __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].cullFace(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].BACK);
                __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].enable(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].CULL_FACE);

                // Enable alpha blending
                __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].enable(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].BLEND);
                __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].blendFunc(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].SRC_ALPHA, __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].ONE_MINUS_SRC_ALPHA);

                // Make the zero texture the active texture
                __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].activeTexture(__WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].TEXTURE0);

                // Init the clear buffer mask
                if (__WEBPACK_IMPORTED_MODULE_6__utilities_settings__["a" /* settings */].clearTargetBuffer) this.clearBufferMask |= __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].COLOR_BUFFER_BIT;

                if (__WEBPACK_IMPORTED_MODULE_6__utilities_settings__["a" /* settings */].enableDepthBuffer) this.clearBufferMask |= __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].DEPTH_BUFFER_BIT;

                if (__WEBPACK_IMPORTED_MODULE_6__utilities_settings__["a" /* settings */].clearStencilBuffer) this.clearBufferMask |= __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].STENCIL_BUFFER_BIT;

                __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].clear(this.clearBufferMask);
            }

            //
            //  DESC: Poll for game events
            //

        }, {
            key: 'pollEvents',
            value: function pollEvents() {
                var event = null;

                // Handle events on the queue
                while (event = __WEBPACK_IMPORTED_MODULE_5__managers_eventmanager__["a" /* eventManager */].pollEvent()) {
                    this.handleEvent(event);
                }
            }
        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                // Empty function to be overwritten
            }
        }, {
            key: 'doStateChange',
            value: function doStateChange() {
                // Empty function to be overwritten
            }
        }, {
            key: 'miscProcess',
            value: function miscProcess() {
                // Empty function to be overwritten
            }
        }, {
            key: 'physics',
            value: function physics() {
                // Empty function to be overwritten
            }
        }, {
            key: 'update',
            value: function update() {
                // Empty function to be overwritten
            }
        }, {
            key: 'transform',
            value: function transform() {
                // Empty function to be overwritten
            }
        }, {
            key: 'render',
            value: function render() {
                __WEBPACK_IMPORTED_MODULE_0__device__["b" /* gl */].clear(this.clearBufferMask);

                this.preRender();
                this.postRender();
            }
        }, {
            key: 'preRender',
            value: function preRender() {
                // Empty function to be overwritten
            }
        }, {
            key: 'postRender',
            value: function postRender() {}
            // Empty function to be overwritten


            // 
            //  DESC: Main game loop
            //

        }, {
            key: 'gameLoop',
            value: function gameLoop() {
                // Break out of the game loop and handle the state change
                if (this.doStateChange()) return;

                // Poll the events
                this.pollEvents();

                // Get our elapsed time
                __WEBPACK_IMPORTED_MODULE_7__utilities_highresolutiontimer__["a" /* highResTimer */].calcElapsedTime();

                // Handle any misc processing before the real work is started
                this.miscProcess();

                // Handle the physics
                this.physics();

                // Update animations, Move sprites, Check for collision
                this.update();

                // Transform game objects
                this.transform();

                // Do the rendering
                this.render();

                // Continues the loop
                requestAnimationFrame(this.gameLoop.bind(this));

                // Apparently it's a good practice to do this at the end of a render cycle
                __WEBPACK_IMPORTED_MODULE_4__managers_shadermanager__["a" /* shaderManager */].unbind();
                __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__["a" /* textureManager */].unbind();
                __WEBPACK_IMPORTED_MODULE_3__managers_vertexbuffermanager__["a" /* vertexBufferManager */].unbind();
                __WEBPACK_IMPORTED_MODULE_2__managers_meshmanager__["a" /* meshManager */].unbind();
            }
        }]);

        return Basegame;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Basegame;

    /***/
},
/* 57 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME:  uv.js
    //  DESC:       uv class
    //


    var UV = function () {
        function UV() {
            var u = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            _classCallCheck(this, UV);

            this.data = new Float32Array([u, v]);
        }

        _createClass(UV, [{
            key: 'u',
            set: function set(value) {
                this.data[0] = value;
            },
            get: function get() {
                return this.data[0];
            }
        }, {
            key: 'v',
            set: function set(value) {
                this.data[1] = value;
            },
            get: function get() {
                return this.data[1];
            }
        }]);

        return UV;
    }();
    /* unused harmony export UV */

    /***/
},
/* 58 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    //
    //  FILE NAME: meshbinaryfileheader.js
    //  DESC:      mesh binary file headers
    //


    // Hex for RSS (Rabbid Squirrel Sprite)

    var MESH_FILE_HEADER = 0x415382AE;
    /* harmony export (immutable) */__webpack_exports__["d"] = MESH_FILE_HEADER;

    // Hex for tag check
    var TAG_CHECK = 0x6A82Fc4d;
    /* harmony export (immutable) */__webpack_exports__["f"] = TAG_CHECK;

    // Max character sizes for the texture path and joint name
    var TEXT_PATH_SIZE = 128;
    /* harmony export (immutable) */__webpack_exports__["g"] = TEXT_PATH_SIZE;

    var JOINT_NAME_SIZE = 20;
    /* unused harmony export JOINT_NAME_SIZE */

    var MeshBinaryFileHeader = function MeshBinaryFileHeader() {
        _classCallCheck(this, MeshBinaryFileHeader);

        this.file_header = 0; // uint32
        this.vert_count = 0; // uint16
        this.uv_count = 0; // uint16
        this.vert_norm_count = 0; // uint16
        this.face_group_count = 0; // uint16
        this.text_count = 0; // uint16
        this.joint_count = 0; // uint16
    };
    /* harmony export (immutable) */

    __webpack_exports__["e"] = MeshBinaryFileHeader;

    // class for reading in texture info

    var BinaryTexture = function BinaryTexture() {
        _classCallCheck(this, BinaryTexture);

        this.type = 0; // int8
        this.path = ''; // file path [TEXT_PATH_SIZE]
    };
    /* harmony export (immutable) */

    __webpack_exports__["b"] = BinaryTexture;
    ;

    // Class for reading and writing the total face count within a group and the material
    // it belongs to

    var BinaryFaceGroup = function BinaryFaceGroup() {
        _classCallCheck(this, BinaryFaceGroup);

        this.groupFaceCount = 0; // uint16
        this.vertexBufCount = 0; // uint16
        this.indexBufCount = 0; // uint16
        this.textureCount = 0; // uint16
    };
    /* harmony export (immutable) */

    __webpack_exports__["a"] = BinaryFaceGroup;
    ;

    // Class for reading and writing face information

    var BinaryFace = function BinaryFace() {
        _classCallCheck(this, BinaryFace);

        this.vert = [];
        this.norm = [];
        this.uv = [];
    };
    /* unused harmony export BinaryFace */


    ;

    // Class for reading and writing face information

    var BinaryVertex = function BinaryVertex() {
        _classCallCheck(this, BinaryVertex);

        this.vert = 0;
        this.norm = 0;
        this.uv = 0;
    };
    /* harmony export (immutable) */

    __webpack_exports__["c"] = BinaryVertex;
    ;

    /***/
},
/* 59 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    //
    //  FILE NAME: mesh3d.js
    //  DESC:      3D mesh class
    //


    var MeshGroup = function MeshGroup() {
        _classCallCheck(this, MeshGroup);

        // Array texture paths for loading
        this.uniqueTexturePathAry = [];

        // Array of loaded textures
        this.meshAry = [];
    };
    /* harmony export (immutable) */

    __webpack_exports__["b"] = MeshGroup;

    var Mesh = function Mesh() {
        _classCallCheck(this, Mesh);

        // Texture indexes into the uniqueTexturePathAry
        this.textureIndexAry = [];

        // Loaded texture data
        this.textureAry = [];

        // VBO
        this.vbo = null;

        // IBO
        this.ibo = null;

        // Number of IBOs needed for rendering
        this.iboCount = 0;
    };
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Mesh;

    /***/
},
/* 60 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_vertex2d__ = __webpack_require__(26);

    // 
    //  FILE NAME:  quad2d.js
    //  DESC:       quad 2d class
    //


    var Quad2d = function Quad2d() {
        _classCallCheck(this, Quad2d);

        this.vert = [new __WEBPACK_IMPORTED_MODULE_0__common_vertex2d__["a" /* Vertex2d */](), new __WEBPACK_IMPORTED_MODULE_0__common_vertex2d__["a" /* Vertex2d */](), new __WEBPACK_IMPORTED_MODULE_0__common_vertex2d__["a" /* Vertex2d */](), new __WEBPACK_IMPORTED_MODULE_0__common_vertex2d__["a" /* Vertex2d */]()];
    };
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Quad2d;

    /***/
},
/* 61 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME: shaderdata.js
    //  DESC:      shader data class
    //


    var ShaderData = function () {
        function ShaderData() {
            _classCallCheck(this, ShaderData);

            // OpenGL ID's
            this.programId = 0;
            this.vertexId = 0;
            this.fragmentId = 0;
            this.attributeCount = 0;

            // location shader map
            this.locationMap = new Map();
        }

        //
        //  DESC: Get the shader location variable
        //


        _createClass(ShaderData, [{
            key: 'getLocation',
            value: function getLocation(id) {
                var loc = this.locationMap.get(id);
                if (loc !== undefined) return loc;else throw new Error('ERROR Shader variable location does not exist! (' + id + ').');

                return null;
            }

            //
            //  DESC: Check for the shader location variable
            //

        }, {
            key: 'hasLocation',
            value: function hasLocation(id) {
                return this.locationMap.has(id);
            }
        }]);

        return ShaderData;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ShaderData;

    /***/
},
/* 62 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__ = __webpack_require__(15);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__library_managers_texturemanager__ = __webpack_require__(6);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__library_managers_vertexbuffermanager__ = __webpack_require__(19);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__library_managers_fontmanager__ = __webpack_require__(38);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__ = __webpack_require__(11);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__library_managers_actionmanager__ = __webpack_require__(33);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__library_gui_menumanager__ = __webpack_require__(24);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__ = __webpack_require__(28);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__library_managers_signalmanager__ = __webpack_require__(18);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__library_managers_soundmanager__ = __webpack_require__(35);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__library_managers_spritestrategymanager__ = __webpack_require__(46);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_11__library_2d_sprite2d__ = __webpack_require__(13);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_12__library_system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_13__library_utilities_highresolutiontimer__ = __webpack_require__(8);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_14__library_utilities_assetholder__ = __webpack_require__(12);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_15__library_gui_uiprogressbar__ = __webpack_require__(45);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_16__state_titlescreenstate__ = __webpack_require__(36);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_17__scripts_utilityscripts__ = __webpack_require__(49);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_18__scripts_menuscripts__ = __webpack_require__(96);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_19__gamestate__ = __webpack_require__(22);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__ = __webpack_require__(3);

    // 
    //  FILE NAME: startupstate.js
    //  DESC:      startup state class
    //


    var STARTUP_ASSET_COUNT = 82,
        LOGO_DISPLAY_DELAY = 2000;

    var StartUpState = function (_WEBPACK_IMPORTED_MO16) {
        _inherits(StartUpState, _WEBPACK_IMPORTED_MO16);

        function StartUpState() {
            var gameLoopCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            _classCallCheck(this, StartUpState);

            var _this29 = _possibleConstructorReturn(this, (StartUpState.__proto__ || Object.getPrototypeOf(StartUpState)).call(this, __WEBPACK_IMPORTED_MODULE_19__gamestate__["c" /* GAME_STATE_STARTUP */], __WEBPACK_IMPORTED_MODULE_19__gamestate__["d" /* GAME_STATE_TITLESCREEN */], gameLoopCallback));

            _this29.stateChange = true;

            // Logo to fade in and out during the load
            _this29.spriteLogo;

            // progress bar to show loading
            _this29.progressBar;

            // Init fade members
            _this29.current = 0.0;
            _this29.final = 1.0;
            _this29.time = 500.0;
            _this29.inc = (_this29.final - _this29.current) / _this29.time;
            _this29.fadeCompleteCallback = _this29.assetLoad.bind(_this29);

            _this29.progressCounter = 0;
            return _this29;
        }

        // 
        //  DESC: progress bar update
        //


        _createClass(StartUpState, [{
            key: 'progressbarUpdate',
            value: function progressbarUpdate() {
                __WEBPACK_IMPORTED_MODULE_12__library_system_device__["b" /* gl */].clear(__WEBPACK_IMPORTED_MODULE_12__library_system_device__["b" /* gl */].COLOR_BUFFER_BIT);

                this.spriteLogo.render(__WEBPACK_IMPORTED_MODULE_12__library_system_device__["a" /* device */].orthographicMatrix);

                this.progressBar.incCurrentValue(++this.progressCounter);
                this.progressBar.simpleTransform();
                this.progressBar.render(__WEBPACK_IMPORTED_MODULE_12__library_system_device__["a" /* device */].orthographicMatrix);

                // Unbind everything after a round of rendering
                __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__["a" /* shaderManager */].unbind();
                __WEBPACK_IMPORTED_MODULE_1__library_managers_texturemanager__["a" /* textureManager */].unbind();
                __WEBPACK_IMPORTED_MODULE_2__library_managers_vertexbuffermanager__["a" /* vertexBufferManager */].unbind();
            }

            // 
            //  DESC: Do start up init
            //

        }, {
            key: 'init',
            value: function init() {
                var groupAry = ['(startup)'];

                // Set the load manager's callback when everything is loaded
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].loadCompleteCallback = this.startFade.bind(this);

                // Load the shaders
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/shaders/shader.cfg', function (xmlNode) {
                        return __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__["a" /* shaderManager */].load(xmlNode, callback);
                    });
                });

                // Load the object data list table and (startup) group
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/objects/2d/objectDataList/dataListTable.lst', function (xmlNode) {
                        // Load the object data list table
                        __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadListTable(xmlNode);

                        // Load the object data XML's
                        __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadXMLGroup2D(groupAry, callback);
                    });
                });

                // Load all the textures associated with this group
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadTextureGroup2D(groupAry, callback);
                });

                // Load all the mesh files associated with this group
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadMeshGroup2D(groupAry, callback);
                });

                // Create OpenGL objects from the loaded data
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].createFromData(groupAry, callback);
                });

                // Start the load
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].load();
            }

            // 
            //  DESC: Start the fade
            //

        }, {
            key: 'startFade',
            value: function startFade() {
                // Create the logo to fade in and out
                this.spriteLogo = new __WEBPACK_IMPORTED_MODULE_11__library_2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(startup)', 'logo'));
                this.spriteLogo.setScaleXYZ(1.5, 1.5, 1);
                this.spriteLogo.transform();

                this.progressBar = new __WEBPACK_IMPORTED_MODULE_15__library_gui_uiprogressbar__["a" /* UIProgressBar */]('(startup)');
                this.progressBar.setPosXYZ(0, -350, 0);
                this.progressBar.loadSpriteFromArray(['progress_frame', 'progress_solid'], 1);
                this.progressBar.initProgressBar(STARTUP_ASSET_COUNT);
                this.progressBar.simpleTransform();

                // Reset the elapsed time before entering the render loop
                __WEBPACK_IMPORTED_MODULE_13__library_utilities_highresolutiontimer__["a" /* highResTimer */].calcElapsedTime();

                // Start the fade
                requestAnimationFrame(this.fade.bind(this));
            }

            // 
            //  DESC: handle the logo fade in
            //

        }, {
            key: 'fade',
            value: function fade() {
                __WEBPACK_IMPORTED_MODULE_13__library_utilities_highresolutiontimer__["a" /* highResTimer */].calcElapsedTime();
                this.time -= __WEBPACK_IMPORTED_MODULE_13__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;

                if (this.time < 0) {
                    this.renderFade(this.final);
                    this.fadeCompleteCallback();
                } else {
                    this.current += this.inc * __WEBPACK_IMPORTED_MODULE_13__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;
                    this.renderFade(this.current);

                    // Continues the loop
                    requestAnimationFrame(this.fade.bind(this));
                }
            }

            // 
            //  DESC: Render the fade
            //

        }, {
            key: 'renderFade',
            value: function renderFade(value) {
                var _iteratorNormalCompletion31 = true;
                var _didIteratorError31 = false;
                var _iteratorError31 = undefined;

                try {
                    for (var _iterator31 = __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__["a" /* shaderManager */].shaderMap.entries()[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
                        var _step31$value = _slicedToArray(_step31.value, 2),
                            key = _step31$value[0],
                            shaderData = _step31$value[1];

                        __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__["a" /* shaderManager */].setShaderValue4fv(key, 'additive', [value, value, value, 1]);
                    }
                } catch (err) {
                    _didIteratorError31 = true;
                    _iteratorError31 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion31 && _iterator31.return) {
                            _iterator31.return();
                        }
                    } finally {
                        if (_didIteratorError31) {
                            throw _iteratorError31;
                        }
                    }
                }

                __WEBPACK_IMPORTED_MODULE_12__library_system_device__["b" /* gl */].clear(__WEBPACK_IMPORTED_MODULE_12__library_system_device__["b" /* gl */].COLOR_BUFFER_BIT);

                this.spriteLogo.render(__WEBPACK_IMPORTED_MODULE_12__library_system_device__["a" /* device */].orthographicMatrix);
                this.progressBar.render(__WEBPACK_IMPORTED_MODULE_12__library_system_device__["a" /* device */].orthographicMatrix);

                // Unbind everything after a round of rendering
                __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__["a" /* shaderManager */].unbind();
                __WEBPACK_IMPORTED_MODULE_1__library_managers_texturemanager__["a" /* textureManager */].unbind();
                __WEBPACK_IMPORTED_MODULE_2__library_managers_vertexbuffermanager__["a" /* vertexBufferManager */].unbind();
            }

            // 
            //  DESC: Load the assets
            //

        }, {
            key: 'assetLoad',
            value: function assetLoad() {
                // Set the function to be called to update the progress bar during the download
                __WEBPACK_IMPORTED_MODULE_8__library_managers_signalmanager__["a" /* signalManager */].connect_loadComplete(this.progressbarUpdate.bind(this));

                // Use the simple timer to see how long the download is
                __WEBPACK_IMPORTED_MODULE_13__library_utilities_highresolutiontimer__["a" /* highResTimer */].timerStart();

                var groupAry = ['(menu)', '(loadingScreen)'];

                // Set the load manager's callback when everything is loaded
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].loadCompleteCallback = this.loadComplete.bind(this);

                // Load the menu assets
                // Load the xml group
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadXMLGroup2D(groupAry, callback);
                });

                // Load all the textures associated with this group
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadTextureGroup2D(groupAry, callback);
                });

                // Load all the meshes associated with this group
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadMeshGroup2D(groupAry, callback);
                });

                // Create OpenGL objects from the loaded data
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    return __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].createFromData(groupAry, callback);
                });

                // Load the Sprite Strategy Manager list table
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/objects/2d/spritestrategy/spriteStrageyListTable.lst', function (xmlNode) {
                        // Load the object data list table
                        __WEBPACK_IMPORTED_MODULE_10__library_managers_spritestrategymanager__["a" /* spriteStrategyManager */].loadListTable(xmlNode);

                        callback();
                    });
                });

                // Load the sound list table and (menu) group
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/sound/soundListTable.lst', function (xmlNode) {
                        // Load the object data list table
                        __WEBPACK_IMPORTED_MODULE_9__library_managers_soundmanager__["a" /* soundManager */].loadListTable(xmlNode);

                        // Preload the menu group
                        __WEBPACK_IMPORTED_MODULE_9__library_managers_soundmanager__["a" /* soundManager */].loadGroup(['(menu)'], callback);
                    });
                });

                // Load the object data list table and (startup) group
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/objects/3d/objectDataList/dataListTable.lst', function (xmlNode) {
                        // Load the object data list table
                        __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].loadListTable(xmlNode);
                        callback();
                    });
                });

                // Load the fonts
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/textures/fonts/font.lst', function (xmlNode) {
                        return __WEBPACK_IMPORTED_MODULE_3__library_managers_fontmanager__["a" /* fontManager */].load(xmlNode, callback);
                    });
                });

                // Load the action manager
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/settings/controllerMapping.cfg', function (xmlNode) {
                        __WEBPACK_IMPORTED_MODULE_5__library_managers_actionmanager__["a" /* actionManager */].load(xmlNode);
                        callback();
                    });
                });

                // Preload the menu group
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/objects/2d/menu/menuListTable.lst', function (xmlNode) {
                        // Load the object data list table
                        __WEBPACK_IMPORTED_MODULE_6__library_gui_menumanager__["a" /* menuManager */].loadListTable(xmlNode);

                        __WEBPACK_IMPORTED_MODULE_20__library_utilities_genfunc__["b" /* downloadFile */]('xml', 'data/objects/2d/menu/menu_action.list', function (xmlNode) {
                            // Load the menu action table
                            __WEBPACK_IMPORTED_MODULE_6__library_gui_menumanager__["a" /* menuManager */].loadMenuAction(xmlNode);

                            // Preload the menu group
                            __WEBPACK_IMPORTED_MODULE_6__library_gui_menumanager__["a" /* menuManager */].preloadGroup(['(menu)'], callback);
                        });
                    });
                });

                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].add(function (callback) {
                    // Load the menu scripts before creating the menus
                    __WEBPACK_IMPORTED_MODULE_18__scripts_menuscripts__["a" /* loadScripts */]();
                    __WEBPACK_IMPORTED_MODULE_17__scripts_utilityscripts__["c" /* loadScripts */]();

                    // Create the menu group
                    __WEBPACK_IMPORTED_MODULE_6__library_gui_menumanager__["a" /* menuManager */].createGroup(['(menu)']);

                    callback();
                });

                // Load the state specific assets
                __WEBPACK_IMPORTED_MODULE_16__state_titlescreenstate__["b" /* load */]();

                // Start the load
                __WEBPACK_IMPORTED_MODULE_7__library_managers_loadmanager__["a" /* loadManager */].load();
            }

            // 
            //  DESC: Load is completed so fade the logo out
            //

        }, {
            key: 'loadComplete',
            value: function loadComplete() {
                var _this30 = this;

                __WEBPACK_IMPORTED_MODULE_8__library_managers_signalmanager__["a" /* signalManager */].clear_loadComplete();
                console.log('StartUp State Download Count: ' + this.progressCounter);

                // Init fade members
                this.current = 1.0;
                this.final = 0.0;
                this.time = 500.0;
                this.inc = (this.final - this.current) / this.time;
                this.fadeCompleteCallback = this.callback;

                // Reset the elapsed time before entering the render loop
                __WEBPACK_IMPORTED_MODULE_13__library_utilities_highresolutiontimer__["a" /* highResTimer */].calcElapsedTime();

                var downloadTime = __WEBPACK_IMPORTED_MODULE_13__library_utilities_highresolutiontimer__["a" /* highResTimer */].timerStop();

                if (downloadTime > LOGO_DISPLAY_DELAY) requestAnimationFrame(this.fade.bind(this));else setTimeout(function () {
                    return requestAnimationFrame(_this30.fade.bind(_this30));
                }, LOGO_DISPLAY_DELAY - downloadTime);
            }

            // 
            //  DESC: Clean up after the startup state
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].freeGroup(['(startup)']);
                __WEBPACK_IMPORTED_MODULE_14__library_utilities_assetholder__["a" /* assetHolder */].deleteGroup(['(startup)', '(menu)']);
            }
        }]);

        return StartUpState;
    }(__WEBPACK_IMPORTED_MODULE_19__gamestate__["e" /* GameState */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = StartUpState;

    /***/
},
/* 63 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_rect__ = __webpack_require__(20);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_texture__ = __webpack_require__(37);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__managers_texturemanager__ = __webpack_require__(6);

    // 
    //  FILE NAME:  font.js
    //  DESC:       font class
    //


    var CharData = function CharData() {
        _classCallCheck(this, CharData);

        // Character offsets
        this.offset = new __WEBPACK_IMPORTED_MODULE_0__common_size__["a" /* Size */]();

        // Character rect
        this.rect = new __WEBPACK_IMPORTED_MODULE_1__common_rect__["a" /* Rect */]();

        // Amount to advance
        this.xAdvance = 0;
    };
    /* unused harmony export CharData */

    var Font = function () {
        function Font() {
            _classCallCheck(this, Font);

            // map list of character data
            this.charDataMap = new Map();

            // Line height
            this.lineHeight = 0;

            // base line offset
            this.baselineOffset = 0;

            // Horizontal padding
            this.horzPadding = 0;

            // Vertival padding
            this.vertPadding = 0;

            // The texture
            this.texture = null;
        }

        // 
        //  DESC: Load from XML node
        //


        _createClass(Font, [{
            key: 'loadFromNode',
            value: function loadFromNode(group, name, xmlNode) {
                // load the texture
                this.texture = __WEBPACK_IMPORTED_MODULE_3__managers_texturemanager__["a" /* textureManager */].getTexture(group, name);

                // Get the padding
                var padding = xmlNode.getElementsByTagName('info')[0].getAttribute('padding');
                this.horzPadding = Number(padding.substr(6, 1));
                this.vertPadding = Number(padding.substr(0, 1));

                // Get the common font info
                var commonNode = xmlNode.getElementsByTagName('common');

                // get the line height
                this.lineHeight = Number(commonNode[0].getAttribute('lineHeight'));

                // get the baseline offset
                this.baselineOffset = Number(commonNode[0].getAttribute('base'));

                // Get the list of character info
                var charNode = xmlNode.getElementsByTagName('char');

                // Load in the individual character data
                for (var i = 0; i < charNode.length; ++i) {
                    var charData = new CharData();

                    // Get the offset of the character
                    charData.offset.w = Number(charNode[i].getAttribute('xoffset'));
                    charData.offset.h = Number(charNode[i].getAttribute('yoffset'));

                    // Get the x advance of the character
                    charData.xAdvance = Number(charNode[i].getAttribute('xadvance'));

                    // Get the rect of the character
                    charData.rect.x1 = Number(charNode[i].getAttribute('x'));
                    charData.rect.y1 = Number(charNode[i].getAttribute('y'));
                    charData.rect.x2 = Number(charNode[i].getAttribute('width'));
                    charData.rect.y2 = Number(charNode[i].getAttribute('height'));

                    // Get the character ID which is the ascii value of the character.
                    var _id2 = Number(charNode[i].getAttribute('id'));

                    // Add the character to our list
                    this.charDataMap.set(_id2, charData);
                }
            }

            // 
            //  DESC: Get the data for this character
            //

        }, {
            key: 'getCharData',
            value: function getCharData(id) {
                // See if this character is part of the map
                var charData = this.charDataMap.get(id);

                if (charData === undefined) throw new Error('Font character ID can\'t be found (' + id + ').');

                return charData;
            }
        }]);

        return Font;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Font;

    /***/
},
/* 64 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_rect__ = __webpack_require__(20);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_size__ = __webpack_require__(1);

    // 
    //  FILE NAME:  spritesheetglyph.js
    //  DESC:       Class to hold sprite sheet glyph data
    //


    var SpriteSheetGlyph = function SpriteSheetGlyph(size, uv) {
        var cropOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        _classCallCheck(this, SpriteSheetGlyph);

        // Size of the sprite on the sheet
        this.size = size;

        // UV coordinates RECT
        this.uv = uv;

        // Crop Offset
        this.cropOffset = cropOffset;
    };
    /* harmony export (immutable) */

    __webpack_exports__["a"] = SpriteSheetGlyph;

    /***/
},
/* 65 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__objectphysicsdata2d__ = __webpack_require__(66);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__objectvisualdata2d__ = __webpack_require__(67);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__utilities_xmlparsehelper__ = __webpack_require__(4);

    // 
    //  FILE NAME: objectdata2d.js
    //  DESC:      Class that holds a 2D object data
    //


    var ObjectData2D = function () {
        function ObjectData2D() {
            _classCallCheck(this, ObjectData2D);

            // Visual data of the object
            this.visualData = new __WEBPACK_IMPORTED_MODULE_1__objectvisualdata2d__["a" /* ObjectVisualData2D */]();

            // Physics data of the object
            this.physicsData = new __WEBPACK_IMPORTED_MODULE_0__objectphysicsdata2d__["a" /* ObjectPhysicsData2D */]();

            // The name of the object data
            this.name = null;

            // The group the object data is in
            this.group = null;

            // The initial size of the object
            this.size = new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */]();
        }

        // 
        //  DESC: Copy the passed in data
        //


        _createClass(ObjectData2D, [{
            key: 'copy',
            value: function copy(obj) {
                this.visualData.copy(obj.visualData);
                this.physicsData.copy(obj.physicsData);
                this.size.copy(obj.size);
            }

            // 
            //  DESC: Load the object data from the passed in node
            //

        }, {
            key: 'loadObjData',
            value: function loadObjData(node, group, name) {
                this.name = name;
                this.group = group;

                // Load the size
                this.size = __WEBPACK_IMPORTED_MODULE_3__utilities_xmlparsehelper__["j" /* loadSize */](node, this.size);

                // Load the visual data
                this.visualData.loadObjData(node);

                // Load the physics data
                this.physicsData.loadObjData(node);
            }

            // 
            //  DESC: Create OpenGL objects from data
            //

        }, {
            key: 'createFromData',
            value: function createFromData(group) {
                // Create the visuales
                this.visualData.createFromData(group, this.size);
            }
        }]);

        return ObjectData2D;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ObjectData2D;

    /***/
},
/* 66 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__Box2D_planck__ = __webpack_require__(32);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__Box2D_planck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__Box2D_planck__);

    // 
    //  FILE NAME:  objectphysicsdata2d.js
    //  DESC:       Class containing the 2D object's physics data
    //


    var Fixture = function () {
        function Fixture() {
            _classCallCheck(this, Fixture);

            // Shape of the fixture
            this.shape = null;

            // Radius if shape is a circle
            this.radius = 0.0;

            // The friction is how much drag this object has on another object  
            this.friction = 0.2;

            // The density is how much the object resists movement  
            this.density = 0.2;

            // The percetange of velocity retained upon colliding with this object
            this.restitution = 0.2;

            // Amount to adjust the top, bottom, left, and right side size of the mesh
            this.topMod = 0;
            this.bottomMod = 0;
            this.leftMod = 0;
            this.rightMod = 0;

            // Flag to define if chain shape is a loop
            this.chainLoop = false;

            // Flag to indicate if fixture is a sensor. Reports collision but doesn't react to it
            this.sensor = false;

            // Collision filter
            this.filterGroupIndex = 0;
            this.filterCategoryBits = 1;
            this.filterMaskBits = 65535;

            // Polygon point vector
            this.vertAry = [];
        }

        // 
        //  DESC: Copy the passed in data
        //


        _createClass(Fixture, [{
            key: 'copy',
            value: function copy(obj) {
                this.shape = obj.shape;
                this.radius = obj.radius;
                this.friction = obj.friction;
                this.density = obj.density;
                this.restitution = obj.restitution;
                this.topMod = obj.topMod;
                this.bottomMod = obj.bottomMod;
                this.leftMod = obj.leftMod;
                this.rightMod = obj.rightMod;
                this.chainLoop = obj.chainLoop;
                this.sensor = obj.sensor;
                this.filterGroupIndex = obj.filterGroupIndex;
                this.filterCategoryBits = obj.filterCategoryBits;
                this.filterMaskBits = obj.filterMaskBits;

                for (var i = 0; i < obj.vertAry.length; ++i) {
                    var vert = obj.vertAry[i];
                    this.vertAry.push(new __WEBPACK_IMPORTED_MODULE_0__Box2D_planck__["Vec2"](vert.x, vert.y));
                }
            }
        }]);

        return Fixture;
    }();
    /* unused harmony export Fixture */

    var ObjectPhysicsData2D = function () {
        function ObjectPhysicsData2D() {
            _classCallCheck(this, ObjectPhysicsData2D);

            // The name of the physics world
            this.world = null;

            // Type of physics body
            this.bodyType = null;

            // The constant decceleration of movement and rotation
            this.linearDamping = 0;
            this.angularDamping = 0;

            // If we want to prevent the object from rotating due to physicss
            this.fixedRotation = false;

            // vector of fixtures
            this.fixtureAry = [];
        }

        // 
        //  DESC: Copy the passed in data
        //


        _createClass(ObjectPhysicsData2D, [{
            key: 'copy',
            value: function copy(obj) {
                this.world = obj.world;
                this.bodyType = obj.bodyType;
                this.linearDamping = obj.linearDamping;
                this.angularDamping = obj.angularDamping;
                this.fixedRotation = obj.fixedRotation;

                for (var i = 0; i < obj.fixtureAry.length; ++i) {
                    var fixture = new Fixture();
                    fixture.copy(obj.fixtureAry[i]);
                    this.fixtureAry.push(fixture);
                }
            }

            // 
            //  DESC: Load the object data
            //

        }, {
            key: 'loadObjData',
            value: function loadObjData(node) {
                var physicsNode = node.getElementsByTagName('physics');

                // Check if the object has any physics data
                if (physicsNode.length) {
                    var attr = physicsNode[0].getAttribute('world');
                    if (attr) this.world = attr;

                    // The body of the physics sprite used for physics
                    var bodyNode = physicsNode[0].getElementsByTagName('body');
                    if (bodyNode.length) {
                        // Get the body type - default is static
                        attr = bodyNode[0].getAttribute('type');
                        if (attr) this.bodyType = attr;

                        // The damping is the constant decceleration of movement
                        attr = bodyNode[0].getAttribute('linearDamping');
                        if (attr) this.linearDamping = Number(attr);

                        // The angular damping is the constant decceleration of rotation
                        attr = bodyNode[0].getAttribute('angularDamping');
                        if (attr) this.angularDamping = Number(attr);

                        // Whether the rotation due to physicss is fixed
                        attr = bodyNode[0].getAttribute('fixedRotation');
                        if (attr) this.fixedRotation = attr === 'true';
                    }

                    // The body of the physics sprite used for physics
                    var fixtureNode = physicsNode[0].getElementsByTagName('fixture');

                    for (var i = 0; i < fixtureNode.length; ++i) {
                        var fixture = this.fixtureAry[i];

                        if (fixture === undefined) {
                            fixture = new Fixture();
                            this.fixtureAry.push(fixture);
                        }

                        // Get the fixture shape
                        attr = fixtureNode[i].getAttribute('shape');
                        if (attr) fixture.shape = attr;

                        // The friction is how much drag this object has on another object
                        attr = fixtureNode[i].getAttribute('friction');
                        if (attr) fixture.friction = Number(attr);

                        // The density is how much the object resists movement
                        attr = fixtureNode[i].getAttribute('density');
                        if (attr) fixture.density = Number(attr);

                        // The restitution is the percentage of velocity retained upon physics
                        attr = fixtureNode[i].getAttribute('restitution');
                        if (attr) fixture.restitution = Number(attr);

                        // Radius if shape is a circle
                        attr = fixtureNode[i].getAttribute('radius');
                        if (attr) fixture.radius = Number(attr);

                        // Is chain shape a loop?
                        attr = fixtureNode[i].getAttribute('chainLoop');
                        if (attr) fixture.chainLoop = attr === 'true';

                        // Is fixture a sensor?
                        attr = fixtureNode[i].getAttribute('sensor');
                        if (attr) fixture.sensor = attr === 'true';

                        // See if there is a vert list
                        var vertNode = fixtureNode[i].getElementsByTagName('vert');

                        for (var j = 0; j < vertNode.length; ++j) {
                            fixture.vertAry.push(new __WEBPACK_IMPORTED_MODULE_0__Box2D_planck__["Vec2"](Number(vertNode[j].getAttribute('x')), Number(vertNode[j].getAttribute('y'))));
                        }

                        // See if the filter is defined
                        var filterNode = fixtureNode[i].getElementsByTagName('collisionFilter');
                        if (filterNode.length) {
                            attr = filterNode[0].getAttribute('categoryBits');
                            if (attr) fixture.filterGroupIndex = Number(attr);

                            attr = filterNode[0].getAttribute('maskBits');
                            if (attr) fixture.filterMaskBits = Number(attr);

                            attr = filterNode[0].getAttribute('groupIndex');
                            if (attr) fixture.filterGroupIndex = Number(attr);
                        }

                        // The size mod is how much the mesh size should be adjusted on each side
                        var sizeModNode = fixtureNode[i].getElementsByTagName('sizeMod');
                        if (sizeModNode.length) {
                            attr = sizeModNode[0].getAttribute('top');
                            if (attr) fixture.topMod = Number(attr);

                            attr = sizeModNode[0].getAttribute('bottom');
                            if (attr) fixture.bottomMod = Number(attr);

                            attr = sizeModNode[0].getAttribute('left');
                            if (attr) fixture.leftMod = Number(attr);

                            attr = sizeModNode[0].getAttribute('right');
                            if (attr) fixture.rightMod = Number(attr);
                        }
                    }
                }
            }

            // 
            //  DESC: Is this genType active
            //

        }, {
            key: 'isActive',
            value: function isActive() {
                return this.bodyType !== null;
            }
        }]);

        return ObjectPhysicsData2D;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ObjectPhysicsData2D;

    /***/
},
/* 67 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_rect__ = __webpack_require__(20);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_color__ = __webpack_require__(16);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__common_vertex2d__ = __webpack_require__(26);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__common_scaledframe__ = __webpack_require__(68);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__common_spritesheet__ = __webpack_require__(40);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__managers_texturemanager__ = __webpack_require__(6);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__managers_vertexbuffermanager__ = __webpack_require__(19);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__managers_spritesheetmanager__ = __webpack_require__(39);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__utilities_assetholder__ = __webpack_require__(12);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__common_defs__ = __webpack_require__(0);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_11__utilities_xmlparsehelper__ = __webpack_require__(4);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_12__utilities_genfunc__ = __webpack_require__(3);

    // 
    //  FILE NAME: ojectvisualdata2d.js
    //  DESC:      Class containing the 2D object's visual data
    //


    var ObjectVisualData2D = function () {
        function ObjectVisualData2D() {
            _classCallCheck(this, ObjectVisualData2D);

            // texture id
            this.texture = null;

            // VBO
            this.vbo = null;

            // IBO
            this.ibo = null;

            // VBO/IBO generation type
            this.genType = __WEBPACK_IMPORTED_MODULE_10__common_defs__["_20" /* EGT_NULL */];

            // Name of the shader
            this.shaderID = null;

            // Initial color of the object
            this.color = new __WEBPACK_IMPORTED_MODULE_1__common_color__["a" /* Color */]();

            // texture file path
            this.textureFilePath = '';

            // mesh file path
            this.meshFilePath = null;

            // Sprite sheet file path
            this.spriteSheetFilePath = null;

            // ibo count
            this.iboCount = 0;

            // The vertex scale of the object
            this.vertexScale = new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */]();

            // Scaled frame
            this.scaledFrame = null;

            // Sprite Sheet
            this.spriteSheet = null;

            // String of glyph ids
            this.glyphIDs = null;

            // Default scale
            this.defaultUniformScale = 1;
        }

        // 
        //  DESC: Copy the passed in data
        //


        _createClass(ObjectVisualData2D, [{
            key: 'copy',
            value: function copy(obj) {
                this.genType = obj.genType;
                this.shaderID = obj.shaderID;
                this.textureFilePath = obj.textureFilePath;
                this.meshFilePath = obj.meshFilePath;
                this.spriteSheetFilePath = obj.spriteSheetFilePath;
                this.defaultUniformScale = obj.defaultUniformScale;
                this.color.copy(obj.color);

                if (obj.glyphIDs) {
                    if (this.glyphIDs === null) this.glyphIDs = [];

                    for (var i = 0; i < obj.glyphIDs.length; ++i) {
                        this.glyphIDs[i] = obj.glyphIDs[i];
                    }
                }

                if (obj.scaledFrame) {
                    this.scaledFrame = new __WEBPACK_IMPORTED_MODULE_4__common_scaledframe__["a" /* ScaledFrame */]();
                    this.scaledFrame.copy(obj.scaledFrame);
                }

                if (obj.spriteSheet) {
                    this.spriteSheet = new __WEBPACK_IMPORTED_MODULE_5__common_spritesheet__["a" /* SpriteSheet */]();
                    this.spriteSheet.copy(obj.spriteSheet);
                }
            }

            // 
            //  DESC: Load the object data
            //

        }, {
            key: 'loadObjData',
            value: function loadObjData(node) {
                var visualNode = node.getElementsByTagName('visual');
                if (visualNode.length) {
                    var attr = visualNode[0].getAttribute('defaultUniformScale');
                    if (attr) this.defaultUniformScale = Number(attr);

                    // See if we have a texture to load
                    var textureNode = visualNode[0].getElementsByTagName('texture');
                    if (textureNode.length) {
                        var file = textureNode[0].getAttribute('file');
                        if (file) this.textureFilePath = file;
                    }

                    // Get the mesh node
                    var meshNode = visualNode[0].getElementsByTagName('mesh');
                    if (meshNode.length) {
                        var genTypeStr = meshNode[0].getAttribute('genType');
                        if (genTypeStr) {
                            if (genTypeStr === 'quad') this.genType = __WEBPACK_IMPORTED_MODULE_10__common_defs__["_21" /* EGT_QUAD */];else if (genTypeStr === 'sprite_sheet') this.genType = __WEBPACK_IMPORTED_MODULE_10__common_defs__["_23" /* EGT_SPRITE_SHEET */];else if (genTypeStr === 'scaled_frame') this.genType = __WEBPACK_IMPORTED_MODULE_10__common_defs__["_22" /* EGT_SCALED_FRAME */];else if (genTypeStr === 'mesh_file') this.genType = __WEBPACK_IMPORTED_MODULE_10__common_defs__["_19" /* EGT_MESH_FILE */];else if (genTypeStr === 'font') this.genType = __WEBPACK_IMPORTED_MODULE_10__common_defs__["_18" /* EGT_FONT */];
                        }

                        var spriteSheetNode = meshNode[0].getElementsByTagName('spriteSheet');
                        if (spriteSheetNode.length) {
                            var defaultIndex = 0;
                            var glyphCount = 0;
                            var columns = 0;

                            var _attr3 = spriteSheetNode[0].getAttribute('defIndex');
                            if (_attr3) defaultIndex = Number(_attr3);

                            // Make sure all elements are defined for manually building the sprite sheet data
                            _attr3 = spriteSheetNode[0].getAttribute('glyphCount');
                            if (_attr3) {
                                glyphCount = Number(_attr3);

                                _attr3 = spriteSheetNode[0].getAttribute('columns');
                                if (_attr3) columns = Number(_attr3);
                            }

                            // Get the sprite sheet glyph file
                            _attr3 = spriteSheetNode[0].getAttribute('file');
                            if (_attr3) this.spriteSheetFilePath = _attr3;

                            // See if any glyph Id's have been defined
                            var glyphNode = spriteSheetNode[0].getElementsByTagName('glyph');
                            if (glyphNode.length) {
                                this.glyphIDs = [];
                                for (var i = 0; i < glyphNode.length; ++i) {
                                    this.glyphIDs.push(glyphNode[i].getAttribute('id'));
                                }
                            }

                            // make sure this is a valid sprite sheet before allocating
                            if (this.spriteSheet === null && (this.glyphIDs || defaultIndex || glyphCount || columns)) this.spriteSheet = new __WEBPACK_IMPORTED_MODULE_5__common_spritesheet__["a" /* SpriteSheet */](defaultIndex, glyphCount, columns);
                        }

                        var scaledFrameNode = meshNode[0].getElementsByTagName('scaledFrame');
                        if (scaledFrameNode.length) {
                            if (this.scaledFrame === null) this.scaledFrame = new __WEBPACK_IMPORTED_MODULE_4__common_scaledframe__["a" /* ScaledFrame */]();

                            this.scaledFrame.frame.w = Number(scaledFrameNode[0].getAttribute('thicknessWidth'));
                            this.scaledFrame.frame.h = Number(scaledFrameNode[0].getAttribute('thicknessHeight'));

                            var centerQuadAttr = scaledFrameNode[0].getAttribute('centerQuad');
                            if (centerQuadAttr) this.scaledFrame.centerQuad = centerQuadAttr === 'true';

                            var frameBottomAttr = scaledFrameNode[0].getAttribute('frameBottom');
                            if (frameBottomAttr) this.scaledFrame.bottomFrame = frameBottomAttr === 'true';
                        }

                        var fileNode = meshNode[0].getElementsByTagName('file');
                        if (fileNode.length) this.meshFilePath = fileNode[0].getAttribute('name');
                    }

                    // The shader node determines which shader to use
                    var shaderNode = visualNode[0].getElementsByTagName('shader');
                    if (shaderNode.length) {
                        this.shaderID = shaderNode[0].getAttribute('id');
                    }

                    // Load the color
                    this.color = __WEBPACK_IMPORTED_MODULE_11__utilities_xmlparsehelper__["b" /* loadColor */](visualNode[0], this.color);

                    // Raise an exception if there's a genType but no shader
                    if (this.genType != __WEBPACK_IMPORTED_MODULE_10__common_defs__["_20" /* EGT_NULL */] && this.shaderID === null) throw new Error('Shader effect or techique not set!');
                }
            }

            // 
            //  DESC: Create the objects from data
            //

        }, {
            key: 'createFromData',
            value: function createFromData(group, size) {
                // Set the texture ID if one exists
                if (this.textureFilePath.length) {
                    // Get the texture for this object
                    this.texture = __WEBPACK_IMPORTED_MODULE_6__managers_texturemanager__["a" /* textureManager */].getTexture(group, this.textureFilePath);

                    // If the passed in size is empty, set it to the texture size
                    if (size.isEmpty()) size.copy(this.texture.size);
                }

                if (this.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_21" /* EGT_QUAD */]) {
                    this.generateQuad(group);

                    this.vertexScale.w = size.w * this.defaultUniformScale;
                    this.vertexScale.h = size.h * this.defaultUniformScale;
                    size.w = Math.trunc(this.vertexScale.w);
                    size.h = Math.trunc(this.vertexScale.h);
                } else if (this.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_23" /* EGT_SPRITE_SHEET */]) {
                    // Build the simple (grid) sprite sheet from XML data
                    if (this.spriteSheetFilePath === null) this.spriteSheet.build(size);

                    // Load complex sprite sheet data from the manager. It's assumed
                    // that string Id's are for complex sprite sheets that are shared
                    // among many sprites
                    else {
                            // This will return the sprite sheet if it's been loaded
                            var spriteSheet = __WEBPACK_IMPORTED_MODULE_8__managers_spritesheetmanager__["a" /* spriteSheetManager */].getSpriteSheet(this.spriteSheetFilePath);

                            // Copy the needed glyph data from the manager
                            spriteSheet.copyTo(this.spriteSheet, this.glyphIDs);
                        }

                    // Generate a quad
                    this.generateQuad(group);

                    // For this generation type, the glyph size is the default scale
                    var glyphSize = this.spriteSheet.getGlyph().size;

                    this.vertexScale.w = glyphSize.w * this.defaultUniformScale;
                    this.vertexScale.h = glyphSize.h * this.defaultUniformScale;
                    size.w = Math.trunc(this.vertexScale.w);
                    size.h = Math.trunc(this.vertexScale.h);
                } else if (this.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_22" /* EGT_SCALED_FRAME */]) {
                    if (this.glyphIDs !== null) {
                        // This will return the sprite sheet
                        var _spriteSheet = __WEBPACK_IMPORTED_MODULE_8__managers_spritesheetmanager__["a" /* spriteSheetManager */].getSpriteSheet(this.spriteSheetFilePath);

                        // Get the glyph to make the frame with
                        var glyph = _spriteSheet.findGlyph(this.glyphIDs[0]);

                        // Create the scaled frame using glyph info
                        if (this.meshFilePath) this.generateScaledFrameMeshFile(group, this.texture.size, glyph.size, size, glyph.uv);else this.generateScaledFrame(group, this.texture.size, glyph.size, size, glyph.uv);
                    } else if (this.meshFilePath) this.generateScaledFrameMeshFile(group, this.texture.size, this.texture.size, size, new __WEBPACK_IMPORTED_MODULE_0__common_rect__["a" /* Rect */]());else
                        // Generate a scaled frame
                        this.generateScaledFrame(group, this.texture.size, this.texture.size, size, new __WEBPACK_IMPORTED_MODULE_0__common_rect__["a" /* Rect */]());
                }
            }

            // 
            //  DESC: Generate a quad
            //

        }, {
            key: 'generateQuad',
            value: function generateQuad(group) {
                // VBO data
                // The order of the verts is counter clockwise
                // 1----0
                // |   /|
                // |  / |
                // | /  |
                // 2----3
                var vertAry = [0.5, 0.5, 0.0, 1.0, 0.0, -0.5, 0.5, 0.0, 0.0, 0.0, -0.5, -0.5, 0.0, 0.0, 1.0, 0.5, -0.5, 0.0, 1.0, 1.0];

                this.vbo = __WEBPACK_IMPORTED_MODULE_7__managers_vertexbuffermanager__["a" /* vertexBufferManager */].createVBO(group, 'guad_0011', vertAry);
                this.ibo = __WEBPACK_IMPORTED_MODULE_7__managers_vertexbuffermanager__["a" /* vertexBufferManager */].createIBO(group, 'quad_0123', [0, 1, 2, 3], true);

                this.iboCount = 4;
            }

            // 
            //  DESC: Generate a scaled frame
            //

        }, {
            key: 'generateScaledFrame',
            value: function generateScaledFrame(group, textureSize, glyphSize, frameSize, spriteSheetOffset) {
                var frame = this.scaledFrame.frame;
                var tSize = textureSize;
                var gSize = glyphSize;
                var vboName = 'scaled_frame_' + frameSize.w + '_' + frameSize.h + '_' + frame.w + '_' + frame.h + '_' + tSize.w + '_' + tSize.h + '_' + gSize.w + '_' + gSize.h;

                this.vbo = __WEBPACK_IMPORTED_MODULE_7__managers_vertexbuffermanager__["a" /* vertexBufferManager */].createScaledFrame(group, vboName, this.scaledFrame, textureSize, glyphSize, frameSize, spriteSheetOffset);

                var iboAry = [0, 1, 2, 0, 3, 1, 2, 4, 5, 2, 1, 4, 1, 6, 4, 1, 7, 6, 7, 8, 6, 7, 9, 8, 10, 9, 7, 10, 11, 9, 12, 11, 10, 12, 13, 11, 14, 10, 3, 14, 12, 10, 15, 3, 0, 15, 14, 3, 3, 7, 1, 3, 10, 7];

                // Create the reusable IBO buffer
                this.ibo = __WEBPACK_IMPORTED_MODULE_7__managers_vertexbuffermanager__["a" /* vertexBufferManager */].createIBO(group, 'scaled_frame', iboAry, true);

                // Set the ibo count depending on the number of quads being rendered
                // If the center quad is not used, just adjust the ibo count because
                // the center quad is just reused verts anyways and is that last 6 in the IBO
                // If the frame bottom is not being use, just subtract.
                // Center quad and no frame bottom can't co-exist.
                this.iboCount = 6 * 8;
                if (this.scaledFrame.centerQuad) this.iboCount += 6;else if (!this.scaledFrame.bottomFrame) this.iboCount -= 6 * 3;
            }

            // 
            //  DESC: Generate a scaled frame with a mesh file
            //

        }, {
            key: 'generateScaledFrameMeshFile',
            value: function generateScaledFrameMeshFile(group, textureSize, glyphSize, frameSize, spriteSheetOffset) {
                // Construct the name used for vbo and ibo
                var name = 'scaled_frame_mesh_' + this.meshFilePath;

                var iboAry = [0, 1, 2, 0, 3, 1, 2, 4, 5, 2, 1, 4, 1, 6, 4, 1, 7, 6, 7, 8, 6, 7, 9, 8, 10, 9, 7, 10, 11, 9, 12, 11, 10, 12, 13, 11, 14, 10, 3, 14, 12, 10, 15, 3, 0, 15, 14, 3];

                if (this.scaledFrame.centerQuad) Array.prototype.push.apply(iboAry, [3, 7, 1, 3, 10, 7]);

                // See if it already exists before loading the mesh file
                this.vbo = __WEBPACK_IMPORTED_MODULE_7__managers_vertexbuffermanager__["a" /* vertexBufferManager */].isVBO(group, name);
                if (this.vbo === null) {
                    // Load a mesh from XML file
                    var meshFileVertAry = [];
                    this.loadMeshFromXML(group, textureSize, frameSize, spriteSheetOffset, 16, meshFileVertAry, iboAry);

                    // create the vbo
                    this.vbo = __WEBPACK_IMPORTED_MODULE_7__managers_vertexbuffermanager__["a" /* vertexBufferManager */].createScaledFrame(group, name, this.scaledFrame, textureSize, glyphSize, frameSize, new __WEBPACK_IMPORTED_MODULE_0__common_rect__["a" /* Rect */](), meshFileVertAry);
                }

                // Create the reusable IBO buffer
                this.ibo = __WEBPACK_IMPORTED_MODULE_7__managers_vertexbuffermanager__["a" /* vertexBufferManager */].createIBO(group, name, iboAry, true);
                this.iboCount = iboAry.length;
            }

            // 
            //  DESC: Load a mesh from XML file
            //

        }, {
            key: 'loadMeshFromXML',
            value: function loadMeshFromXML(group, textureSize, frameSize, spriteSheetOffset, iboOffset, vertAry, iboAry) {
                // Check if the width or height is odd. If so, we offset 
                // by 0.5 for proper orthographic rendering
                var additionalOffsetX = 0;
                if (Math.trunc(frameSize.w) % 2 != 0) additionalOffsetX = 0.5;

                var additionalOffsetY = 0;
                if (Math.trunc(frameSize.h) % 2 != 0) additionalOffsetY = 0.5;

                // This converts the data to a center aligned vertex buffer
                var centerAlignSize = new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](-(frameSize.w / 2), frameSize.h / 2);

                // Open and parse the XML file:
                var node = __WEBPACK_IMPORTED_MODULE_9__utilities_assetholder__["a" /* assetHolder */].get(group, this.meshFilePath);
                var vboNode = node.getElementsByTagName('vbo');

                if (vboNode.length) {
                    var vertNode = vboNode[0].getElementsByTagName('vert');

                    for (var i = 0; i < vertNode.length; ++i) {
                        // Load the 2D vert
                        var vert = __WEBPACK_IMPORTED_MODULE_11__utilities_xmlparsehelper__["l" /* loadVertex2d */](vertNode[i]);

                        // This converts the data to a center aligned vertex buffer
                        vertAry.push(centerAlignSize.w + vert.x + additionalOffsetX);
                        vertAry.push(centerAlignSize.h - vert.y + additionalOffsetY);
                        vertAry.push(vert.z);
                        vertAry.push(spriteSheetOffset.x1 + vert.u / textureSize.w);
                        vertAry.push(spriteSheetOffset.y1 + vert.v / textureSize.h);
                    }
                }

                var iboNode = node.getElementsByTagName('ibo');
                if (iboNode.length) {
                    var iNode = iboNode[0].getElementsByTagName('i');

                    for (var _i10 = 0; _i10 < iNode.length; ++_i10) {
                        iboAry.push(iboOffset + Number(iNode[_i10].childNodes[0].nodeValue));
                    }
                }
            }

            // 
            //  DESC: Is this genType active
            //

        }, {
            key: 'isActive',
            value: function isActive() {
                return this.genType !== __WEBPACK_IMPORTED_MODULE_10__common_defs__["_20" /* EGT_NULL */];
            }

            // 
            //  DESC: Get the frame count
            //

        }, {
            key: 'getFrameCount',
            value: function getFrameCount() {
                if (this.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_23" /* EGT_SPRITE_SHEET */]) return this.spriteSheet.getCount();else if (this.texture !== null) return 1;

                return 0;
            }
        }]);

        return ObjectVisualData2D;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ObjectVisualData2D;

    /***/
},
/* 68 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_size__ = __webpack_require__(1);

    // 
    //  FILE NAME:  scaledframe.js
    //  DESC:       Class for holding scaled frame data
    //


    var ScaledFrame = function () {
        function ScaledFrame() {
            _classCallCheck(this, ScaledFrame);

            // Size of the frame
            this.frame = new __WEBPACK_IMPORTED_MODULE_0__common_size__["a" /* Size */]();

            // Is there a center quad?
            this.centerQuad = true;

            // Is there a bottom frame?
            this.bottomFrame = true;
        }

        // 
        //  DESC: Copy the passed in data
        //


        _createClass(ScaledFrame, [{
            key: 'copy',
            value: function copy(obj) {
                this.frame.copy(obj.frame);
                this.centerQuad = obj.centerQuad;
                this.bottomFrame = obj.bottomFrame;
            }
        }]);

        return ScaledFrame;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ScaledFrame;

    /***/
},
/* 69 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__objectvisualdata3d__ = __webpack_require__(70);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_xmlparsehelper__ = __webpack_require__(4);

    // 
    //  FILE NAME: objectdata3d.js
    //  DESC:      Class that holds a 3D object data
    //


    //import { ObjectPhysicsData3D } from '../objectdatamanager/objectphysicsdata3d';


    var ObjectData3D = function () {
        function ObjectData3D() {
            _classCallCheck(this, ObjectData3D);

            // Visual data of the object
            this.visualData = new __WEBPACK_IMPORTED_MODULE_0__objectvisualdata3d__["a" /* ObjectVisualData3D */]();

            // Physics data of the object
            //CObjectPhysicsData2D m_physicsData;

            // The name of the object data
            this.name = null;

            // The group the object data is in
            this.group = null;
        }

        // 
        //  DESC: Copy the passed in data
        //


        _createClass(ObjectData3D, [{
            key: 'copy',
            value: function copy(obj) {
                this.visualData.copy(obj.visualData);
            }

            // 
            //  DESC: Load the object data from the passed in node
            //

        }, {
            key: 'loadObjData',
            value: function loadObjData(node, group, name) {
                this.name = name;
                this.group = group;

                // Load the visual data
                this.visualData.loadObjData(node);

                // Load the physics data
                //m_physicsData.LoadFromNode( node );
            }

            // 
            //  DESC: Add the textures to the mesh with the "createFromData" call
            //

        }, {
            key: 'createFromData',
            value: function createFromData(group) {
                // Create the visuales
                this.visualData.addTexturesToMesh(group);
            }
        }]);

        return ObjectData3D;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ObjectData3D;

    /***/
},
/* 70 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_color__ = __webpack_require__(16);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__ = __webpack_require__(6);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__utilities_xmlparsehelper__ = __webpack_require__(4);

    // 
    //  FILE NAME: ojectvisualdata3d.js
    //  DESC:      Class containing the 3D object's visual data
    //


    var ObjectVisualData3D = function () {
        function ObjectVisualData3D() {
            _classCallCheck(this, ObjectVisualData3D);

            // Mesh group object
            this.meshGrp = null;

            // Name of the shader
            this.shaderID = null;

            // Initial color of the object
            this.color = new __WEBPACK_IMPORTED_MODULE_0__common_color__["a" /* Color */]();

            // mesh file path
            this.meshFilePath = null;
        }

        // 
        //  DESC: Copy the passed in data
        //


        _createClass(ObjectVisualData3D, [{
            key: 'copy',
            value: function copy(obj) {
                this.shaderID = obj.shaderID;
                this.meshFilePath = obj.meshFilePath;
                this.color.copy(obj.color);
                this.meshGrp = obj.meshGrp;
            }

            // 
            //  DESC: Load the object data
            //

        }, {
            key: 'loadObjData',
            value: function loadObjData(node) {
                var visualNode = node.getElementsByTagName('visual');
                if (visualNode.length) {
                    var attr = visualNode[0].getAttribute('file');
                    if (attr) this.meshFilePath = attr;

                    // The shader node determines which shader to use
                    var shaderNode = visualNode[0].getElementsByTagName('shader');
                    if (shaderNode.length) {
                        this.shaderID = shaderNode[0].getAttribute('id');
                    }

                    // Load the color
                    this.color = __WEBPACK_IMPORTED_MODULE_2__utilities_xmlparsehelper__["b" /* loadColor */](visualNode[0], this.color);
                }
            }

            // 
            //  DESC: Add the textures to the mesh
            //

        }, {
            key: 'addTexturesToMesh',
            value: function addTexturesToMesh(group) {
                for (var i = 0; i < this.meshGrp.meshAry.length; ++i) {
                    for (var j = 0; j < this.meshGrp.meshAry[i].textureIndexAry.length; ++j) {
                        var textIndex = this.meshGrp.meshAry[i].textureIndexAry[j];

                        var textPath = this.meshGrp.uniqueTexturePathAry[textIndex].path;

                        this.meshGrp.meshAry[i].textureAry.push(__WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__["a" /* textureManager */].getTexture(group, textPath));
                    }
                }
            }

            // 
            //  DESC: Is this genType active
            //

        }, {
            key: 'isActive',
            value: function isActive() {
                return this.meshGrp !== null;
            }
        }]);

        return ObjectVisualData3D;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ObjectVisualData3D;

    /***/
},
/* 71 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    // 
    //  FILE NAME: keycodeaction.js
    //  DESC:      Class for holding key codes to test for action events
    //


    var KeyCodeAction = function () {
        function KeyCodeAction(id) {
            _classCallCheck(this, KeyCodeAction);

            this.idAry = [id];
        }

        // Set additional id's


        _createClass(KeyCodeAction, [{
            key: 'setId',
            value: function setId(id) {
                // Only set id's that are positive numbers
                if (id > -1) this.idAry.push(id);
            }

            // Remove an id

        }, {
            key: 'removeId',
            value: function removeId(id) {
                var index = this.idAry.indexOf(id);

                if (index > -1) this.idAry.splice(index, 1);
            }

            // Check for action

        }, {
            key: 'wasAction',
            value: function wasAction(id) {
                if (this.idAry.indexOf(id) > -1) return true;

                return false;
            }
        }]);

        return KeyCodeAction;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = KeyCodeAction;

    /***/
},
/* 72 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__2d_object2d__ = __webpack_require__(25);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_dynamicoffset__ = __webpack_require__(30);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__scrollparam__ = __webpack_require__(42);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__utilities_settings__ = __webpack_require__(9);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__2d_sprite2d__ = __webpack_require__(13);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__gui_uicontrolnavnode__ = __webpack_require__(44);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__objectdatamanager_objectdatamanager__ = __webpack_require__(11);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__script_scriptcomponent__ = __webpack_require__(21);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__script_scriptmanager__ = __webpack_require__(14);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__uicontrolfactory__ = __webpack_require__(34);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_11__utilities_xmlparsehelper__ = __webpack_require__(4);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_12__common_defs__ = __webpack_require__(0);
    // 
    //  FILE NAME: menu.js
    //  DESC:      Class for user interface menu
    //


    var Menu = function (_WEBPACK_IMPORTED_MO17) {
        _inherits(Menu, _WEBPACK_IMPORTED_MO17);

        function Menu(name, group, filePath) {
            _classCallCheck(this, Menu);

            // This menu's name
            var _this31 = _possibleConstructorReturn(this, (Menu.__proto__ || Object.getPrototypeOf(Menu)).call(this));

            _this31.name = name;

            // Group name
            _this31.group = group;

            // File path
            _this31.filePath = filePath;

            // Array of menu static sprites
            _this31.spriteAry = [];

            // Array list of static controls
            _this31.staticControlAry = [];

            // Array list of mouse only controls
            _this31.mouseOnlyControlAry = [];

            // Array list of controls
            _this31.controlAry = [];

            // Array list of navigation nodes
            _this31.controlNodeAry = [];

            // Map container of controls for easy name access
            // NOTE: This container does not own it's pointers.
            _this31.controlMap = new Map();

            // Current active node
            _this31.activeNode = null;

            // menu state
            _this31.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["E" /* ECS_NULL */];

            // Dynamic offset
            _this31.dynamicOffset = new __WEBPACK_IMPORTED_MODULE_1__common_dynamicoffset__["a" /* DynamicOffset */]();

            // Scrolling parameters
            _this31.scrollParam = new __WEBPACK_IMPORTED_MODULE_2__scrollparam__["a" /* ScrollParam */]();

            // Base smart Gui control scoped pointer
            _this31.smartGui = null;

            // menu alpha value
            _this31.alpha = 0;

            // The script conponent
            _this31.scriptComponent = new __WEBPACK_IMPORTED_MODULE_8__script_scriptcomponent__["a" /* ScriptComponent */]();

            // Script object map. Prepare scripts by name
            _this31.scriptFactoryMap = new Map();

            // The menu needs to default hidden
            _this31.setVisible(false);
            return _this31;
        }

        // 
        //  DESC: Load the menu info from file
        //


        _createClass(Menu, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                // Init the script factory functions
                this.initScriptFactoryFunctions(node);

                // Load the scroll data from node
                this.scrollParam.loadFromNode(node.getElementsByTagName('scroll'));

                // Get the static sprite
                var nodeLst = node.getElementsByTagName('spriteList');
                if (nodeLst.length) {
                    var spriteNode = nodeLst[0].children;

                    for (var i = 0; i < spriteNode.length; ++i) {
                        this.loadStaticSpriteFromNode(spriteNode[i]);
                    }
                }

                // Get the static menu controls node
                nodeLst = node.getElementsByTagName('staticMenuControls');
                if (nodeLst.length) {
                    var controlNode = nodeLst[0].children;

                    for (var _i11 = 0; _i11 < controlNode.length; ++_i11) {
                        this.loadStaticControlFromNode(controlNode[_i11]);
                    }
                }

                // Get the mouse only menu controls node
                nodeLst = node.getElementsByTagName('mouseOnlyControls');
                if (nodeLst.length) {
                    var _controlNode = nodeLst[0].children;

                    for (var _i12 = 0; _i12 < _controlNode.length; ++_i12) {
                        this.loadMouseOnlyControlFromNode(_controlNode[_i12]);
                    }
                }

                // Get the menu controls
                nodeLst = node.getElementsByTagName('menuControls');
                if (nodeLst.length) {
                    var _controlNode2 = nodeLst[0].children;

                    // map to help setup the node pointers
                    var navNodeMap = new Map();

                    // Load the controls
                    for (var _i13 = 0; _i13 < _controlNode2.length; ++_i13) {
                        this.loadControlFromNode(_controlNode2[_i13], navNodeMap);
                    } // Map the controls to their respective nodes
                    for (var _i14 = 0; _i14 < _controlNode2.length; ++_i14) {
                        this.findNodes(_controlNode2[_i14], _i14, navNodeMap);
                    }
                }
            }

            // 
            //  DESC: Init the script factory functions and add them to the map
            //        This function loads the attribute info reguardless of what it is
            //

        }, {
            key: 'initScriptFactoryFunctions',
            value: function initScriptFactoryFunctions(node) {
                // Check for scripting
                var scriptLst = node.getElementsByTagName('scriptLst');
                if (scriptLst.length) {
                    var scriptNode = scriptLst[0].children;

                    for (var i = 0; i < scriptNode.length; ++i) {
                        var attr = scriptNode[i].attributes[0];

                        if (attr) {
                            this.scriptFactoryMap.set(attr.name, __WEBPACK_IMPORTED_MODULE_9__script_scriptmanager__["a" /* scriptManager */].get(attr.value));
                        }
                    }
                }
            }

            // 
            //  DESC: Load a static sprite from an XML node
            //

        }, {
            key: 'loadStaticSpriteFromNode',
            value: function loadStaticSpriteFromNode(node) {
                // Get the type of object
                var objectName = node.getAttribute('objectName');

                // Allocate the static sprite and add it to the array
                var sprite = new __WEBPACK_IMPORTED_MODULE_4__2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_7__objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData(this.group, objectName));
                this.spriteAry.push(sprite);

                // Load the transform data
                sprite.loadTransFromNode(node);

                // Init the script factory functions
                sprite.initScriptFactoryFunctions(node);
            }

            // 
            //  DESC: Load static controls from an XML node
            //

        }, {
            key: 'loadStaticControlFromNode',
            value: function loadStaticControlFromNode(node) {
                // New up the control with its respected control type
                var control = __WEBPACK_IMPORTED_MODULE_10__uicontrolfactory__["a" /* create */](node, this.group);
                this.staticControlAry.push(control);

                // Does this control have a name then add it to the map
                if (control.name) this.controlMap.set(control.name, control);
            }

            // 
            //  DESC: Load mouse only controls from an XML node
            //

        }, {
            key: 'loadMouseOnlyControlFromNode',
            value: function loadMouseOnlyControlFromNode(node) {
                // New up the control with its respected control type
                var control = __WEBPACK_IMPORTED_MODULE_10__uicontrolfactory__["a" /* create */](node, this.group);
                this.mouseOnlyControlAry.push(control);

                // Does this control have a name then add it to the map
                if (control.name) this.controlMap.set(control.name, control);
            }

            // 
            //  DESC: Load a control from an XML node
            //

        }, {
            key: 'loadControlFromNode',
            value: function loadControlFromNode(node, navNodeMap) {
                // New up the control with its respected control type
                var control = __WEBPACK_IMPORTED_MODULE_10__uicontrolfactory__["a" /* create */](node, this.group);
                this.controlAry.push(control);

                // Does this control have a name then add it to the map
                if (control.name) {
                    // Check for duplicate names
                    if (this.controlMap.has(control.name)) throw new Error('Duplicate control name! (' + control.name + ')');

                    // Map of menu controls
                    this.controlMap.set(control.name, control);

                    // Add a node to the array with it's control
                    var navNode = new __WEBPACK_IMPORTED_MODULE_6__gui_uicontrolnavnode__["a" /* UIControlNavNode */](control);
                    this.controlNodeAry.push(navNode);

                    // Map of menu control nodes
                    navNodeMap.set(control.name, navNode);
                }
            }

            // 
            //  DESC: Load the dynamic offset data from node
            //

        }, {
            key: 'loadDynamicOffsetFromNode',
            value: function loadDynamicOffsetFromNode(node) {
                // Load the dynamic offset
                this.dynamicOffset = __WEBPACK_IMPORTED_MODULE_11__utilities_xmlparsehelper__["c" /* loadDynamicOffset */](node);

                // Set the dynamic position
                this.setDynamicPos();
            }

            // 
            //  DESC: Set the dynamic position
            //

        }, {
            key: 'setDynamicPos',
            value: function setDynamicPos() {
                // Position the menu based on the dynamic offset
                if (this.dynamicOffset) this.setPos(this.dynamicOffset.getPos(__WEBPACK_IMPORTED_MODULE_3__utilities_settings__["a" /* settings */].defaultSize_half));
            }

            // 
            //  DESC: Reset the dynamic position
            //

        }, {
            key: 'resetDynamicPos',
            value: function resetDynamicPos() {
                this.setDynamicPos();

                for (var i = 0; i < this.staticControlAry.length; ++i) {
                    this.staticControlAry[i].setDynamicPos();
                }for (var _i15 = 0; _i15 < this.mouseOnlyControlAry.length; ++_i15) {
                    this.mouseOnlyControlAry[_i15].setDynamicPos();
                }for (var _i16 = 0; _i16 < this.controlAry.length; ++_i16) {
                    this.controlAry[_i16].setDynamicPos();
                }
            }

            // 
            //  DESC: Find the reference nodes
            //

        }, {
            key: 'findNodes',
            value: function findNodes(node, nodeIndex, navNodeMap) {
                var navNode = node.getElementsByTagName('navigate');
                if (navNode.length) {
                    this.setNodes(navNode, nodeIndex, 'up', __WEBPACK_IMPORTED_MODULE_12__common_defs__["_41" /* ENAV_NODE_UP */], navNodeMap);
                    this.setNodes(navNode, nodeIndex, 'down', __WEBPACK_IMPORTED_MODULE_12__common_defs__["_38" /* ENAV_NODE_DOWN */], navNodeMap);
                    this.setNodes(navNode, nodeIndex, 'left', __WEBPACK_IMPORTED_MODULE_12__common_defs__["_39" /* ENAV_NODE_LEFT */], navNodeMap);
                    this.setNodes(navNode, nodeIndex, 'right', __WEBPACK_IMPORTED_MODULE_12__common_defs__["_40" /* ENAV_NODE_RIGHT */], navNodeMap);
                }
            }

            // 
            //  DESC: Find the reference nodes
            //

        }, {
            key: 'setNodes',
            value: function setNodes(node, nodeIndex, attrStr, navId, navNodeMap) {
                var attr = node[0].getAttribute(attrStr);
                if (attr) {
                    var ctrlNode = navNodeMap.get(attr);
                    if (ctrlNode !== undefined) this.controlNodeAry[nodeIndex].setNode(navId, ctrlNode);else throw new Error('Control node doesn\'t exist! (' + attr + ', ' + attrStr + ')');
                }
            }

            // 
            //  DESC: Init the menu controls
            //

        }, {
            key: 'init',
            value: function init() {
                for (var i = 0; i < this.staticControlAry.length; ++i) {
                    this.staticControlAry[i].init();
                }for (var _i17 = 0; _i17 < this.mouseOnlyControlAry.length; ++_i17) {
                    this.mouseOnlyControlAry[_i17].init();
                }for (var _i18 = 0; _i18 < this.controlAry.length; ++_i18) {
                    this.controlAry[_i18].init();
                }
            } // Init

            // 
            //  DESC: Init the menu controls
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                for (var i = 0; i < this.staticControlAry.length; ++i) {
                    this.staticControlAry[i].cleanUp();
                }for (var _i19 = 0; _i19 < this.mouseOnlyControlAry.length; ++_i19) {
                    this.mouseOnlyControlAry[_i19].cleanUp();
                }for (var _i20 = 0; _i20 < this.controlAry.length; ++_i20) {
                    this.controlAry[_i20].cleanUp();
                }
            } // CleanUp

            // 
            //  DESC: Activate this menu because it's probably a root menu
            //

        }, {
            key: 'activateMenu',
            value: function activateMenu() {
                this.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["_34" /* EMS_IDLE */];
                this.setVisible(true);
                this.setAlpha(1);
                this.activateFirstInactiveControl();
            }

            // 
            //  DESC: Update the menu
            //

        }, {
            key: 'update',
            value: function update() {
                this.scriptComponent.update();

                if (this.isVisible()) {
                    for (var i = 0; i < this.spriteAry.length; ++i) {
                        this.spriteAry[i].update();
                    }for (var _i21 = 0; _i21 < this.staticControlAry.length; ++_i21) {
                        this.staticControlAry[_i21].update();
                    }for (var _i22 = 0; _i22 < this.mouseOnlyControlAry.length; ++_i22) {
                        this.mouseOnlyControlAry[_i22].update();
                    }for (var _i23 = 0; _i23 < this.controlAry.length; ++_i23) {
                        this.controlAry[_i23].update();
                    }
                }
            }

            // 
            //  DESC: Transform the menu
            //

        }, {
            key: 'doTransform',
            value: function doTransform() {
                if (this.isVisible()) {
                    this.transform();

                    for (var i = 0; i < this.spriteAry.length; ++i) {
                        this.spriteAry[i].transform(this.matrix, this.wasWorldPosTranformed());
                    }for (var _i24 = 0; _i24 < this.staticControlAry.length; ++_i24) {
                        this.staticControlAry[_i24].doTransform(this);
                    }for (var _i25 = 0; _i25 < this.mouseOnlyControlAry.length; ++_i25) {
                        this.mouseOnlyControlAry[_i25].doTransform(this);
                    }for (var _i26 = 0; _i26 < this.controlAry.length; ++_i26) {
                        this.controlAry[_i26].doTransform(this);
                    }
                }
            }

            // 
            //  DESC: do the render
            //

        }, {
            key: 'render',
            value: function render(matrix) {
                if (this.isVisible()) {
                    for (var i = 0; i < this.spriteAry.length; ++i) {
                        this.spriteAry[i].render(matrix);
                    }for (var _i27 = 0; _i27 < this.staticControlAry.length; ++_i27) {
                        this.staticControlAry[_i27].render(matrix);
                    }for (var _i28 = 0; _i28 < this.mouseOnlyControlAry.length; ++_i28) {
                        this.mouseOnlyControlAry[_i28].render(matrix);
                    }for (var _i29 = 0; _i29 < this.controlAry.length; ++_i29) {
                        this.controlAry[_i29].render(matrix);
                    }
                }
            }

            // 
            //  DESC: Handle events
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                if (event instanceof CustomEvent) {
                    // Have the controls handle events
                    for (var i = 0; i < this.controlAry.length; ++i) {
                        this.controlAry[i].handleEvent(event);
                    }for (var _i30 = 0; _i30 < this.mouseOnlyControlAry.length; ++_i30) {
                        this.mouseOnlyControlAry[_i30].handleEvent(event);
                    }if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_15" /* EGE_MENU_TRANS_IN */]) {
                        this.onTransIn(event);
                    } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_16" /* EGE_MENU_TRANS_OUT */]) {
                        this.onTransOut(event);
                    } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_1" /* EGE_MENU_REACTIVATE */]) {
                        this.onReactivate(event);
                    } else if (this.state === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_34" /* EMS_IDLE */]) {
                        if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_7" /* EGE_MENU_SELECT_ACTION */]) {
                            this.onSelectAction(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_9" /* EGE_MENU_SET_ACTIVE_CONTROL */]) {
                            this.onSetActiveControl(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_6" /* EGE_MENU_SCROLL_UP */]) {
                            this.onUpAction(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_3" /* EGE_MENU_SCROLL_DOWN */]) {
                            this.onDownAction(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_4" /* EGE_MENU_SCROLL_LEFT */]) {
                            this.onLeftAction(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_5" /* EGE_MENU_SCROLL_RIGHT */]) {
                            this.onRightAction(event);
                        } else if (event.detail.type >= __WEBPACK_IMPORTED_MODULE_12__common_defs__["_17" /* EGE_MENU_UP_ACTION */] && event.detail.type <= __WEBPACK_IMPORTED_MODULE_12__common_defs__["_2" /* EGE_MENU_RIGHT_ACTION */]) {
                            if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_12__common_defs__["k" /* EAP_DOWN */]) {
                                if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_17" /* EGE_MENU_UP_ACTION */]) {
                                    this.onUpAction(event);
                                } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["X" /* EGE_MENU_DOWN_ACTION */]) {
                                    this.onDownAction(event);
                                }
                                if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_0" /* EGE_MENU_LEFT_ACTION */]) {
                                    this.onLeftAction(event);
                                } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_2" /* EGE_MENU_RIGHT_ACTION */]) {
                                    this.onRightAction(event);
                                }
                            }
                        }
                    }
                } else if (this.state === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_34" /* EMS_IDLE */]) {
                    if (event.type === 'mousemove') {
                        this.onMouseMove(event);
                    }
                }

                // Handle any smart menu events
                this.smartHandleEvent(event);
            }

            // 
            //  DESC: Handle OnUpAction message
            //

        }, {
            key: 'onUpAction',
            value: function onUpAction(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_12__common_defs__["_41" /* ENAV_NODE_UP */]);
            }

            // 
            //  DESC: Handle OnMenuDown message
            //

        }, {
            key: 'onDownAction',
            value: function onDownAction(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_12__common_defs__["_38" /* ENAV_NODE_DOWN */]);
            }

            // 
            //  DESC: Handle OnMenuLeft message
            //

        }, {
            key: 'onLeftAction',
            value: function onLeftAction(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_12__common_defs__["_39" /* ENAV_NODE_LEFT */]);
            }

            // 
            //  DESC: Handle OnRightAction message
            //

        }, {
            key: 'onRightAction',
            value: function onRightAction(event) {
                this.navigateMenu(__WEBPACK_IMPORTED_MODULE_12__common_defs__["_40" /* ENAV_NODE_RIGHT */]);
            }

            // 
            //  DESC: Navigate the menu. Find the next control node that isn't
            //        disabled and make it the active control node
            //

        }, {
            key: 'navigateMenu',
            value: function navigateMenu(navNodeAction) {
                if (this.activeNode !== null) {
                    var navNode = this.activeNode;

                    do {
                        navNode = navNode.getNode(navNodeAction);

                        if (navNode === null) {
                            break;
                        } else if (!navNode.uiControl.isDisabled()) {
                            this.activeNode = navNode;

                            __WEBPACK_IMPORTED_MODULE_5__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_12__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_12__common_defs__["A" /* ECS_ACTIVE */], navNode.uiControl);

                            break;
                        }
                    } while (true);
                }
            }

            // 
            //  DESC: Handle OnMouseMove message
            //

        }, {
            key: 'onMouseMove',
            value: function onMouseMove(event) {
                for (var i = 0; i < this.controlNodeAry.length; ++i) {
                    if (this.controlNodeAry[i].uiControl.onMouseMove(event)) this.activeNode = this.controlNodeAry[i];else this.controlNodeAry[i].uiControl.deactivateControl();
                }

                for (var _i31 = 0; _i31 < this.mouseOnlyControlAry.length; ++_i31) {
                    if (!this.mouseOnlyControlAry[_i31].onMouseMove(event)) this.mouseOnlyControlAry[_i31].deactivateControl();
                }
            }

            // 
            //  DESC: Handle OnSelectAction message
            //

        }, {
            key: 'onSelectAction',
            value: function onSelectAction(event) {
                var selectionFound = false;

                if (this.activeNode !== null && this.activeNode.uiControl.handleSelectAction(event)) {
                    selectionFound = true;

                    // Set the state to active which will block all messages until the state is reset to idle
                    if (this.activeNode.uiControl.actionType > __WEBPACK_IMPORTED_MODULE_12__common_defs__["w" /* ECAT_NULL */]) this.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["_33" /* EMS_ACTIVE */];
                } else if (event.detail.arg[__WEBPACK_IMPORTED_MODULE_12__common_defs__["_46" /* ESMA_DEVICE_TYPE */]] === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_57" /* MOUSE */]) {
                    // For mouse only controls
                    for (var i = 0; i < this.mouseOnlyControlAry.length; ++i) {
                        if (this.mouseOnlyControlAry[i].handleSelectAction(event)) {
                            selectionFound = true;

                            // Set the state to active which will block all messages until the state is reset to idle
                            if (this.mouseOnlyControlAry[i].actionType > __WEBPACK_IMPORTED_MODULE_12__common_defs__["w" /* ECAT_NULL */]) this.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["_33" /* EMS_ACTIVE */];

                            break;
                        }
                    }
                }

                // Try to handle touch presses on a non-active control
                // The mouse just happends to be clicked over a non-active control
                if (!selectionFound && event.detail.arg[__WEBPACK_IMPORTED_MODULE_12__common_defs__["_46" /* ESMA_DEVICE_TYPE */]] === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_57" /* MOUSE */]) {
                    // Deactivate the control that should be active
                    if (this.activeNode !== null && event.detail.arg[__WEBPACK_IMPORTED_MODULE_12__common_defs__["_49" /* ESMA_PRESS_TYPE */]] === this.activeNode.uiControl.mouseSelectType) {
                        this.activeNode.uiControl.deactivateControl();

                        // Go through all the controls on this menu to try to find the one clicked on
                        for (var _i32 = 0; _i32 < this.controlAry.length; ++_i32) {
                            if (this.controlAry[_i32].handleSelectAction(event)) {
                                // Set the state to active which will block all messages until the state is reset to idle
                                if (this.activeNode.uiControl.actionType > __WEBPACK_IMPORTED_MODULE_12__common_defs__["w" /* ECAT_NULL */]) this.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["_33" /* EMS_ACTIVE */];

                                break;
                            }
                        }
                    }
                }
            }

            // 
            //  DESC: Handle OnSetActiveControl message
            //

        }, {
            key: 'onSetActiveControl',
            value: function onSetActiveControl(event) {
                // Set the first inactive control to active
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_12__common_defs__["i" /* EAC_FIRST_ACTIVE_CONTROL */]) this.activateFirstInactiveControl();
            }

            // 
            //  DESC: Handle OnReactivate message
            //

        }, {
            key: 'onReactivate',
            value: function onReactivate(event) {
                this.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["_34" /* EMS_IDLE */];
            }

            // 
            //  DESC: Handle OnTransIn message
            //

        }, {
            key: 'onTransIn',
            value: function onTransIn(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_50" /* ETC_BEGIN */]) {
                    this.prepare('transIn');

                    this.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["_33" /* EMS_ACTIVE */];
                } else if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_51" /* ETC_END */]) {
                    this.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["_34" /* EMS_IDLE */];
                }
            }

            // 
            //  DESC: Handle OnTransOut message
            //

        }, {
            key: 'onTransOut',
            value: function onTransOut(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_50" /* ETC_BEGIN */]) {
                    this.prepare('transOut');

                    this.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["_33" /* EMS_ACTIVE */];
                } else if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_51" /* ETC_END */]) {
                    this.state = __WEBPACK_IMPORTED_MODULE_12__common_defs__["_35" /* EMS_INACTIVE */];
                }
            }

            // 
            //  DESC: Prepare the script function to run
            //

        }, {
            key: 'prepare',
            value: function prepare(scriptFactoryId) {
                var scriptFactory = this.scriptFactoryMap.get(scriptFactoryId);
                if (scriptFactory) this.scriptComponent.set(scriptFactory(this));
            }

            // 
            //  DESC: Set the first inactive control to be active
            //

        }, {
            key: 'activateFirstInactiveControl',
            value: function activateFirstInactiveControl() {
                var found = false;

                // Activate the first control found and deactivate all the rest
                for (var i = 0; i < this.controlNodeAry.length; ++i) {
                    if (!found && this.controlNodeAry[i].uiControl.activateFirstInactiveControl()) {
                        this.activeNode = this.controlNodeAry[i];

                        found = true;
                    } else {
                        this.controlNodeAry[i].uiControl.deactivateControl();
                    }
                }
            }

            // 
            //  DESC: Reset all controls
            //

        }, {
            key: 'reset',
            value: function reset() {
                for (var i = 0; i < this.controlAry.length; ++i) {
                    this.controlAry[i].reset(true);
                }for (var _i33 = 0; _i33 < this.mouseOnlyControlAry.length; ++_i33) {
                    this.mouseOnlyControlAry[_i33].reset(true);
                }
            }

            // 
            //  DESC: Get the control in question
            //

        }, {
            key: 'getControl',
            value: function getControl(name) {
                // See if the control can be found
                var control = this.controlMap.get(name);

                // Make sure control is available
                if (control === undefined) throw new Error('Control being asked for is missing! (' + name + ').');

                // Pass back the control if found
                return control;
            }

            // 
            //  DESC: Get the pointer to the active control
            //

        }, {
            key: 'getActiveControl',
            value: function getActiveControl() {
                var result = null;

                for (var i = 0; i < this.controlAry.length; ++i) {
                    if (this.controlAry[i].state > __WEBPACK_IMPORTED_MODULE_12__common_defs__["C" /* ECS_INACTIVE */]) {
                        result = this.controlAry[i].getActiveControl();
                        break;
                    }
                }

                return result;
            }

            // 
            //  DESC: Does this menu use dynamic offsets
            //

        }, {
            key: 'isDynamicOffset',
            value: function isDynamicOffset() {
                return !this.dynamicOffset.isEmpty();
            }

            // 
            //  DESC: Get the scroll params
            //

        }, {
            key: 'getScrollParam',
            value: function getScrollParam(msg) {
                if (this.activeNode != null && this.activeNode.uiControl.canScroll(msg)) {
                    return this.activeNode.uiControl.scrollParam;
                }

                return this.scrollParam;
            }

            // 
            //  DESC: Do any smart create
            //

        }, {
            key: 'smartCreate',
            value: function smartCreate() {
                if (this.smartGui) this.smartGui.create();
            }

            // 
            //  DESC: Do any smart event handling
            //

        }, {
            key: 'smartHandleEvent',
            value: function smartHandleEvent(event) {
                if (this.smartGui) this.smartGui.handleEvent(event);
            }

            // 
            //  DESC: Set the alpha value of this menu
            //

        }, {
            key: 'setAlpha',
            value: function setAlpha(alpha) {
                if (this.isVisible()) {
                    for (var i = 0; i < this.spriteAry.length; ++i) {
                        this.spriteAry[i].setAlpha(alpha);
                    }for (var _i34 = 0; _i34 < this.staticControlAry.length; ++_i34) {
                        this.staticControlAry[_i34].setAlpha(alpha);
                    }for (var _i35 = 0; _i35 < this.mouseOnlyControlAry.length; ++_i35) {
                        this.mouseOnlyControlAry[_i35].setAlpha(alpha);
                    }for (var _i36 = 0; _i36 < this.controlAry.length; ++_i36) {
                        this.controlAry[_i36].setAlpha(alpha);
                    }
                }

                this.alpha = alpha;
            }

            // 
            //  DESC: Get the alpha value of this menu
            //

        }, {
            key: 'getAlpha',
            value: function getAlpha() {
                return this.alpha;
            }

            // 
            //  DESC: Is the menu idle
            //

        }, {
            key: 'isIdle',
            value: function isIdle() {
                return this.state === __WEBPACK_IMPORTED_MODULE_12__common_defs__["_34" /* EMS_IDLE */];
            }
        }]);

        return Menu;
    }(__WEBPACK_IMPORTED_MODULE_0__2d_object2d__["a" /* Object2D */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Menu;

    /***/
},
/* 73 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__managers_shadermanager__ = __webpack_require__(15);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__ = __webpack_require__(6);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__managers_vertexbuffermanager__ = __webpack_require__(19);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__managers_fontmanager__ = __webpack_require__(38);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__common_fontdata__ = __webpack_require__(74);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__utilities_matrix__ = __webpack_require__(10);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__common_color__ = __webpack_require__(16);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__common_vertex2d__ = __webpack_require__(26);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__common_defs__ = __webpack_require__(0);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_11__utilities_xmlparsehelper__ = __webpack_require__(4);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_12__utilities_genfunc__ = __webpack_require__(3);

    // 
    //  FILE NAME:  visualcomponent2d.js
    //  DESC:       Class for handling the visual part of the sprite
    //


    // Global final matrix to be reused by every render call so that an object specific
    // one doesn't have to be created each time a render call is made or a perminate one
    // allocated and heald within each class
    var gFinalMatrix = new __WEBPACK_IMPORTED_MODULE_5__utilities_matrix__["a" /* Matrix */]();

    var VisualComponent2D = function () {
        function VisualComponent2D(visualData) {
            _classCallCheck(this, VisualComponent2D);

            this.visualData = visualData;
            this.shaderData = null;
            this.vertexLocation = null;
            this.text0Location = null;
            this.uvLocation = null;
            this.matrixLocation = null;
            this.colorLocation = null;
            this.glyphLocation = null;
            this.fontData = null;
            this.VERTEX_BUF_SIZE = 20;
            this.drawMode = visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_21" /* EGT_QUAD */] || visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_23" /* EGT_SPRITE_SHEET */] ? __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].TRIANGLE_FAN : __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].TRIANGLES;
            this.indiceType = visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_18" /* EGT_FONT */] ? __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].UNSIGNED_SHORT : __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].UNSIGNED_BYTE;
            this.frameIndex = 0;
            this.glyphUV = null;
            this.vbo = visualData.vbo;
            this.ibo = visualData.ibo;
            this.iboCount = visualData.iboCount;
            this.texture = visualData.texture;
            this.color = new __WEBPACK_IMPORTED_MODULE_6__common_color__["a" /* Color */]();

            if (visualData.isActive()) {
                this.shaderData = __WEBPACK_IMPORTED_MODULE_0__managers_shadermanager__["a" /* shaderManager */].getShaderData(visualData.shaderID);

                // Common shader members
                this.vertexLocation = this.shaderData.getLocation('in_position');
                this.matrixLocation = this.shaderData.getLocation('cameraViewProjMatrix');
                this.colorLocation = this.shaderData.getLocation('color');

                // Do we have a texture? This could be a solid rect
                if (this.texture !== null || visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_18" /* EGT_FONT */]) {
                    this.uvLocation = this.shaderData.getLocation('in_uv');
                    this.text0Location = this.shaderData.getLocation('text0');
                }

                // Is this a sprite sheet? Get the glyph rect position
                if (visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_23" /* EGT_SPRITE_SHEET */]) {
                    this.glyphLocation = this.shaderData.getLocation('glyphRect');

                    this.glyphUV = visualData.spriteSheet.getGlyph().uv;
                    this.frameIndex = visualData.spriteSheet.defaultIndex;

                    // Local vertex scale for sprite sheets that might have glyphs of different sizes
                    this.vertexScale = new __WEBPACK_IMPORTED_MODULE_7__common_size__["a" /* Size */]();
                    this.vertexScale.copy(this.visualData.vertexScale);
                }

                // Allocate the storage for the font if this is a font sprite
                if (visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_18" /* EGT_FONT */]) this.fontData = new __WEBPACK_IMPORTED_MODULE_4__common_fontdata__["a" /* FontData */]();

                this.color.copy(this.visualData.color);
            }
        }

        //
        //  DESC: Delete the custom VBO for this font
        //


        _createClass(VisualComponent2D, [{
            key: 'deleteFontVBO',
            value: function deleteFontVBO() {
                // Delete the VBO if this is a font
                if (this.visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_18" /* EGT_FONT */] && this.vbo !== null) {
                    __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].deleteBuffer(this.vbo);
                    this.vbo = null;
                }

                // The IBO for the font is managed by the vertex buffer manager.
                // Font IBO are all the same with the only difference being
                // length of the character string.
            }

            //
            //  DESC: do the render
            //

        }, {
            key: 'render',
            value: function render(objMatrix, projMatrix) {
                if (this.allowRender()) {
                    // Bind the VBO and IBO
                    __WEBPACK_IMPORTED_MODULE_2__managers_vertexbuffermanager__["a" /* vertexBufferManager */].bind(this.vbo, this.ibo);

                    // Bind the shader.
                    __WEBPACK_IMPORTED_MODULE_0__managers_shadermanager__["a" /* shaderManager */].bind(this.shaderData);

                    // Setup the vertex attribute shader data
                    __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].vertexAttribPointer(this.vertexLocation, 3, __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].FLOAT, false, this.VERTEX_BUF_SIZE, 0);

                    if (this.texture) {
                        // Bind the texture
                        __WEBPACK_IMPORTED_MODULE_1__managers_texturemanager__["a" /* textureManager */].bind(this.texture.id);
                        __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].uniform1i(this.text0Location, 0); // 0 = TEXTURE0

                        // Setup the UV attribute shade data
                        __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].vertexAttribPointer(this.uvLocation, 2, __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].FLOAT, false, this.VERTEX_BUF_SIZE, 12);
                    }

                    // Send the color to the shader
                    __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].uniform4fv(this.colorLocation, this.color.data);

                    // If this is a quad, we need to take into account the vertex scale
                    if (this.visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_21" /* EGT_QUAD */]) {
                        // Calculate the final matrix
                        gFinalMatrix.initilizeMatrix();
                        gFinalMatrix.setScaleFromSize(this.visualData.vertexScale);
                        gFinalMatrix.mergeMatrix(objMatrix.matrix);
                        gFinalMatrix.mergeMatrix(projMatrix.matrix);

                        // Send the final matrix to the shader
                        __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].uniformMatrix4fv(this.matrixLocation, false, gFinalMatrix.matrix);
                    }
                    // If this is a sprite sheet, we need to take into account the vertex scale and glyph rect
                    else if (this.visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_23" /* EGT_SPRITE_SHEET */]) {
                            // Calculate the final matrix
                            gFinalMatrix.initilizeMatrix();
                            gFinalMatrix.setScaleFromSize(this.vertexScale);
                            gFinalMatrix.mergeMatrix(objMatrix.matrix);
                            gFinalMatrix.mergeMatrix(projMatrix.matrix);

                            // Send the final matrix to the shader
                            __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].uniformMatrix4fv(this.matrixLocation, false, gFinalMatrix.matrix);

                            // Send the glyph rect
                            __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].uniform4fv(this.glyphLocation, this.glyphUV.data);
                        }
                        // this is for scaled frame and font rendering
                        else {
                                gFinalMatrix.initilizeMatrix();
                                gFinalMatrix.mergeMatrix(objMatrix.matrix);
                                gFinalMatrix.mergeMatrix(projMatrix.matrix);

                                __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].uniformMatrix4fv(this.matrixLocation, false, gFinalMatrix.matrix);
                            }

                    __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].drawElements(this.drawMode, this.iboCount, this.indiceType, 0);
                }
            }

            //
            //  DESC: Load the font properties from XML node
            //

        }, {
            key: 'loadFontPropFromNode',
            value: function loadFontPropFromNode(node) {
                if (this.fontData) {
                    // Get the must have font related name
                    this.fontData.fontProp.fontName = node.getAttribute('fontName');

                    // Get the attributes node
                    var attrNode = node.getElementsByTagName('attributes');
                    if (attrNode.length) {
                        var attr = attrNode[0].getAttribute('kerning');
                        if (attr) this.fontData.fontProp.kerning = Number(attr);

                        attr = attrNode[0].getAttribute('spaceCharKerning');
                        if (attr) this.fontData.fontProp.spaceCharKerning = Number(attr);

                        attr = attrNode[0].getAttribute('lineWrapWidth');
                        if (attr) this.fontData.fontProp.lineWrapWidth = Number(attr);

                        attr = attrNode[0].getAttribute('lineWrapHeight');
                        if (attr) this.fontData.fontProp.lineWrapHeight = Number(attr);
                    }

                    // Get the alignment node
                    var alignmentNode = node.getElementsByTagName('alignment');
                    if (alignmentNode.length) {
                        // Set the default alignment
                        this.fontData.fontProp.hAlign = __WEBPACK_IMPORTED_MODULE_11__utilities_xmlparsehelper__["d" /* loadHorzAlignment */](alignmentNode[0], __WEBPACK_IMPORTED_MODULE_10__common_defs__["_24" /* EHA_HORZ_CENTER */]);
                        this.fontData.fontProp.vAlign = __WEBPACK_IMPORTED_MODULE_11__utilities_xmlparsehelper__["k" /* loadVertAlignment */](alignmentNode[0], __WEBPACK_IMPORTED_MODULE_10__common_defs__["_53" /* EVA_VERT_CENTER */]);
                    }
                }
            }

            //
            //  DESC: Create the font string from data
            //

        }, {
            key: 'createFontStringFromData',
            value: function createFontStringFromData() {
                if (this.fontData !== null && this.fontData.fontString) this.createFontString(this.fontData.fontString);
            }

            //
            //  DESC: Create the font string
            //

        }, {
            key: 'createFontString',
            value: function createFontString(fontString) {
                // Qualify if we want to build the font string
                if (this.fontData !== null && fontString !== '' && this.fontData.fontProp.fontName !== null && (fontString !== this.fontData.fontString || this.vbo === null)) {
                    this.fontData.fontStrSize.reset();
                    var lastCharDif = 0;

                    var font = __WEBPACK_IMPORTED_MODULE_3__managers_fontmanager__["a" /* fontManager */].getFont(this.fontData.fontProp.fontName);

                    this.texture = font.texture;

                    this.fontData.fontString = fontString;

                    // count up the number of space characters
                    var spaceCharCount = __WEBPACK_IMPORTED_MODULE_12__utilities_genfunc__["a" /* countStrOccurrence */](this.fontData.fontString, ' ');

                    // count up the number of bar | characters
                    var barCharCount = __WEBPACK_IMPORTED_MODULE_12__utilities_genfunc__["a" /* countStrOccurrence */](this.fontData.fontString, '|');

                    // Size of the allocation
                    var charCount = this.fontData.fontString.length - spaceCharCount - barCharCount;
                    this.iboCount = charCount * 6;

                    // Set a flag to indicate if the IBO should be built
                    var BUILD_FONT_IBO = this.iboCount > __WEBPACK_IMPORTED_MODULE_2__managers_vertexbuffermanager__["a" /* vertexBufferManager */].currentMaxFontIndices;

                    // Allocate the vert array
                    var vertAry = new Array(charCount * 4 * 5);

                    // Create a buffer to hold the indicies
                    var indexAry = null;

                    // Should we build or rebuild the font IBO
                    if (BUILD_FONT_IBO) indexAry = new Array(this.iboCount);

                    var xOffset = 0;
                    var width = 0;
                    var lineHeightOffset = 0;
                    var lineHeightWrap = font.lineHeight + font.vertPadding + this.fontData.fontProp.lineWrapHeight;
                    var initialHeightOffset = font.baselineOffset + font.vertPadding;
                    var lineSpace = font.lineHeight - font.baselineOffset;

                    var counter = 0;
                    var vertAryIndex = 0;
                    var lineCount = 0;

                    // Get the size of the texture
                    var textureSize = font.texture.size;

                    // Handle the horizontal alignment
                    var lineWidthOffsetAry = this.calcLineWidthOffset(font, this.fontData.fontString);

                    // Set the initial line offset
                    xOffset = lineWidthOffsetAry[lineCount++];

                    // Handle the vertical alighnmenrt
                    if (this.fontData.fontProp.vAlign === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_54" /* EVA_VERT_TOP */]) lineHeightOffset = -initialHeightOffset;

                    if (this.fontData.fontProp.vAlign === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_53" /* EVA_VERT_CENTER */]) {
                        lineHeightOffset = -(initialHeightOffset - (font.baselineOffset - lineSpace) / 2 - font.vertPadding);

                        if (lineWidthOffsetAry.length > 1) lineHeightOffset = lineHeightWrap * lineWidthOffsetAry.length / 2 - font.baselineOffset;
                    } else if (this.fontData.fontProp.vAlign === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_52" /* EVA_VERT_BOTTOM */]) {
                        lineHeightOffset = -(initialHeightOffset - font.baselineOffset - font.vertPadding);

                        if (lineWidthOffsetAry.length > 1) lineHeightOffset += lineHeightWrap * (lineWidthOffsetAry.length - 1);
                    }

                    // Remove any fractional component of the line height offset
                    lineHeightOffset = Math.trunc(lineHeightOffset);

                    // Setup each character in the vertex buffer
                    for (var i = 0; i < this.fontData.fontString.length; ++i) {
                        var _id3 = this.fontData.fontString.charCodeAt(i);

                        // Line wrap if '|' character was used
                        if (_id3 === __WEBPACK_IMPORTED_MODULE_10__common_defs__["d" /* CHAR_CODE_PIPE */]) {
                            xOffset = lineWidthOffsetAry[lineCount];
                            width = 0;

                            lineHeightOffset += -lineHeightWrap;
                            ++lineCount;
                        } else {
                            // See if we can find the character
                            var charData = font.getCharData(_id3);

                            // Ignore space characters
                            if (_id3 != __WEBPACK_IMPORTED_MODULE_10__common_defs__["e" /* CHAR_CODE_SPACE */]) {
                                var rect = charData.rect;

                                var yOffset = font.lineHeight - rect.y2 - charData.offset.h + lineHeightOffset;

                                // Check if the width or height is odd. If so, we offset
                                // by 0.5 for proper orthographic rendering
                                var additionalOffsetX = 0;
                                if (Math.trunc(rect.x2) % 2 != 0) additionalOffsetX = 0.5;

                                var additionalOffsetY = 0;
                                if (Math.trunc(rect.y2) % 2 != 0) additionalOffsetY = 0.5;

                                vertAry[vertAryIndex] = xOffset + charData.offset.w + additionalOffsetX;
                                vertAry[vertAryIndex + 1] = yOffset + additionalOffsetY;
                                vertAry[vertAryIndex + 2] = 0;
                                vertAry[vertAryIndex + 3] = rect.x1 / textureSize.w;
                                vertAry[vertAryIndex + 4] = (rect.y1 + rect.y2) / textureSize.h;

                                // Calculate the second vertex of the first face
                                vertAry[vertAryIndex + 5] = xOffset + rect.x2 + charData.offset.w + additionalOffsetX;
                                vertAry[vertAryIndex + 6] = yOffset + rect.y2 + additionalOffsetY;
                                vertAry[vertAryIndex + 7] = 0;
                                vertAry[vertAryIndex + 8] = (rect.x1 + rect.x2) / textureSize.w;
                                vertAry[vertAryIndex + 9] = rect.y1 / textureSize.h;

                                // Calculate the third vertex of the first face
                                vertAry[vertAryIndex + 10] = vertAry[vertAryIndex];
                                vertAry[vertAryIndex + 11] = vertAry[vertAryIndex + 6];
                                vertAry[vertAryIndex + 12] = 0;
                                vertAry[vertAryIndex + 13] = vertAry[vertAryIndex + 3];
                                vertAry[vertAryIndex + 14] = vertAry[vertAryIndex + 9];

                                // Calculate the second vertex of the second face
                                vertAry[vertAryIndex + 15] = vertAry[vertAryIndex + 5];
                                vertAry[vertAryIndex + 16] = vertAry[vertAryIndex + 1];
                                vertAry[vertAryIndex + 17] = 0;
                                vertAry[vertAryIndex + 18] = vertAry[vertAryIndex + 8];
                                vertAry[vertAryIndex + 19] = vertAry[vertAryIndex + 4];

                                vertAryIndex += 20;

                                if (BUILD_FONT_IBO) {
                                    // Create the indicies into the VBO
                                    var arrayIndex = counter * 6;
                                    var vertIndex = counter * 4;

                                    indexAry[arrayIndex] = vertIndex;
                                    indexAry[arrayIndex + 1] = vertIndex + 1;
                                    indexAry[arrayIndex + 2] = vertIndex + 2;

                                    indexAry[arrayIndex + 3] = vertIndex;
                                    indexAry[arrayIndex + 4] = vertIndex + 3;
                                    indexAry[arrayIndex + 5] = vertIndex + 1;
                                }

                                ++counter;
                            }

                            // Inc the font position
                            var inc = charData.xAdvance + this.fontData.fontProp.kerning + font.horzPadding;

                            // Add in any additional spacing for the space character
                            if (_id3 === __WEBPACK_IMPORTED_MODULE_10__common_defs__["e" /* CHAR_CODE_SPACE */]) inc += this.fontData.fontProp.spaceCharKerning;

                            width += inc;
                            xOffset += inc;

                            // Get the longest width of this font string
                            if (this.fontData.fontStrSize.w < width) {
                                this.fontData.fontStrSize.w = width;

                                // This is the space between this character and the next.
                                // Save this difference so that it can be subtracted at the end
                                lastCharDif = inc - charData.rect.x2;
                            }

                            // Wrap to another line
                            if (_id3 === __WEBPACK_IMPORTED_MODULE_10__common_defs__["e" /* CHAR_CODE_SPACE */] && this.fontData.fontProp.lineWrapWidth > 0) {
                                var nextWord = 0;

                                // Get the length of the next word to see if if should wrap
                                for (var j = i + 1; j < this.fontData.fontString.length; ++j) {
                                    _id3 = this.fontData.fontString[j];

                                    if (_id3 != __WEBPACK_IMPORTED_MODULE_10__common_defs__["d" /* CHAR_CODE_PIPE */]) {
                                        // See if we can find the character
                                        var anotherCharData = font.getCharData(_id3);

                                        // Break here when space is found
                                        // Don't add the space to the size of the next word
                                        if (_id3 === __WEBPACK_IMPORTED_MODULE_10__common_defs__["e" /* CHAR_CODE_SPACE */]) break;

                                        // Don't count the
                                        nextWord += anotherCharData.xAdvance + this.fontData.fontProp.kerning + font.horzPadding;
                                    }
                                }

                                if (width + nextWord >= this.fontData.fontProp.lineWrapWidth) {
                                    xOffset = lineWidthOffsetAry[lineCount++];
                                    width = 0;

                                    lineHeightOffset += -lineHeightWrap;
                                }
                            }
                        }
                    }

                    // Subtract the extra space after the last character
                    this.fontData.fontStrSize.w -= lastCharDif;
                    this.fontData.fontStrSize.h = font.lineHeight;

                    // Save the data
                    // If one doesn't exist, create the VBO and IBO for this font
                    if (this.vbo === null) this.vbo = __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].createBuffer();

                    __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].ARRAY_BUFFER, this.vbo);
                    __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].bufferData(__WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].ARRAY_BUFFER, new Float32Array(vertAry), __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].STATIC_DRAW);
                    __WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].bindBuffer(__WEBPACK_IMPORTED_MODULE_9__system_device__["b" /* gl */].ARRAY_BUFFER, null);

                    // All fonts share the same IBO because it's always the same and the only difference is it's length
                    // This updates the current IBO if it exceeds the current max
                    this.ibo = __WEBPACK_IMPORTED_MODULE_2__managers_vertexbuffermanager__["a" /* vertexBufferManager */].createDynamicFontIBO(__WEBPACK_IMPORTED_MODULE_3__managers_fontmanager__["a" /* fontManager */].groupName, 'dynamic_font_ibo', indexAry, this.iboCount);
                } else if (this.fontData !== null && fontString !== '' && fontString !== this.fontData.fontString && this.vbo !== null) {
                    this.fontData.fontString = '';
                }
            }

            //
            //  DESC: Add up all the character widths
            //

        }, {
            key: 'calcLineWidthOffset',
            value: function calcLineWidthOffset(font, str) {
                var firstCharOffset = 0;
                var lastCharOffset = 0;
                var spaceWidth = 0;
                var width = 0;
                var counter = 0;
                var lineWidthOffsetAry = [];

                for (var i = 0; i < str.length; ++i) {
                    var _id4 = str.charCodeAt(i);

                    // Line wrap if '|' character was used
                    if (_id4 === __WEBPACK_IMPORTED_MODULE_10__common_defs__["d" /* CHAR_CODE_PIPE */]) {
                        // Add the line width to the vector based on horz alignment
                        this.addLineWithToAry(font, lineWidthOffsetAry, this.fontData.fontProp.hAlign, width, firstCharOffset, lastCharOffset);

                        counter = 0;
                        width = 0;
                    } else {
                        // Get the next character
                        var charData = font.getCharData(_id4);

                        if (counter === 0) firstCharOffset = charData.offset.w;

                        spaceWidth = charData.xAdvance + this.fontData.fontProp.kerning + font.horzPadding;

                        // Add in any additional spacing for the space character
                        if (_id4 === __WEBPACK_IMPORTED_MODULE_10__common_defs__["e" /* CHAR_CODE_SPACE */]) spaceWidth += this.fontData.fontProp.spaceCharKerning;

                        width += spaceWidth;

                        if (_id4 != __WEBPACK_IMPORTED_MODULE_10__common_defs__["e" /* CHAR_CODE_SPACE */]) lastCharOffset = charData.offset.w;

                        ++counter;
                    }

                    // Wrap to another line
                    if (_id4 === __WEBPACK_IMPORTED_MODULE_10__common_defs__["e" /* CHAR_CODE_SPACE */] && this.fontData.fontProp.lineWrapWidth > 0) {
                        var nextWord = 0;

                        // Get the length of the next word to see if if should wrap
                        for (var j = i + 1; j < str.length; ++j) {
                            _id4 = str[j];

                            if (_id4 != __WEBPACK_IMPORTED_MODULE_10__common_defs__["d" /* CHAR_CODE_PIPE */]) {
                                // See if we can find the character
                                var _charData = font.getCharData(_id4);

                                // Break here when space is found
                                // Don't add the space to the size of the next word
                                if (_id4 === __WEBPACK_IMPORTED_MODULE_10__common_defs__["e" /* CHAR_CODE_SPACE */]) break;

                                // Don't count the
                                nextWord += _charData.xAdvance + this.fontData.fontProp.kerning + font.horzPadding;
                            }
                        }

                        if (width + nextWord >= this.fontData.fontProp.lineWrapWidth) {
                            // Add the line width to the vector based on horz alignment
                            this.addLineWithToAry(font, lineWidthOffsetAry, this.fontData.fontProp.hAlign, width - spaceWidth, firstCharOffset, lastCharOffset);

                            counter = 0;
                            width = 0;
                        }
                    }
                }

                // Add the line width to the vector based on horz alignment
                this.addLineWithToAry(font, lineWidthOffsetAry, this.fontData.fontProp.hAlign, width, firstCharOffset, lastCharOffset);

                return lineWidthOffsetAry;
            }

            //
            //  DESC: Add the line width to the array based on horz alignment
            //

        }, {
            key: 'addLineWithToAry',
            value: function addLineWithToAry(font, lineWidthOffsetAry, hAlign, width, firstCharOffset, lastCharOffset) {
                if (hAlign === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_25" /* EHA_HORZ_LEFT */]) lineWidthOffsetAry.push(-(firstCharOffset + font.horzPadding));else if (hAlign === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_24" /* EHA_HORZ_CENTER */]) lineWidthOffsetAry.push(-((width + (firstCharOffset + lastCharOffset)) / 2));else if (hAlign === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_26" /* EHA_HORZ_RIGHT */]) lineWidthOffsetAry.push(-(width - lastCharOffset - font.horzPadding));

                // Remove any fractional component of the last index
                lineWidthOffsetAry[lineWidthOffsetAry.length - 1] = Math.trunc(lineWidthOffsetAry[lineWidthOffsetAry.length - 1]);
            }

            //
            //  DESC: Get/Set the displayed font string
            //

        }, {
            key: 'getFontString',
            value: function getFontString() {
                if (this.fontData === null) throw new Error('Can\'t ask for the font string from a sprite that is not a sprite font!');

                return this.fontData.fontString;
            }
        }, {
            key: 'setFontString',
            value: function setFontString(fontString) {
                if (this.fontData === null) throw new Error('Can\'t set a font string for a sprite that is not a sprite font!');

                this.fontData.fontString = fontString;
            }

            //
            //  DESC: Is rendering allowed?
            //

        }, {
            key: 'allowRender',
            value: function allowRender() {
                return this.visualData.genType > __WEBPACK_IMPORTED_MODULE_10__common_defs__["_20" /* EGT_NULL */] && this.visualData.genType < __WEBPACK_IMPORTED_MODULE_10__common_defs__["_18" /* EGT_FONT */] || this.visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_18" /* EGT_FONT */] && this.fontData.fontString;
            }

            //
            //  DESC: Is this a font sprite
            //

        }, {
            key: 'isFontSprite',
            value: function isFontSprite() {
                return this.visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_18" /* EGT_FONT */];
            }

            //
            //  DESC: Set the frame ID from index
            //

        }, {
            key: 'setFrame',
            value: function setFrame(index) {
                // Only sprite sheet animations currently supported.
                if (this.visualData.genType === __WEBPACK_IMPORTED_MODULE_10__common_defs__["_23" /* EGT_SPRITE_SHEET */]) {
                    var glyph = this.visualData.spriteSheet.getGlyph(index);

                    this.vertexScale.w = glyph.size.w * this.visualData.defaultUniformScale;
                    this.vertexScale.h = glyph.size.h * this.visualData.defaultUniformScale;

                    this.glyphUV = glyph.uv;

                    this.frameIndex = index;
                }
            }

            //
            //  DESC: Get the font size
            //

        }, {
            key: 'getFontSize',
            value: function getFontSize() {
                if (!this.fontData) {
                    throw new Error('Can\'t ask for the font size from a sprite that is not a sprite font!');
                    return null;
                }

                return this.fontData.fontStrSize;
            }
        }]);

        return VisualComponent2D;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = VisualComponent2D;

    /***/
},
/* 74 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__fontproperties__ = __webpack_require__(75);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__size__ = __webpack_require__(1);

    // 
    //  FILE NAME:  fontdata.js
    //  DESC:       font data class
    //


    var FontData = function FontData() {
        _classCallCheck(this, FontData);

        // Displayed font string
        this.fontString = '';

        // Font members
        this.fontProp = new __WEBPACK_IMPORTED_MODULE_0__fontproperties__["a" /* FontProperties */]();

        // Font string size
        // Not usefull for multiline strings
        this.fontStrSize = new __WEBPACK_IMPORTED_MODULE_1__size__["a" /* Size */]();
    };
    /* harmony export (immutable) */

    __webpack_exports__["a"] = FontData;

    /***/
},
/* 75 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: fontproperties.js
    //  DESC:      font properties class
    //


    var FontProperties = function FontProperties() {
        var fontName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var hAlign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __WEBPACK_IMPORTED_MODULE_0__defs__["_24" /* EHA_HORZ_CENTER */];
        var vAlign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__defs__["_53" /* EVA_VERT_CENTER */];
        var kerning = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var spaceCharKerning = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var lineWrapWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;
        var lineWrapHeight = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;

        _classCallCheck(this, FontProperties);

        // font to use
        this.fontName = fontName;

        // horzontal alignment
        this.hAlign = hAlign;

        // vertical alignment
        this.vAlign = vAlign;

        // distance between each character
        this.kerning = kerning;

        // special kerning just for the space character
        this.spaceCharKerning = spaceCharKerning;

        // width of line to force wrap
        this.lineWrapWidth = lineWrapWidth;

        // add spacing to the lines
        this.lineWrapHeight = 0;
    };
    /* harmony export (immutable) */

    __webpack_exports__["a"] = FontProperties;

    /***/
},
/* 76 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__physicsworldmanager__ = __webpack_require__(43);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__ = __webpack_require__(32);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__Box2D_planck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__);

    // 
    //  FILE NAME: physicscomponent2d.js
    //  DESC:      Class for handling the physics part of the sprite.
    //


    var PhysicsComponent2D = function () {
        function PhysicsComponent2D(physicsData) {
            _classCallCheck(this, PhysicsComponent2D);

            // Body type
            this.bodyType = null;

            // The physics body the sprite belongs to
            this.body = null;

            // Pixels to meters conversion
            this.pixelsToMeters = 0;
            this.metersToPixels = 0;

            // Pointer to the world
            // NOTE: Do not free. We don't own this pointer.
            this.world = null;

            if (physicsData.isActive()) {
                this.world = __WEBPACK_IMPORTED_MODULE_0__physicsworldmanager__["a" /* physicsWorldManager */].getWorld(physicsData.world);

                // Re-init the constants to the values needed
                this.metersToPixels = this.world.pixelsPerMeter;
                this.pixelsToMeters = 1.0 / this.metersToPixels;
            }
        }

        // 
        //  DESC: Init the physics by creating the body and fixture
        //  NOTE: Function must be called externally at the right time
        //        when the sprite has been setup with it's initial offsets
        //


        _createClass(PhysicsComponent2D, [{
            key: 'init',
            value: function init(sprite) {
                if (this.world !== null) {
                    this.createBody(sprite);
                    this.createFixture(sprite);
                }
            }

            // 
            //  DESC: Create the body
            //

        }, {
            key: 'createBody',
            value: function createBody(sprite) {
                var physicsData = sprite.objData.physicsData;
                var worldDef = {
                    type: physicsData.bodyType,
                    position: __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"](sprite.pos.x * this.pixelsToMeters, -(sprite.pos.y * this.pixelsToMeters)),
                    angle: -sprite.rot.z,

                    linearVelocity: __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"].zero(),
                    angularVelocity: 0.0,

                    linearDamping: physicsData.linearDamping,
                    angularDamping: physicsData.angularDamping,

                    fixedRotation: physicsData.fixedRotation,
                    bullet: false,
                    gravityScale: 1.0,

                    allowSleep: true,
                    awake: true,
                    active: true,

                    userData: sprite };

                // Create the body
                this.body = this.world.createBody(worldDef);
            }

            // 
            //  DESC: Create the fixture
            //

        }, {
            key: 'createFixture',
            value: function createFixture(sprite) {
                var fixtureAry = sprite.objData.physicsData.fixtureAry;

                for (var i = 0; i < fixtureAry.length; ++i) {
                    // Create the fixture
                    if (fixtureAry[i].shape === __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Circle"].TYPE) this.createCircularShapeFixture(sprite, fixtureAry[i]);else if (fixtureAry[i].shape === __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Edge"].TYPE) this.createEdgeShapeFixture(sprite, fixtureAry[i]);else if (fixtureAry[i].shape === __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Polygon"].TYPE) this.createPolygonShapeFixture(sprite, fixtureAry[i]);else if (fixtureAry[i].shape === __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Chain"].TYPE) this.createChainShapeFixture(sprite, fixtureAry[i]);
                }
            }

            // 
            //  DESC: Create the circular shape fixture
            //

        }, {
            key: 'getFixtureDef',
            value: function getFixtureDef(sprite, fixture) {
                var fixtureDef = {
                    userData: sprite,
                    friction: fixture.friction,
                    restitution: fixture.restitution,
                    density: fixture.density,
                    isSensor: fixture.sensor,

                    filterGroupIndex: 0,
                    filterCategoryBits: 0x0001,
                    filterMaskBits: 0xFFFF };

                return fixtureDef;
            }

            // 
            //  DESC: Create the circular shape fixture
            //

        }, {
            key: 'createCircularShapeFixture',
            value: function createCircularShapeFixture(sprite, fixture) {
                this.body.createFixture(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Circle"](fixture.radius * sprite.scale.x * this.pixelsToMeters), this.getFixtureDef(sprite, fixture));
            }

            // 
            //  DESC: Create the edge shape fixture
            //  NOTE: An edge is a line segment of two points
            //        This is no different then making a polygon from points
            //

        }, {
            key: 'createEdgeShapeFixture',
            value: function createEdgeShapeFixture(sprite, fixture) {
                // Do a sanity check because we need two points to define an edge
                if (fixture.vertAry.length !== 2) throw new Error('Physics object has incorrect number of points defined (' + fixture.vertAry.length + ')!');

                // Apply scale to the size and divide by 2
                var size = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */](sprite.objData.size.w * sprite.scale.x * 0.5, sprite.objData.size.h * sprite.scale.y * 0.5);

                // Convert the points to world location in meters
                var Vec2Ary = [];
                this.convertPoints(Vec2Ary, fixture, size, sprite.scale);

                this.body.createFixture(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Edge"](Vec2Ary[0], Vec2Ary[1]), this.getFixtureDef(sprite, fixture));
            }

            // 
            //  DESC: Create the polygon shape fixture
            //

        }, {
            key: 'createPolygonShapeFixture',
            value: function createPolygonShapeFixture(sprite, fixture) {
                var Vec2Ary = [];

                // Apply scale to the size and divide by 2
                var size = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */](sprite.objData.size.w * sprite.scale.x * 0.5, sprite.objData.size.h * sprite.scale.y * 0.5);

                // Is this polygon shape defined by a vector of points?
                if (fixture.vertAry.length) {
                    // Convert the points to world location in meters
                    this.convertPoints(Vec2Ary, fixture, size, sprite.scale);
                }

                // If vector points are not supplied, build a square based on the object size
                else {
                        // Bottom and left mod have their signs flipped so that a positive mod always means
                        // expansion of the side, and a negative mod always means a contraction of the side
                        var topMod = fixture.topMod * sprite.scale.y;
                        var bottomMod = -fixture.bottomMod * sprite.scale.y;
                        var leftMod = -fixture.leftMod * sprite.scale.x;
                        var rightMod = fixture.rightMod * sprite.scale.x;

                        // Convert to meters
                        // Box2D polygons are defined using Counter Clockwise Winding (CCW)
                        Vec2Ary.push(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"]((-size.w + leftMod) * this.pixelsToMeters, (size.h + topMod) * this.pixelsToMeters));

                        Vec2Ary.push(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"]((-size.w + leftMod) * this.pixelsToMeters, (-size.h + bottomMod) * this.pixelsToMeters));

                        Vec2Ary.push(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"]((size.w + rightMod) * this.pixelsToMeters, (-size.h + bottomMod) * this.pixelsToMeters));

                        Vec2Ary.push(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"]((size.w + rightMod) * this.pixelsToMeters, (size.h + topMod) * this.pixelsToMeters));
                    }

                this.body.createFixture(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Polygon"](Vec2Ary), this.getFixtureDef(sprite, fixture));
            }

            // 
            //  DESC: Create the chain shape fixture
            //

        }, {
            key: 'createChainShapeFixture',
            value: function createChainShapeFixture(sprite, fixture) {
                // Do a sanity check because we need more then 1 point to define a chain
                if (fixture.vertAry.length > 1) throw new Error('Physics object has incorrect number of points defined (' + fixture.vertAry.length + ')!');

                // Apply scale to the size and divide by 2
                var size = new __WEBPACK_IMPORTED_MODULE_1__common_size__["a" /* Size */](sprite.objData.size.w * sprite.scale.x * 0.5, sprite.objData.size.h * sprite.scale.y * 0.5);

                // Convert the points to world location in meters
                var Vec2Ary = [];
                this.convertPoints(Vec2Ary, fixture, size, sprite.scale);

                this.body.createFixture(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Chain"](Vec2Ary, fixture.chainLoop), this.getFixtureDef(sprite, fixture));
            }

            // 
            //  DESC: Convert the points to world location in meters
            //

        }, {
            key: 'convertPoints',
            value: function convertPoints(polyPointAry, fixture, size, scale) {
                // Convert to meters and world coordinates
                // Box2D polygons are defined using Counter Clockwise Winding (CCW)
                for (var i = 0; i < fixture.vertAry.length; ++i) {
                    polyPointAry.push(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"]((fixture.vertAry[i].x * scale.x - size.w) * this.pixelsToMeters, (fixture.vertAry[i].y * scale.y - size.h) * this.pixelsToMeters));
                }
            }

            // 
            //  DESC: Update the physics
            //

        }, {
            key: 'update',
            value: function update(sprite) {
                if (this.isActive()) {
                    //CStatCounter::Instance().IncPhysicsObjectsCounter();

                    //if( (BODY_TYPE > b2_staticBody) && m_pBody->IsAwake() )
                    if (this.body.isAwake()) {
                        var pos = this.body.getPosition();
                        var angle = this.body.getAngle();
                        sprite.setPosXYZ(pos.x * this.metersToPixels, -(pos.y * this.metersToPixels));
                        sprite.setRotXYZ(0, 0, -angle, false);
                    }
                }
            }

            // 
            //  DESC: Is this component active?
            //

        }, {
            key: 'isActive',
            value: function isActive() {
                return this.body !== null;
            }

            // 
            //  DESC: Update the physics
            //

        }, {
            key: 'destroyBody',
            value: function destroyBody() {
                if (this.body !== null) {
                    this.world.destroyBody(this.body);
                    this.body = null;
                }
            }

            // 
            //  DESC: Set the physics position and rotation
            //

        }, {
            key: 'setTransform',
            value: function setTransform(x, y, angle, resetVelocity) {
                if (this.body !== null) {
                    this.body.setTransform(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"](x * this.pixelsToMeters, -(y * this.pixelsToMeters)), angle);

                    if (resetVelocity) {
                        this.body.setLinearVelocity(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"].zero());
                        this.body.setAngularVelocity(0);
                    }
                }
            }

            // 
            //  DESC: Set the linear velocity
            //

        }, {
            key: 'setLinearVelocity',
            value: function setLinearVelocity(x, y) {
                if (this.body !== null) this.body.setLinearVelocity(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"](x * this.pixelsToMeters, -(y * this.pixelsToMeters)));
            }
        }]);

        return PhysicsComponent2D;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = PhysicsComponent2D;

    /***/
},
/* 77 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__utilities_highresolutiontimer__ = __webpack_require__(8);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_genfunc__ = __webpack_require__(3);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__ = __webpack_require__(32);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__Box2D_planck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__Box2D_planck__);

    // 
    //  FILE NAME: physicsworld2d.js
    //  DESC:      Wrapper class for Box2D's b2World
    //


    var PhysicsWorld2D = function () {
        function PhysicsWorld2D() {
            _classCallCheck(this, PhysicsWorld2D);

            // Box2D world
            this.world = __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["World"]();

            // All bodies that are handled by this physics world
            this.bodyAry = [];

            // If we're actively running simulations
            this.active = false;

            // If we're going to start a step this frame
            this.beginStep = 0;

            // Timer to let us know when to do another step
            this.timer = 0;

            // The ammount of time to simulate in milliseconds
            this.stepTime = 0;

            // The ammount of time to simulate in Seconds
            this.stepTimeSec = 0;

            // The ratio of time between steps
            //this.timeRatio = 0;

            // The number of velocity and position steps to calculate
            this.velStepCount = 0;
            this.posStepCount = 0;

            // pixels per meter scaler
            this.pixelsPerMeter = 0;
        }

        //
        //  DESC: Load the physics world from XML node
        //


        _createClass(PhysicsWorld2D, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                // Get the world's settings, if any are set
                var settingsNode = node.getElementsByTagName("settings");
                if (settingsNode.length) {
                    var attr = settingsNode[0].getAttribute('active');
                    if (attr) this.active = attr === 'true';
                }

                // Get the world's gravity, if any are set
                var gravityNode = node.getElementsByTagName("gravity");
                if (gravityNode.length) {
                    var gravity = __WEBPACK_IMPORTED_MODULE_2__Box2D_planck__["Vec2"](Number(gravityNode[0].getAttribute("x")), Number(gravityNode[0].getAttribute("y")));

                    this.world.setGravity(gravity);
                }

                // Get the stepping which determins how accurate the physics are
                var steppingNode = node.getElementsByTagName("stepping");
                if (steppingNode.length) {
                    this.velStepCount = Number(steppingNode[0].getAttribute("velocity"));
                    this.posStepCount = Number(steppingNode[0].getAttribute("position"));

                    var fps = Number(steppingNode[0].getAttribute("fps"));

                    // If the number is negative, get the current refresh rate
                    /*if( fps < 0.0 )
                    {
                        SDL_DisplayMode dm;
                        SDL_GetDesktopDisplayMode(0, &dm);
                         if( dm.refresh_rate == 0 )
                            fps = 60.f;
                        else
                            fps = dm.refresh_rate;
                    }*/

                    this.setFPS(fps);
                }

                // Get the conversion of pixels per meter because Box2D works in meters
                var conversionNode = node.getElementsByTagName("conversion");
                if (conversionNode.length) this.pixelsPerMeter = Number(conversionNode[0].getAttribute("pixelsPerMeter"));
            }

            //
            //  DESC: Create a physics body
            //  NOTE: Function should only be called from physics component
            //

        }, {
            key: 'createBody',
            value: function createBody(def) {
                var body = this.world.createBody(def);

                if (body === null) throw new Error('Error creating physics body!');

                this.bodyAry.push(body);

                return body;
            }

            //
            //  DESC: Destroy a physics body
            //  NOTE: Function should only be called from physics component
            //

        }, {
            key: 'destroyBody',
            value: function destroyBody(body) {
                var index = this.bodySet.indexOf(body);

                if (index !== -1) {
                    // Destroy the body
                    this.world.destroyBody(body);

                    // Remove the body from the array
                    this.bodyAry.splice(index, 1);
                }
            }

            //
            //  DESC: Perform fixed time step physics simulation
            //

        }, {
            key: 'fixedTimeStep',
            value: function fixedTimeStep() {
                if (this.active) {
                    // Increment the timer
                    this.timer += __WEBPACK_IMPORTED_MODULE_0__utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;

                    if (this.timer > this.stepTime) {
                        this.timer = __WEBPACK_IMPORTED_MODULE_1__utilities_genfunc__["c" /* modulus */](this.timer, this.stepTime);

                        // Begin the physics world step
                        this.world.step(this.stepTimeSec, this.velStepCount, this.posStepCount);
                    }

                    //this.timeRatio = this.timer / this.stepTime;
                }
            }

            //
            //  DESC: Perform variable time step physics simulation
            //

        }, {
            key: 'variableTimeStep',
            value: function variableTimeStep() {
                if (this.active) {
                    // Begin the physics world step
                    this.world.step(__WEBPACK_IMPORTED_MODULE_0__utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime / 1000.0, this.velStepCount, this.posStepCount);
                }
            }

            //
            //  DESC: Set the fps to run the simulation at
            //

        }, {
            key: 'setFPS',
            value: function setFPS(fps) {
                // Make sure we don't have a negative or zero fps
                if (fps > 1.0) {
                    // Calculate the step paramaters
                    this.stepTimeSec = 1.0 / fps;
                    this.stepTime = this.stepTimeSec * 1000.0;

                    // Set the timer so that we'll begin a step next time we call Update
                    this.timer = this.stepTime;
                }
            }
        }]);

        return PhysicsWorld2D;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = PhysicsWorld2D;

    /***/
},
/* 78 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME: physicsworld3d.js
    //  DESC:      Wrapper class for Bullet physics
    //

    var PhysicsWorld3D = function PhysicsWorld3D() {
        _classCallCheck(this, PhysicsWorld3D);
    };
    /* harmony export (immutable) */

    __webpack_exports__["a"] = PhysicsWorld3D;

    /***/
},
/* 79 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__2d_object2d__ = __webpack_require__(25);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_settings__ = __webpack_require__(9);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_dynamicoffset__ = __webpack_require__(30);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__utilities_assetholder__ = __webpack_require__(12);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__utilities_xmlparsehelper__ = __webpack_require__(4);

    // 
    //  FILE NAME: controlbase.js
    //  DESC:      Control base class
    //


    var ControlBase = function (_WEBPACK_IMPORTED_MO18) {
        _inherits(ControlBase, _WEBPACK_IMPORTED_MO18);

        function ControlBase(group) {
            _classCallCheck(this, ControlBase);

            // Object data group name
            var _this32 = _possibleConstructorReturn(this, (ControlBase.__proto__ || Object.getPrototypeOf(ControlBase)).call(this));

            _this32.group = group;

            // Unique string id
            _this32.name = null;

            // The type of control
            _this32.type = null;

            // Control string list
            _this32.stringAry = [];

            // A name that is applied to similar controls.
            // Provides a way to check for many controls without having to use unique names
            _this32.faction = null;

            // Dynamic offset
            _this32.dynamicOffset = null;
            return _this32;
        }

        // 
        //  DESC: Load the control info from XML node
        //


        _createClass(ControlBase, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                // Set the controls name
                var attr = node.getAttribute('name');
                if (attr) this.name = attr;

                // Set the faction name
                attr = node.getAttribute('faction');
                if (attr) this.faction = attr;

                // Load the transform data
                this.loadTransFromNode(node);

                // Load the dynamic offset from node
                this.loadDynamicOffsetFromNode(node);

                // See if we have a list of strings
                var stringLstNode = node.getElementsByTagName('fontStringLst');
                if (stringLstNode.length) {
                    var stringNode = stringLstNode[0].getElementsByTagName('string');

                    for (var i = 0; i < stringNode.length; ++i) {
                        this.stringAry.push(stringNode[i].getAttribute('text'));
                    }
                }

                // Load the control specific xml file
                // Get the file path node to the control specific xml code
                var filePathNode = node.getElementsByTagName('filePath');
                if (filePathNode.length) {
                    // Get the control's file path
                    var controlFilePath = filePathNode[0].getAttribute('file');

                    // Load xml specific control code
                    // Use the preloaded since many controls reuse xml files
                    this.loadControlFromNode(__WEBPACK_IMPORTED_MODULE_3__utilities_assetholder__["a" /* assetHolder */].get(this.group, controlFilePath));
                }
            }

            // 
            //  DESC: Load the control specific info from XML node
            //

        }, {
            key: 'loadControlFromNode',
            value: function loadControlFromNode(node) {}
            // Empty function to be overwritten


            // 
            //  DESC: Load the dynamic offset data from node
            //

        }, {
            key: 'loadDynamicOffsetFromNode',
            value: function loadDynamicOffsetFromNode(node) {
                // Load the dynamic offset
                this.dynamicOffset = __WEBPACK_IMPORTED_MODULE_4__utilities_xmlparsehelper__["c" /* loadDynamicOffset */](node);

                // Set the dynamic position
                this.setDynamicPos();
            }

            // 
            //  DESC: Set the dynamic position
            //

        }, {
            key: 'setDynamicPos',
            value: function setDynamicPos() {
                // Position the menu based on the dynamic offset
                if (this.dynamicOffset) this.setPos(this.dynamicOffset.getPos(__WEBPACK_IMPORTED_MODULE_1__utilities_settings__["a" /* settings */].defaultSize_half));
            }
        }]);

        return ControlBase;
    }(__WEBPACK_IMPORTED_MODULE_0__2d_object2d__["a" /* Object2D */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = ControlBase;

    /***/
},
/* 80 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_point__ = __webpack_require__(5);

    // 
    //  FILE NAME:  quad.js
    //  DESC:       quad class
    //


    var Quad = function () {
        function Quad() {
            _classCallCheck(this, Quad);

            this.point = [new __WEBPACK_IMPORTED_MODULE_0__common_point__["a" /* Point */](), new __WEBPACK_IMPORTED_MODULE_0__common_point__["a" /* Point */](), new __WEBPACK_IMPORTED_MODULE_0__common_point__["a" /* Point */](), new __WEBPACK_IMPORTED_MODULE_0__common_point__["a" /* Point */]()];
        }

        // 
        //  DESC: Is the point in the Quad
        //  Note: Fast but does not work when quad is rotated
        //


        _createClass(Quad, [{
            key: 'isPointInQuad',
            value: function isPointInQuad(x, y) {
                var result = false;

                //console.log( `isPointInQuad - X: ${x}, Y: ${y}` );

                for (var i = 0, j = 3; i < 4; j = i++) {
                    if (this.point[i].y > y != this.point[j].y > y && x < (this.point[j].x - this.point[i].x) * (y - this.point[i].y) / (this.point[j].y - this.point[i].y) + this.point[i].x) {
                        result = !result;
                    }
                }

                return result;
            }
        }]);

        return Quad;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Quad;

    /***/
},
/* 81 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__uicontrol__ = __webpack_require__(17);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uilabel.js
    //  DESC:      Class for user interface labels
    //


    var UILabel = function (_WEBPACK_IMPORTED_MO19) {
        _inherits(UILabel, _WEBPACK_IMPORTED_MO19);

        function UILabel(group) {
            _classCallCheck(this, UILabel);

            var _this33 = _possibleConstructorReturn(this, (UILabel.__proto__ || Object.getPrototypeOf(UILabel)).call(this, group));

            _this33.type = __WEBPACK_IMPORTED_MODULE_1__common_defs__["J" /* ECT_LABEL */];
            return _this33;
        }

        return UILabel;
    }(__WEBPACK_IMPORTED_MODULE_0__uicontrol__["a" /* UIControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UILabel;

    /***/
},
/* 82 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__uicontrol__ = __webpack_require__(17);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uibutton.js
    //  DESC:      Class for user interface buttons
    //


    var UIButton = function (_WEBPACK_IMPORTED_MO20) {
        _inherits(UIButton, _WEBPACK_IMPORTED_MO20);

        function UIButton(group) {
            _classCallCheck(this, UIButton);

            var _this34 = _possibleConstructorReturn(this, (UIButton.__proto__ || Object.getPrototypeOf(UIButton)).call(this, group));

            _this34.type = __WEBPACK_IMPORTED_MODULE_1__common_defs__["G" /* ECT_BUTTON */];
            return _this34;
        }

        return UIButton;
    }(__WEBPACK_IMPORTED_MODULE_0__uicontrol__["a" /* UIControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UIButton;

    /***/
},
/* 83 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__uisubcontrol__ = __webpack_require__(27);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_bitmask__ = __webpack_require__(31);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uibuttonlist.js
    //  DESC:      Class for user interface buttons
    //


    var UIButtonList = function (_WEBPACK_IMPORTED_MO21) {
        _inherits(UIButtonList, _WEBPACK_IMPORTED_MO21);

        function UIButtonList(group) {
            _classCallCheck(this, UIButtonList);

            var _this35 = _possibleConstructorReturn(this, (UIButtonList.__proto__ || Object.getPrototypeOf(UIButtonList)).call(this, group));

            _this35.type = __WEBPACK_IMPORTED_MODULE_3__common_defs__["H" /* ECT_BUTTON_LIST */];

            // Active index into the list
            _this35.activeIndex = 0;

            // Index of the image list
            _this35.imageLstIndex = -1;

            // Indicates if the control responds to up, down, left or right
            _this35.actionMask = new __WEBPACK_IMPORTED_MODULE_1__utilities_bitmask__["a" /* BitMask */]();
            return _this35;
        }

        // 
        //  DESC: Load the control info from XML node
        //


        _createClass(UIButtonList, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                // Call the parent
                _get(UIButtonList.prototype.__proto__ || Object.getPrototypeOf(UIButtonList.prototype), 'loadFromNode', this).call(this, node);

                // See what the control will respond to
                var actionResponseNode = node.getElementsByTagName('actionResponse');
                var attr = actionResponseNode[0].getAttribute('up');
                if (attr && attr === 'true') {
                    this.actionMask.add(__WEBPACK_IMPORTED_MODULE_3__common_defs__["q" /* EAR_UP */]);
                }

                attr = actionResponseNode[0].getAttribute('down');
                if (attr && attr === 'true') {
                    this.actionMask.add(__WEBPACK_IMPORTED_MODULE_3__common_defs__["n" /* EAR_DOWN */]);
                }

                attr = actionResponseNode[0].getAttribute('left');
                if (attr && attr === 'true') {
                    this.actionMask.add(__WEBPACK_IMPORTED_MODULE_3__common_defs__["o" /* EAR_LEFT */]);
                }

                attr = actionResponseNode[0].getAttribute('right');
                if (attr && attr === 'true') {
                    this.actionMask.add(__WEBPACK_IMPORTED_MODULE_3__common_defs__["p" /* EAR_RIGHT */]);
                }
            }

            // 
            //  DESC: Load the control specific info from XML node
            //

        }, {
            key: 'loadControlFromNode',
            value: function loadControlFromNode(node) {
                // Call the parent
                _get(UIButtonList.prototype.__proto__ || Object.getPrototypeOf(UIButtonList.prototype), 'loadControlFromNode', this).call(this, node);

                // See if there is an image list
                for (var i = 0; i < this.spriteAry.length; ++i) {
                    if (this.spriteAry[i].objData.visualData.getFrameCount() > 1) {
                        this.imageLstIndex = i;
                        break;
                    }
                }
            }

            // 
            //  DESC: Inc/Dec control
            //

        }, {
            key: 'inc',
            value: function inc() {
                __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_3__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_3__common_defs__["F" /* ECS_SELECTED */], this.subControlAry[__WEBPACK_IMPORTED_MODULE_3__common_defs__["b" /* BTN_INC */]]);
            }
        }, {
            key: 'dec',
            value: function dec() {
                __WEBPACK_IMPORTED_MODULE_2__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_3__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_3__common_defs__["F" /* ECS_SELECTED */], this.subControlAry[__WEBPACK_IMPORTED_MODULE_3__common_defs__["a" /* BTN_DEC */]]);
            }

            // 
            //  DESC: Handle Onmessage
            //

        }, {
            key: 'onDownAction',
            value: function onDownAction(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_3__common_defs__["k" /* EAP_DOWN */] && this.actionMask.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["n" /* EAR_DOWN */])) this.dec();
            }
        }, {
            key: 'onUpAction',
            value: function onUpAction(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_3__common_defs__["k" /* EAP_DOWN */] && this.actionMask.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["q" /* EAR_UP */])) this.inc();
            }
        }, {
            key: 'onLeftAction',
            value: function onLeftAction(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_3__common_defs__["k" /* EAP_DOWN */] && this.actionMask.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["o" /* EAR_LEFT */])) this.dec();
            }
        }, {
            key: 'onRightAction',
            value: function onRightAction(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_3__common_defs__["k" /* EAP_DOWN */] && this.actionMask.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["p" /* EAR_RIGHT */])) this.inc();
            }

            // 
            //  DESC: Handle OnLeftScroll message
            //

        }, {
            key: 'onDownScroll',
            value: function onDownScroll(event) {
                if (this.actionMask.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["n" /* EAR_DOWN */])) this.dec();
            }
        }, {
            key: 'onUpScroll',
            value: function onUpScroll(event) {
                if (this.actionMask.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["q" /* EAR_UP */])) this.inc();
            }
        }, {
            key: 'onLeftScroll',
            value: function onLeftScroll(event) {
                if (this.actionMask.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["o" /* EAR_LEFT */])) this.dec();
            }
        }, {
            key: 'onRightScroll',
            value: function onRightScroll(event) {
                if (this.actionMask.isSet(__WEBPACK_IMPORTED_MODULE_3__common_defs__["p" /* EAR_RIGHT */])) this.inc();
            }

            // 
            //  DESC: Handle OnStateChange message
            //

        }, {
            key: 'onStateChange',
            value: function onStateChange(event) {
                _get(UIButtonList.prototype.__proto__ || Object.getPrototypeOf(UIButtonList.prototype), 'onStateChange', this).call(this, event);

                var state = event.detail.arg[0];

                if (state === __WEBPACK_IMPORTED_MODULE_3__common_defs__["F" /* ECS_SELECTED */]) {
                    if (this.subControlAry[__WEBPACK_IMPORTED_MODULE_3__common_defs__["a" /* BTN_DEC */]] == event.detail.arg[1]) {
                        // Dec the list
                        this.decList();

                        // Update the display
                        this.updateDisplay(this.activeIndex);

                        // Execute smart gui
                        this.smartExecuteAction();
                    } else if (this.subControlAry[__WEBPACK_IMPORTED_MODULE_3__common_defs__["b" /* BTN_INC */]] == event.detail.arg[1]) {
                        // Inc the list
                        this.incList();

                        // Update the display
                        this.updateDisplay(this.activeIndex);

                        // Execute smart gui
                        this.smartExecuteAction();
                    }
                }
            }

            // 
            //  DESC: Inc the list
            //

        }, {
            key: 'incList',
            value: function incList() {
                if (this.stringAry.length) this.activeIndex = (this.activeIndex + 1) % this.stringAry.length;
            }
        }, {
            key: 'decList',
            value: function decList() {
                if (this.stringAry.length) {
                    if (this.activeIndex > 0) this.activeIndex = (this.activeIndex - 1) % this.stringAry.length;else this.activeIndex = this.stringAry.length - 1;
                }
            }

            // 
            //  DESC: Update the display
            //

        }, {
            key: 'updateDisplay',
            value: function updateDisplay(index) {
                this.activeIndex = index;

                this.createFontString(this.activeIndex);

                if (this.imageLstIndex > -1) this.spriteAry[this.imageLstIndex].visualComponent.setFrame(this.activeIndex);
            }
        }]);

        return UIButtonList;
    }(__WEBPACK_IMPORTED_MODULE_0__uisubcontrol__["a" /* UISubControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UIButtonList;

    /***/
},
/* 84 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__uicontrol__ = __webpack_require__(17);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uicheckbox.js
    //  DESC:      Class for user interface check box buttons
    //


    var UICheckBox = function (_WEBPACK_IMPORTED_MO22) {
        _inherits(UICheckBox, _WEBPACK_IMPORTED_MO22);

        function UICheckBox(group) {
            _classCallCheck(this, UICheckBox);

            var _this36 = _possibleConstructorReturn(this, (UICheckBox.__proto__ || Object.getPrototypeOf(UICheckBox)).call(this, group));

            _this36.type = __WEBPACK_IMPORTED_MODULE_1__common_defs__["I" /* ECT_CHECK_BOX */];

            // Select state
            _this36.toggleState = false;
            return _this36;
        }

        // 
        //  DESC: Handle OnSelectExecute message
        //


        _createClass(UICheckBox, [{
            key: 'onSelectExecute',
            value: function onSelectExecute(event) {
                if (this.state === __WEBPACK_IMPORTED_MODULE_1__common_defs__["F" /* ECS_SELECTED */]) this.toggleState = !this.toggleState;

                _get(UICheckBox.prototype.__proto__ || Object.getPrototypeOf(UICheckBox.prototype), 'onSelectExecute', this).call(this, event);
            }

            // 
            //  DESC: Render the control
            //

        }, {
            key: 'render',
            value: function render(matrix) {
                for (var i = 0; i < this.spriteAry.length - 1; ++i) {
                    this.spriteAry[i].render(matrix);
                }if (this.toggleState === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_62" /* TOGGLE_STATE_ON */]) this.spriteAry[this.spriteAry.length - 1].render(matrix);
            }
        }]);

        return UICheckBox;
    }(__WEBPACK_IMPORTED_MODULE_0__uicontrol__["a" /* UIControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UICheckBox;

    /***/
},
/* 85 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__uisubcontrol__ = __webpack_require__(27);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__utilities_settings__ = __webpack_require__(9);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uislider.js
    //  DESC:      Class for user interface slider
    //


    var UISlider = function (_WEBPACK_IMPORTED_MO23) {
        _inherits(UISlider, _WEBPACK_IMPORTED_MO23);

        function UISlider(group) {
            _classCallCheck(this, UISlider);

            var _this37 = _possibleConstructorReturn(this, (UISlider.__proto__ || Object.getPrototypeOf(UISlider)).call(this, group));

            _this37.type = __WEBPACK_IMPORTED_MODULE_4__common_defs__["N" /* ECT_SLIDER */];

            // Slider travel distance in pixels
            _this37.travelDistPixels = 0;

            // Slider Orientation
            _this37.orientation = __WEBPACK_IMPORTED_MODULE_4__common_defs__["_42" /* EO_HORIZONTAL */];

            // Min value
            _this37.minValue = 0;

            // Max value
            _this37.maxValue = 0;

            // Current value
            _this37.curValue = 0;

            // inc value
            _this37.incValue = 0;

            // Flag to indicate to display the value as an int
            _this37.displayValueAsInt = false;

            // Default position of the slider button
            _this37.defaultPos = new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */]();

            // slider button hold flag
            _this37.sliderBtnHold = false;

            // The current press type
            _this37.pressType = __WEBPACK_IMPORTED_MODULE_4__common_defs__["l" /* EAP_IDLE */];
            return _this37;
        }

        // 
        //  DESC: Load the control info from XML node
        //


        _createClass(UISlider, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                _get(UISlider.prototype.__proto__ || Object.getPrototypeOf(UISlider.prototype), 'loadFromNode', this).call(this, node);

                // Get the slider specific settings
                var settingsNode = node.getElementsByTagName('settings');
                if (settingsNode.length) {
                    var attr = settingsNode[0].getAttribute('orientation');
                    if (attr && attr === 'VERT') this.orientation = __WEBPACK_IMPORTED_MODULE_4__common_defs__["_43" /* EO_VERTICAL */];

                    attr = settingsNode[0].getAttribute('minValue');
                    if (attr) this.minValue = Number(attr);

                    attr = settingsNode[0].getAttribute('maxValue');
                    if (attr) this.maxValue = Number(attr);

                    attr = settingsNode[0].getAttribute('incValue');
                    if (attr) this.incValue = Number(attr);

                    attr = settingsNode[0].getAttribute('defValue');
                    if (attr) this.curValue = Number(attr);

                    attr = settingsNode[0].getAttribute('displayValueAsInt');
                    if (attr && attr === 'true') this.displayValueAsInt = true;
                }
            }

            // 
            //  DESC: Load the control specific info from XML node
            //

        }, {
            key: 'loadControlFromNode',
            value: function loadControlFromNode(node) {
                // Have the parent load it's stuff
                _get(UISlider.prototype.__proto__ || Object.getPrototypeOf(UISlider.prototype), 'loadControlFromNode', this).call(this, node);

                // Get the position of the slider button as the default position
                this.defaultPos.copy(this.subControlAry[0].position);

                // Get the slider specific settings
                var settingsNode = node.getElementsByTagName('settings');
                if (settingsNode.length) {
                    var attr = settingsNode[0].getAttribute('maxTravelDistPixels');
                    if (attr) this.travelDistPixels = Number(attr);
                }
            }

            // 
            //  DESC: Init the control
            //

        }, {
            key: 'init',
            value: function init() {
                _get(UISlider.prototype.__proto__ || Object.getPrototypeOf(UISlider.prototype), 'init', this).call(this);

                this.updateSlider();
            }

            // 
            //  DESC: Handle OnLeftAction message
            //

        }, {
            key: 'onLeftAction',
            value: function onLeftAction(event) {
                // Handle the slider change
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_4__common_defs__["k" /* EAP_DOWN */]) this.handleSliderChange(-this.incValue, true);
            }

            // 
            //  DESC: Handle OnRightAction message
            //

        }, {
            key: 'onRightAction',
            value: function onRightAction(event) {
                // Handle the slider change
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_4__common_defs__["k" /* EAP_DOWN */]) this.handleSliderChange(this.incValue, true);
            }

            // 
            //  DESC: Handle OnRightScroll message
            //

        }, {
            key: 'onLeftScroll',
            value: function onLeftScroll(event) {
                this.handleSliderChange(-this.incValue);
            }

            // 
            //  DESC: Handle OnRightScroll message
            //

        }, {
            key: 'onRightScroll',
            value: function onRightScroll(event) {
                this.handleSliderChange(this.incValue);
            }

            // 
            //  DESC: Handle OnMouseMove message
            //

        }, {
            key: 'onMouseMove',
            value: function onMouseMove(event) {
                var result = _get(UISlider.prototype.__proto__ || Object.getPrototypeOf(UISlider.prototype), 'onMouseMove', this).call(this, event);

                if (this.isActive() && this.pressType === __WEBPACK_IMPORTED_MODULE_4__common_defs__["k" /* EAP_DOWN */]) {
                    var oneOverAspectRatio = 1.0 / __WEBPACK_IMPORTED_MODULE_2__utilities_settings__["a" /* settings */].orthoAspectRatio.h;

                    if (this.orientation === __WEBPACK_IMPORTED_MODULE_4__common_defs__["_42" /* EO_HORIZONTAL */]) this.incSliderMovePos(event.movementX * oneOverAspectRatio);else this.incSliderMovePos(event.movementY * oneOverAspectRatio);

                    this.smartExecuteAction();
                }

                return result;
            }

            // 
            //  DESC: Handle the select action
            //

        }, {
            key: 'handleSelectAction',
            value: function handleSelectAction(event) {
                var result = this.isActive() && event.detail.arg[__WEBPACK_IMPORTED_MODULE_4__common_defs__["_46" /* ESMA_DEVICE_TYPE */]] === __WEBPACK_IMPORTED_MODULE_4__common_defs__["_57" /* MOUSE */] && this.isPointInControl(event.detail.arg[__WEBPACK_IMPORTED_MODULE_4__common_defs__["_47" /* ESMA_MOUSE_X */]], event.detail.arg[__WEBPACK_IMPORTED_MODULE_4__common_defs__["_48" /* ESMA_MOUSE_Y */]]);

                if (result && event.detail.arg[__WEBPACK_IMPORTED_MODULE_4__common_defs__["_49" /* ESMA_PRESS_TYPE */]] === this.mouseSelectType) {
                    // Get the press type to know if we need to move the slider 
                    // along with the mouse move
                    this.pressType = this.mouseSelectType;

                    if (event.detail.arg[__WEBPACK_IMPORTED_MODULE_4__common_defs__["_49" /* ESMA_PRESS_TYPE */]] === __WEBPACK_IMPORTED_MODULE_4__common_defs__["k" /* EAP_DOWN */]) {
                        this.prepareControlScriptFactory(__WEBPACK_IMPORTED_MODULE_4__common_defs__["F" /* ECS_SELECTED */]);

                        var ratio = 1.0 / __WEBPACK_IMPORTED_MODULE_2__utilities_settings__["a" /* settings */].orthoAspectRatio.h;

                        if (this.orientation === __WEBPACK_IMPORTED_MODULE_4__common_defs__["_42" /* EO_HORIZONTAL */]) this.incSliderMovePos((event.detail.arg[__WEBPACK_IMPORTED_MODULE_4__common_defs__["_47" /* ESMA_MOUSE_X */]] - this.subControlAry[0].collisionCenter.x) * ratio);else this.incSliderMovePos((event.detail.arg[__WEBPACK_IMPORTED_MODULE_4__common_defs__["_48" /* ESMA_MOUSE_Y */]] - this.subControlAry[0].collisionCenter.y) * ratio);

                        this.smartExecuteAction();
                    }
                } else if (event.detail.arg[__WEBPACK_IMPORTED_MODULE_4__common_defs__["_49" /* ESMA_PRESS_TYPE */]] !== this.mouseSelectType) {
                    this.pressType = __WEBPACK_IMPORTED_MODULE_4__common_defs__["l" /* EAP_IDLE */];
                }

                return result;
            }

            // 
            //  DESC: Deactivate the control
            //

        }, {
            key: 'deactivateControl',
            value: function deactivateControl() {
                _get(UISlider.prototype.__proto__ || Object.getPrototypeOf(UISlider.prototype), 'deactivateControl', this).call(this);

                this.pressType = __WEBPACK_IMPORTED_MODULE_4__common_defs__["l" /* EAP_IDLE */];
            }

            // 
            //  DESC: Handle the slider change
            //

        }, {
            key: 'handleSliderChange',
            value: function handleSliderChange(value) {
                var prepareOnSelect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                if (this.isActive()) {
                    if (prepareOnSelect) this.prepareControlScriptFactory(__WEBPACK_IMPORTED_MODULE_4__common_defs__["F" /* ECS_SELECTED */]);

                    // Send a message to blink the button
                    __WEBPACK_IMPORTED_MODULE_3__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_4__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_4__common_defs__["F" /* ECS_SELECTED */], this.subControlAry[0]);

                    this.incSlider(value);

                    this.smartExecuteAction();
                }
            }

            // 
            //  DESC: Set the slider inc value
            //

        }, {
            key: 'setSlider',
            value: function setSlider() {
                var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

                this.curValue = value;

                // Update the slider
                this.updateSlider();
            }

            // 
            //  DESC: Set the slider inc value
            //

        }, {
            key: 'incSlider',
            value: function incSlider() {
                var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

                this.curValue += value;

                // Update the slider
                this.updateSlider();
            }

            // 
            //  DESC: Inc the slider based on mouse movement
            //

        }, {
            key: 'incSliderMovePos',
            value: function incSliderMovePos(value) {
                this.curValue += value * ((this.maxValue - this.minValue) / this.travelDistPixels);

                // Update the slider
                this.updateSlider();
            }

            // 
            //  DESC: Update the slider
            //

        }, {
            key: 'updateSlider',
            value: function updateSlider() {
                // Cap current value to it's range
                this.capSliderValue();

                // Set the position of the slider
                this.setSliderPos();

                // Set the slider label if there is one
                if (this.stringAry.length) {
                    // Format for display
                    var valueStr = void 0;

                    if (this.displayValueAsInt) valueStr = this.stringAry[this.stringAry.length - 1].replace(/%d/i, Math.trunc(this.curValue));else valueStr = this.stringAry[this.stringAry.length - 1].replace(/%d/i, this.curValue);

                    this.createFontStr(valueStr);
                }
            }

            // 
            //  DESC: Cap the slider value
            //

        }, {
            key: 'capSliderValue',
            value: function capSliderValue() {
                // Cap current value to range
                if (this.curValue < this.minValue) this.curValue = this.minValue;else if (this.curValue > this.maxValue) this.curValue = this.maxValue;
            }

            // 
            //  DESC: Set the position of the slider
            //

        }, {
            key: 'setSliderPos',
            value: function setSliderPos() {
                if (Math.abs(this.maxValue) > 0.001) {
                    var startPos = -(this.travelDistPixels / 2);
                    var pixelsPerValue = this.travelDistPixels / (this.maxValue - this.minValue);
                    var pos = startPos + pixelsPerValue * (this.curValue - this.minValue);

                    if (this.orientation === __WEBPACK_IMPORTED_MODULE_4__common_defs__["_42" /* EO_HORIZONTAL */]) this.subControlAry[0].setPosXYZ(this.defaultPos.x + pos, this.defaultPos.y);else this.subControlAry[0].setPosXYZ(this.defaultPos.x, this.defaultPos.y + -pos);
                }
            }

            // 
            //  DESC: Is the mouse down
            //

        }, {
            key: 'isMouseDown',
            value: function isMouseDown() {
                return this.pressType === __WEBPACK_IMPORTED_MODULE_4__common_defs__["k" /* EAP_DOWN */];
            }
        }]);

        return UISlider;
    }(__WEBPACK_IMPORTED_MODULE_0__uisubcontrol__["a" /* UISubControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UISlider;

    /***/
},
/* 86 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__uisubcontrol__ = __webpack_require__(27);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_point__ = __webpack_require__(5);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__2d_sprite2d__ = __webpack_require__(13);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__objectdatamanager_objectdatamanager__ = __webpack_require__(11);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__utilities_highresolutiontimer__ = __webpack_require__(8);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__utilities_xmlparsehelper__ = __webpack_require__(4);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__uicontrolfactory__ = __webpack_require__(34);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: uiscrollbox.js
    //  DESC:      Class for user interface scroll boxes
    //


    var IN_VIEWABLE_AREA = 1;
    var NEW_ACTIVE_CTRL = 2;

    var UIScrollBox = function (_WEBPACK_IMPORTED_MO24) {
        _inherits(UIScrollBox, _WEBPACK_IMPORTED_MO24);

        function UIScrollBox(group) {
            _classCallCheck(this, UIScrollBox);

            var _this38 = _possibleConstructorReturn(this, (UIScrollBox.__proto__ || Object.getPrototypeOf(UIScrollBox)).call(this, group));

            _this38.type = __WEBPACK_IMPORTED_MODULE_9__common_defs__["M" /* ECT_SCROLL_BOX */];

            // Array list of controls in scroll box
            _this38.scrollControlAry = [];

            // Initial scroll box control offset
            _this38.initialOffset = new __WEBPACK_IMPORTED_MODULE_1__common_point__["a" /* Point */]();

            // Height to cull
            _this38.cullHeight = 0;

            // height of control
            _this38.controlHeight = 0;

            // Scroll move counter
            _this38.scrollCurPos = 0;

            // Number of controls visible in scroll box
            _this38.visibleCount = 0;

            // Visible start pos
            _this38.visStartPos = 0;
            _this38.visEndPos = 0;

            // Max scroll amount
            _this38.maxMoveAmount = 0;

            // stencil mask sprite
            _this38.stencilMaskSprite;

            // Active scroll control index in this control
            _this38.activeScrollCtrl = __WEBPACK_IMPORTED_MODULE_9__common_defs__["_58" /* NO_ACTIVE_CONTROL */];

            // index of first control in scroll box
            _this38.firstScrollCtrlIndex = 0;

            // Default offsets
            _this38.defaultOffsetAry = [];

            // speed members
            _this38.scrollSpeed = 0.05;
            _this38.pageSpeed = 0.05;

            // Scroll vector to indicate the control is scrolling
            _this38.scrollVector = 0;

            // Flag to indicate the control is paging
            _this38.paging = 0;

            // Scroll counter
            _this38.scrollCounter = 0;

            // Scroll distance
            _this38.scrollDistance = 0;

            // Flag to indicate scrolling needs to stop
            // but allows the scrolling to finish
            _this38.endScroll = false;

            // Flag to indicate that the scroll message has been sent
            _this38.scrollMsg = false;

            // Flag to allow for end scroll selection
            _this38.endScrollSelection = false;
            return _this38;
        }

        // 
        //  DESC: Load the control info from XML node
        //


        _createClass(UIScrollBox, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'loadFromNode', this).call(this, node);

                // Init the slider
                this.subControlAry[0].maxValue = this.maxMoveAmount;
                this.subControlAry[0].setSlider();

                // Get the scrolling info
                var scrollNode = node.getElementsByTagName('scroll');
                if (scrollNode.length) {
                    var attr = scrollNode[0].getAttribute('scrollSpeed');
                    if (attr) this.scrollSpeed = Number(attr);

                    attr = scrollNode[0].getAttribute('pageSpeed');
                    if (attr) this.pageSpeed = Number(attr);
                }

                // Calc the start and end positions of what should
                // be viewable in the scroll box
                this.setStartEndPos();
            }

            // 
            //  DESC: Load the control specific info from XML node
            //

        }, {
            key: 'loadControlFromNode',
            value: function loadControlFromNode(node) {
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'loadControlFromNode', this).call(this, node);

                // Get the menu controls node
                var menuControlsNode = node.getElementsByTagName("scrollBoxControlList");
                if (menuControlsNode.length) {
                    // Get the initial offset of the first control in the scroll box
                    this.initialOffset = __WEBPACK_IMPORTED_MODULE_7__utilities_xmlparsehelper__["e" /* loadPosition */](menuControlsNode[0]);

                    // Get the scroll boc info node
                    var controlInfoNode = menuControlsNode[0].getElementsByTagName("controlInfo");
                    this.controlHeight = Number(controlInfoNode[0].getAttribute("height"));
                    this.visibleCount = Number(controlInfoNode[0].getAttribute("visibleInScrollBox"));

                    // Get the number of controls in this scroll box
                    var scrollControlNode = menuControlsNode[0].getElementsByTagName("control");

                    // Add the scroll control from node
                    for (var i = 0; i < scrollControlNode.length; ++i) {
                        this.addScrollControlFromNode(scrollControlNode[i]);
                    }
                }

                // Get the stencil mask node
                var stencilMaskNode = node.getElementsByTagName("stencilMask");
                if (stencilMaskNode.length) {
                    var objectName = stencilMaskNode[0].getAttribute("objectName");

                    this.stencilMaskSprite = new __WEBPACK_IMPORTED_MODULE_2__2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_3__objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData(this.group, objectName));

                    // Get the cull height
                    this.cullHeight = (this.stencilMaskSprite.objData.size.w + this.controlHeight) / 2;

                    // Load the transform data
                    this.stencilMaskSprite.loadTransFromNode(stencilMaskNode[0]);
                }
            }

            // 
            //  DESC: Add the scroll control from node
            //  NOTE: This function recalculates the scroll box members because
            //        it is also used for run-time dynamic scroll boxes
            //

        }, {
            key: 'addScrollControlFromNode',
            value: function addScrollControlFromNode(node) {
                // The reference is placed within a array for all controls
                var ctrl = __WEBPACK_IMPORTED_MODULE_8__uicontrolfactory__["a" /* create */](node, this.group);
                this.scrollControlAry.push(ctrl);

                // Get the position for this control
                var posY = this.initialOffset.y - this.controlHeight * (this.scrollControlAry.length - 1);

                // Record the default y offset
                this.defaultOffsetAry.push(posY);

                // Set the position
                ctrl.setPosXYZ(this.initialOffset.x, posY, this.initialOffset.z);

                // Init the control visual state
                ctrl.deactivateControl();

                // Calculate the maximum scroll amount in pixels
                if (this.scrollControlAry.length > this.visibleCount) this.maxMoveAmount = (this.scrollControlAry.length - this.visibleCount) * this.controlHeight;

                return ctrl;
            }

            // 
            //  DESC: Init the control
            //

        }, {
            key: 'init',
            value: function init() {
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'init', this).call(this);

                // Init all controls
                for (var i = 0; i < this.scrollControlAry.length; ++i) {
                    this.scrollControlAry[i].init();
                }
            }

            // 
            //  DESC: Do some cleanup
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'cleanUp', this).call(this);

                // Init all controls
                for (var i = 0; i < this.scrollControlAry.length; ++i) {
                    this.scrollControlAry[i].cleanUp();
                }
            }

            // 
            //  DESC: Handle events
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'handleEvent', this).call(this, event);

                for (var i = this.visStartPos; i < this.visEndPos; ++i) {
                    this.scrollControlAry[i].handleEvent(event);
                }
            }

            // 
            //  DESC: Handle OnUpAction message
            //

        }, {
            key: 'onUpAction',
            value: function onUpAction(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_9__common_defs__["k" /* EAP_DOWN */]) this.handleKeyboardGamepadScroll(-1);else if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_9__common_defs__["m" /* EAP_UP */]) this.endScroll = true;
            }

            // 
            //  DESC: Handle OnDownAction message
            //

        }, {
            key: 'onDownAction',
            value: function onDownAction(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_9__common_defs__["k" /* EAP_DOWN */]) this.handleKeyboardGamepadScroll(1);else if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_9__common_defs__["m" /* EAP_UP */]) this.endScroll = true;
            }

            // 
            //  DESC: Handle OnUpScroll message
            //

        }, {
            key: 'onUpScroll',
            value: function onUpScroll(event) {
                this.handleKeyboardGamepadScroll(-1);
                this.scrollMsg = true;
            }

            // 
            //  DESC: Handle OnDownScroll message
            //

        }, {
            key: 'onDownScroll',
            value: function onDownScroll(event) {
                this.handleKeyboardGamepadScroll(1);
                this.scrollMsg = true;
            } // OnDownScroll

            // 
            //  DESC: Handle OnTabLeft message
            //

        }, {
            key: 'onTabLeft',
            value: function onTabLeft(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_9__common_defs__["k" /* EAP_DOWN */]) this.handlePageScroll(-1);
            }

            // 
            //  DESC: Handle OnTabRight message
            //

        }, {
            key: 'onTabRight',
            value: function onTabRight(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_9__common_defs__["k" /* EAP_DOWN */]) this.handlePageScroll(1);
            }

            // 
            //  DESC: Handle the mouse move
            //

        }, {
            key: 'onMouseMove',
            value: function onMouseMove(event) {
                var result = _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'onMouseMove', this).call(this, event);

                // Invalidate the active control
                this.activeScrollCtrl = __WEBPACK_IMPORTED_MODULE_9__common_defs__["_58" /* NO_ACTIVE_CONTROL */];

                if (this.subControlAry[0].isMouseDown()) {
                    // Get the current scroll position
                    this.scrollCurPos = this.subControlAry[0].curValue;

                    // Set the bounds
                    this.setStartEndPos();

                    // Reposition the scroll controlls
                    this.repositionScrollControls();
                }

                return result;
            }

            // 
            //  DESC: Update the control
            //

        }, {
            key: 'update',
            value: function update() {
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'update', this).call(this);

                // Update all controls
                for (var i = this.visStartPos; i < this.visEndPos; ++i) {
                    this.scrollControlAry[i].update();
                } // Handle any scrolling
                this.handleScrollUpdate();
            }

            // 
            //  DESC: Transform the control
            //

        }, {
            key: 'doTransform',
            value: function doTransform(object) {
                // Call the parent
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'doTransform', this).call(this, object);

                // Transform all controls
                for (var i = this.visStartPos; i < this.visEndPos; ++i) {
                    this.scrollControlAry[i].doTransform(this);
                } // Transform the mask
                this.stencilMaskSprite.transform(this.matrix, this.wasWorldPosTranformed());
            }

            // 
            //  DESC: Render the sub control
            //

        }, {
            key: 'render',
            value: function render(matrix) {
                // Call the parent
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'render', this).call(this, matrix);

                // Disable rendering to the color buffer
                // NOTE: Using gl.FALSE or gl.TRUE causes a problem with this function call
                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].colorMask(false, false, false, false);

                // Disable rendering to the depth mask
                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].depthMask(false);

                // Start using the stencil
                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].enable(__WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].STENCIL_TEST);

                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].stencilFunc(__WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].ALWAYS, 0x1, 0x1);
                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].stencilOp(__WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].REPLACE, __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].REPLACE, __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].REPLACE);

                this.stencilMaskSprite.render(matrix);

                // Re-enable color
                // NOTE: Using gl.FALSE or gl.TRUE causes a problem with this function call
                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].colorMask(true, true, true, true);

                // Where a 1 was not rendered
                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].stencilFunc(__WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].EQUAL, 0x1, 0x1);

                // Keep the pixel
                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].stencilOp(__WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].KEEP, __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].KEEP, __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].KEEP);

                // Enable rendering to the depth mask
                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].depthMask(true);

                for (var i = this.visStartPos; i < this.visEndPos; ++i) {
                    this.scrollControlAry[i].render(matrix);
                } // Finished using stencil
                __WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].disable(__WEBPACK_IMPORTED_MODULE_4__system_device__["b" /* gl */].STENCIL_TEST);
            }

            // 
            //  DESC: Set the first inactive control to be active
            //  NOTE: Don't want this functuality for the scroll box buttons and slider
            //

        }, {
            key: 'activateFirstInactiveControl',
            value: function activateFirstInactiveControl() {
                if (_get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'baseActivateFirstInactiveControl', this).call(this)) {
                    for (var i = 0; i < this.scrollControlAry.length; ++i) {
                        if (this.scrollControlAry[i].activateFirstInactiveControl()) {
                            this.activeScrollCtrl = i;
                            break;
                        }
                    }
                }

                return this.activeScrollCtrl != __WEBPACK_IMPORTED_MODULE_9__common_defs__["_58" /* NO_ACTIVE_CONTROL */];
            }

            // 
            //  DESC: Handle the select action
            //

        }, {
            key: 'handleSelectAction',
            value: function handleSelectAction(event) {
                var result = _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'handleSelectAction', this).call(this, event);

                // Let the scroll controls handle any selection
                for (var i = 0; i < this.scrollControlAry.length; ++i) {
                    this.scrollControlAry[i].handleSelectAction(event);
                }if (event.detail.arg[__WEBPACK_IMPORTED_MODULE_9__common_defs__["_46" /* ESMA_DEVICE_TYPE */]] === __WEBPACK_IMPORTED_MODULE_9__common_defs__["_57" /* MOUSE */] && event.detail.arg[__WEBPACK_IMPORTED_MODULE_9__common_defs__["_49" /* ESMA_PRESS_TYPE */]] === __WEBPACK_IMPORTED_MODULE_9__common_defs__["k" /* EAP_DOWN */]) {
                    // Get the current scroll position
                    this.scrollCurPos = this.subControlAry[0].curValue;

                    // Set the bounds
                    this.setStartEndPos();

                    // Reposition the scroll controlls
                    this.repositionScrollControls();
                }

                return result;
            }

            // 
            //  DESC: Handle the page scrolling
            //

        }, {
            key: 'handlePageScroll',
            value: function handlePageScroll(scrollVector) {
                if (this.scrollVector == 0) {
                    // If there's no controls to select or reposition, do the scroll
                    if (!this.selectAndRepositionCtrl(scrollVector)) {
                        var SCROLL_DOWN = scrollVector > 0;
                        var SCROLL_UP = scrollVector < 0;

                        // Make sure we have some place to page to
                        if (SCROLL_UP && this.firstScrollCtrlIndex > 0 || SCROLL_DOWN && this.firstScrollCtrlIndex + this.visibleCount < this.scrollControlAry.length) {
                            var visibleCount = this.visibleCount;

                            // Cap the scroll amount to what is capable
                            if (SCROLL_UP && visibleCount > this.firstScrollCtrlIndex) {
                                visibleCount = this.firstScrollCtrlIndex;
                            } else if (SCROLL_DOWN && visibleCount + this.firstScrollCtrlIndex + this.visibleCount - 1 >= this.scrollControlAry.length) {
                                visibleCount = this.scrollControlAry.length - this.firstScrollCtrlIndex - this.visibleCount;
                            }

                            // Init the scroll
                            this.initScrolling(scrollVector, this.controlHeight * visibleCount, true, true);

                            // Deactivate the last control if the scrolling has been activated
                            if (this.scrollVector) {
                                if (this.activeScrollCtrl != __WEBPACK_IMPORTED_MODULE_9__common_defs__["_58" /* NO_ACTIVE_CONTROL */]) this.scrollControlAry[this.activeScrollCtrl].deactivateControl();
                            }
                        } else {
                            this.activeScrollCtrl = this.firstScrollCtrlIndex;

                            if (SCROLL_DOWN) this.activeScrollCtrl += this.visibleCount - 1;

                            // If the first control can't be selected, then find one that can
                            if (!this.activateScrollCtrl(this.activeScrollCtrl)) this.selectNextControl(-scrollVector);
                        }
                    }
                }
            }

            // 
            //  DESC: Handle the keyboard/Gamepad scrolling
            //

        }, {
            key: 'handleKeyboardGamepadScroll',
            value: function handleKeyboardGamepadScroll(scrollVector) {
                // If there's no controls to select or reposition, do the scroll
                if (!this.selectAndRepositionCtrl(scrollVector)) {
                    // Try to select the next control
                    var scrollResult = this.selectNextControl(scrollVector);

                    // Scroll the contents of the scroll box if we need to activate a control
                    // that's outside of the viewable area of the scroll box.
                    if (!(scrollResult & IN_VIEWABLE_AREA)) {
                        this.initScrolling(scrollVector, this.controlHeight);
                    }
                }
            }

            // 
            //  DESC: Select the next control
            //

        }, {
            key: 'selectNextControl',
            value: function selectNextControl(scrollVector) {
                // Set the active control to the viewable area
                this.setActiveCtrlToViewableArea(scrollVector);

                // Scroll to the next control in the viewable area
                var scrollResult = this.scrollToTheNextCtrlInViewableArea(scrollVector);

                // If we are still in the viewable area but have no active control,
                // try to activate the current control
                if (scrollResult & IN_VIEWABLE_AREA && !(scrollResult & NEW_ACTIVE_CTRL)) {
                    __WEBPACK_IMPORTED_MODULE_5__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_9__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_9__common_defs__["A" /* ECS_ACTIVE */], this.scrollControlAry[this.activeScrollCtrl]);
                }

                return scrollResult;
            }

            // 
            //  DESC: Do we need to select and reposition the control
            //

        }, {
            key: 'selectAndRepositionCtrl',
            value: function selectAndRepositionCtrl(scrollVector) {
                // If there's no selected control, don't scroll
                // just select the first selectable control
                if (this.setActiveCtrlToViewableArea(scrollVector)) {
                    // If the first control can't be selected, then find one that can
                    if (!this.activateScrollCtrl(this.activeScrollCtrl)) this.selectNextControl(1);

                    // Get the alignment to see if it needs to be adjusted
                    var diff = this.getControlAlignment();
                    if (diff > 0.1) {
                        var pos = this.scrollCurPos / this.controlHeight;

                        var nextCtrl = (this.activeScrollCtrl - this.firstScrollCtrlIndex) * this.controlHeight;

                        if (nextCtrl || this.firstScrollCtrlIndex > pos) this.initScrolling(1, this.controlHeight - diff, false);else this.initScrolling(-1, diff, false);
                    }

                    return true;
                }

                return false;
            }

            // 
            //  DESC: Select the paged control
            //

        }, {
            key: 'selectPagedControl',
            value: function selectPagedControl(scrollVector) {
                this.activeScrollCtrl += scrollVector * this.visibleCount;

                // Cap the control index
                if (this.activeScrollCtrl <= 0) {
                    this.activeScrollCtrl = 0;
                    scrollVector = 1;
                } else if (this.activeScrollCtrl >= this.scrollControlAry.length - 1) {
                    this.activeScrollCtrl = this.scrollControlAry.size() - 1;
                    scrollVector = -1;
                }

                // If the first control can't be selected, then find one that can
                if (!this.activateScrollCtrl(this.activeScrollCtrl)) this.selectNextControl(scrollVector);
            }

            // 
            //  DESC: Set the active control to the viewable area
            //        This also deactivates the last known active control
            //

        }, {
            key: 'setActiveCtrlToViewableArea',
            value: function setActiveCtrlToViewableArea(scrollVector) {
                // If the active control is not within the active area, make it so that it will be the first one selected
                if (this.activeScrollCtrl < this.firstScrollCtrlIndex || this.activeScrollCtrl >= this.firstScrollCtrlIndex + this.visibleCount) {
                    if (this.activeScrollCtrl != __WEBPACK_IMPORTED_MODULE_9__common_defs__["_58" /* NO_ACTIVE_CONTROL */]) this.scrollControlAry[this.activeScrollCtrl].deactivateControl();

                    this.activeScrollCtrl = this.firstScrollCtrlIndex;

                    return true;
                }

                return false;
            }

            // 
            //  DESC: Scroll to the next control in the viewable area
            //

        }, {
            key: 'scrollToTheNextCtrlInViewableArea',
            value: function scrollToTheNextCtrlInViewableArea(scrollVector) {
                var newActiveCtrl = 0;
                var inView = this.inView(this.activeScrollCtrl, scrollVector);

                // Only scroll within the viewable area
                if (inView) {
                    // Set a temp variable to the active scroll control
                    var tmpScrollCtrl = this.activeScrollCtrl;

                    // Loop until we hit a selectable control
                    do {
                        tmpScrollCtrl += scrollVector;

                        if (this.activateScrollCtrl(tmpScrollCtrl)) {
                            newActiveCtrl = NEW_ACTIVE_CTRL;

                            this.activeScrollCtrl = tmpScrollCtrl;
                            break;
                        }

                        inView = this.inView(tmpScrollCtrl, scrollVector);
                    } while (inView);
                }

                var result = inView | newActiveCtrl;

                return result;
            }

            // 
            //  DESC: See if we can activate this scroll control
            //

        }, {
            key: 'activateScrollCtrl',
            value: function activateScrollCtrl(scrollControlIndex) {
                if (scrollControlIndex != __WEBPACK_IMPORTED_MODULE_9__common_defs__["_58" /* NO_ACTIVE_CONTROL */] && scrollControlIndex < this.scrollControlAry.length && !this.scrollControlAry[scrollControlIndex].isDisabled()) {
                    __WEBPACK_IMPORTED_MODULE_5__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_9__common_defs__["W" /* EGE_MENU_CONTROL_STATE_CHANGE */], __WEBPACK_IMPORTED_MODULE_9__common_defs__["A" /* ECS_ACTIVE */], this.scrollControlAry[scrollControlIndex]);

                    return true;
                }

                return false;
            }

            // 
            //  DESC: Init the variables that scroll the contents of the scroll box
            //

        }, {
            key: 'initScrolling',
            value: function initScrolling(scrollVector, distance) {
                var endScrollSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
                var paging = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

                if (this.scrollVector === 0) {
                    var SCROLL_DOWN = scrollVector > 0;
                    var SCROLL_UP = scrollVector < 0;

                    if (SCROLL_UP && this.scrollCurPos > 0 || SCROLL_DOWN && this.scrollCurPos < this.maxMoveAmount) {
                        this.scrollVector = scrollVector;
                        this.scrollCounter = 0;
                        this.endScroll = false;
                        this.scrollMsg = false;
                        this.paging = paging;
                        this.endScrollSelection = endScrollSelection;
                        this.scrollDistance = distance;
                    }
                }
            }

            // 
            //  DESC: Handle the time based Scrolling of the contents of the scroll box
            //

        }, {
            key: 'handleScrollUpdate',
            value: function handleScrollUpdate() {
                if (this.scrollVector) {
                    var dist = __WEBPACK_IMPORTED_MODULE_6__utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime * this.scrollSpeed;

                    if (this.paging) dist = __WEBPACK_IMPORTED_MODULE_6__utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime * this.pageSpeed;

                    if (this.scrollVector > 0) this.scrollCurPos += dist;else this.scrollCurPos -= dist;

                    this.subControlAry[0].setSlider(this.scrollCurPos);

                    this.scrollCounter += dist;

                    // Set the bounds
                    this.setStartEndPos();

                    if (this.scrollCounter >= this.scrollDistance) {
                        if (this.endScroll || !this.scrollMsg || this.paging) {
                            this.alignScrollPostion();

                            if (this.endScrollSelection) {
                                if (this.paging) this.selectPagedControl(this.scrollVector);else this.selectNextControl(this.scrollVector);
                            }

                            // This has to be last
                            this.scrollVector = 0;
                        } else {
                            this.scrollDistance += this.controlHeight;
                        }
                    }
                    // Sanity check
                    else if (this.scrollCurPos < 0 || this.scrollCurPos > this.maxMoveAmount) {
                            this.alignScrollPostion();
                            this.scrollVector = 0;
                        }

                    // Reposition the scroll controls
                    this.repositionScrollControls();
                }
            }

            // 
            //  DESC: Get the fractional amount the controls are off within the scroll box
            //

        }, {
            key: 'getControlAlignment',
            value: function getControlAlignment() {
                var pos = this.scrollCurPos / this.controlHeight;
                return this.controlHeight * Math.trunc(pos);
            }

            // 
            //  DESC: Is the scroll index in view
            //

        }, {
            key: 'inView',
            value: function inView(scrollIndex, scrollVector) {
                return scrollVector < 0 && scrollIndex > this.firstScrollCtrlIndex || scrollVector > 0 && scrollIndex < this.firstScrollCtrlIndex + this.visibleCount - 1;
            }

            // 
            //  DESC: Get the reference to the subcontrol if found
            //

        }, {
            key: 'findSubControlByName',
            value: function findSubControlByName(name) {
                var ctrl = _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'findSubControlByName', this).call(this, name);

                for (var i = this.visStartPos; i < this.visEndPos && ctrl === null; ++i) {
                    ctrl = this.scrollControlAry[i].findControlByName(name);
                }return ctrl;
            }

            // 
            //  DESC: Find the sub control via is pointer
            //

        }, {
            key: 'findSubControlByRef',
            value: function findSubControlByRef(control) {
                var ctrl = _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'findSubControlByRef', this).call(this, control);

                for (var i = this.visStartPos; i < this.visEndPos && ctrl === null; ++i) {
                    if (this.scrollControlAry[i] === control) ctrl = this.scrollControlAry[i];
                }return ctrl;
            }

            // 
            //  DESC: Handle the sub control mouse move
            //

        }, {
            key: 'onSubControlMouseMove',
            value: function onSubControlMouseMove(event) {
                var result = _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'onSubControlMouseMove', this).call(this, event);

                // We only care about the scroll controls if the point is within the scroll box
                if (!result && this.isPointInControl(event.clientX + __WEBPACK_IMPORTED_MODULE_5__managers_eventmanager__["a" /* eventManager */].mouseOffsetX, event.clientY + __WEBPACK_IMPORTED_MODULE_5__managers_eventmanager__["a" /* eventManager */].mouseOffsetY)) {
                    for (var i = this.visStartPos; i < this.visEndPos && !result; ++i) {
                        result = this.scrollControlAry[i].onMouseMove(event);

                        if (result) this.activeScrollCtrl = i;
                    }
                }

                return result;
            }

            // 
            //  DESC: Deactivate the sub control
            //

        }, {
            key: 'deactivateSubControl',
            value: function deactivateSubControl() {
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'deactivateSubControl', this).call(this);

                for (var i = this.visStartPos; i < this.visEndPos; ++i) {
                    this.scrollControlAry[i].deactivateControl();
                }
            }

            // 
            //  DESC: Set the start and end positions
            //

        }, {
            key: 'setStartEndPos',
            value: function setStartEndPos() {
                var pos = this.scrollCurPos / this.controlHeight;

                // Push the ceiling so that the starting index is viewable
                this.firstScrollCtrlIndex = Math.trunc(pos + 0.7);

                this.visStartPos = Math.trunc(pos);
                this.visEndPos = this.visStartPos + this.visibleCount + 1;

                // Sanity checks
                if (this.visStartPos < 0) this.visStartPos = 0;

                if (this.visEndPos > this.scrollControlAry.length) this.visEndPos = this.scrollControlAry.length;
            }

            // 
            //  DESC: Reposition the scroll controls
            //

        }, {
            key: 'repositionScrollControls',
            value: function repositionScrollControls() {
                for (var i = this.visStartPos; i < this.visEndPos; ++i) {
                    var pos = this.scrollControlAry[i].position;
                    var y = this.defaultOffsetAry[i] + this.scrollCurPos;
                    this.scrollControlAry[i].setPosXYZ(pos.x, y, pos.z);
                }
            }

            // 
            //  DESC: Align the scroll box to it's proper stopping point
            //        to account for floating point movement
            //

        }, {
            key: 'alignScrollPostion',
            value: function alignScrollPostion() {
                // Do bounds checking just for sanity reasons
                if (this.firstScrollCtrlIndex < 0) this.firstScrollCtrlIndex = 0;else if (this.firstScrollCtrlIndex + this.visibleCount > this.scrollControlAry.length) this.firstScrollCtrlIndex = this.scrollControlAry.length - this.visibleCount;

                // Recalucate the scroll position which will wipe the fractional component
                this.scrollCurPos = this.firstScrollCtrlIndex * this.controlHeight;
            }

            // 
            //  DESC: Only deactivate sub controls
            //

        }, {
            key: 'deactivateControl',
            value: function deactivateControl() {
                this.deactivateSubControl();
            }

            // 
            //  DESC: Set the alpha value of this control
            //

        }, {
            key: 'setAlpha',
            value: function setAlpha(alpha) {
                _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'setAlpha', this).call(this, alpha);

                for (var i = this.visStartPos; i < this.visEndPos; ++i) {
                    this.scrollControlAry[i].setAlpha(alpha);
                }
            }

            // 
            //  DESC: Get the pointer to the active control
            //

        }, {
            key: 'getActiveControl',
            value: function getActiveControl() {
                var result = _get(UIScrollBox.prototype.__proto__ || Object.getPrototypeOf(UIScrollBox.prototype), 'getActiveControl', this).call(this);

                if (result === null) {
                    for (var i = 0; i < this.scrollControlAry.length; ++i) {
                        if (this.scrollControlAry[i].state > __WEBPACK_IMPORTED_MODULE_9__common_defs__["C" /* ECS_INACTIVE */]) {
                            result = scrollControlAry[i].getActiveControl();
                            break;
                        }
                    }
                }

                return result;
            }
        }]);

        return UIScrollBox;
    }(__WEBPACK_IMPORTED_MODULE_0__uisubcontrol__["a" /* UISubControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UIScrollBox;

    /***/
},
/* 87 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__utilities_timer__ = __webpack_require__(88);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_highresolutiontimer__ = __webpack_require__(8);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_size__ = __webpack_require__(1);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__uicontrol__ = __webpack_require__(17);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__script_scriptmanager__ = __webpack_require__(14);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__common_defs__ = __webpack_require__(0);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__utilities_xmlparsehelper__ = __webpack_require__(4);

    // 
    //  FILE NAME: uimeter.js
    //  DESC:      Class for user interface meters
    //


    // EBangType
    var EBT_RAMP_UP = 0,
        EBT_LINEAR = 1,
        EBT_HYBRID = 2;

    // EScaleType
    var EST_AXIS = 0,
        EST_ACCURATE = 1;

    var BangRange = function BangRange(target, bangType, velocity, estimatedTime, slowStartTime) {
        _classCallCheck(this, BangRange);

        this.target = target;
        this.bangType = bangType;
        this.velocity = velocity;
        this.estimatedTime = estimatedTime;
        this.slowStartTime = slowStartTime;
    };

    var UIMeter = function (_WEBPACK_IMPORTED_MO25) {
        _inherits(UIMeter, _WEBPACK_IMPORTED_MO25);

        function UIMeter(group) {
            _classCallCheck(this, UIMeter);

            var _this39 = _possibleConstructorReturn(this, (UIMeter.__proto__ || Object.getPrototypeOf(UIMeter)).call(this, group));

            _this39.type = __WEBPACK_IMPORTED_MODULE_5__common_defs__["K" /* ECT_METER */];

            // Current value
            _this39.currentValue = 0;

            // Target value
            _this39.targetValue = 0;

            // Velocity value
            _this39.velocity = 0;

            // Terminal velocity value
            _this39.terminalVelocity = 0;

            // Acceleration value
            _this39.acceleration = 0;

            // Impulse value
            _this39.impulse = 0;

            // last value
            _this39.lastValue = 0;

            // fast bang time amount
            _this39.fastBangTime = 0;

            // bang up flag
            _this39.bangUp = false;

            // spin timer
            _this39.startUpTimer = new __WEBPACK_IMPORTED_MODULE_0__utilities_timer__["a" /* Timer */]();

            // Current bang range
            _this39.bangRange = new BangRange();

            // Sprite reference to font
            _this39.fontSprite = null;

            // Bang range value
            _this39.bangRangeAry = [];

            // Max Font string size for this meter
            _this39.maxFontStrSize = null;

            // The amount to scale the font by to fit within the meter
            _this39.bangScaleAdjustment = new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */]();

            // Scale on axis or accurate
            _this39.scaleType = EST_AXIS;

            // On meter script function names
            _this39.meterScriptFunction = new Map();
            return _this39;
        }

        //
        //  DESC: Load the control info from XML node
        //


        _createClass(UIMeter, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                _get(UIMeter.prototype.__proto__ || Object.getPrototypeOf(UIMeter.prototype), 'loadFromNode', this).call(this, node);

                // Get the bang range info
                var bangRangeNode = node.getElementsByTagName('bangRange');
                if (bangRangeNode.length) {
                    // Get the fast bang time
                    this.fastBangTime = Number(bangRangeNode[0].getAttribute('fastBangTime'));

                    // Set the scale type - How the font is scaled to fit within the meter
                    if (bangRangeNode[0].getAttribute('scaleType') === 'accurate') this.scaleType = EST_ACCURATE;

                    var rangeNode = bangRangeNode[0].getElementsByTagName('range');

                    for (var i = 0; i < rangeNode.length; ++i) {
                        var attr = rangeNode[i].getAttribute('bangUpType');
                        var bangType = EBT_RAMP_UP;
                        if (attr === 'linear') bangType = EBT_LINEAR;else if (attr === 'hybrid') bangType = EBT_HYBRID;

                        this.bangRangeAry.push(new BangRange(Number(rangeNode[i].getAttribute('target')), bangType, Number(rangeNode[i].getAttribute('velocity')), Number(rangeNode[i].getAttribute('estimatedTime')), Number(rangeNode[i].getAttribute('slowStartTime'))));
                    }
                }

                // Get the meter script functions
                var meterScriptNode = node.getElementsByTagName('meterScript');
                if (meterScriptNode.length) {
                    var _attr4 = meterScriptNode[0].getAttribute("onInit");
                    if (_attr4) this.meterScriptFunction.set(__WEBPACK_IMPORTED_MODULE_5__common_defs__["_30" /* EMSF_ON_INIT */], __WEBPACK_IMPORTED_MODULE_4__script_scriptmanager__["a" /* scriptManager */].get(_attr4));

                    _attr4 = meterScriptNode[0].getAttribute("onStart");
                    if (_attr4) this.meterScriptFunction.set(__WEBPACK_IMPORTED_MODULE_5__common_defs__["_31" /* EMSF_ON_START */], __WEBPACK_IMPORTED_MODULE_4__script_scriptmanager__["a" /* scriptManager */].get(_attr4));

                    _attr4 = meterScriptNode[0].getAttribute("onStop");
                    if (_attr4) this.meterScriptFunction.set(__WEBPACK_IMPORTED_MODULE_5__common_defs__["_32" /* EMSF_ON_STOP */], __WEBPACK_IMPORTED_MODULE_4__script_scriptmanager__["a" /* scriptManager */].get(_attr4));

                    _attr4 = meterScriptNode[0].getAttribute("onClear");
                    if (_attr4) this.meterScriptFunction.set(__WEBPACK_IMPORTED_MODULE_5__common_defs__["_29" /* EMSF_ON_CLEAR */], __WEBPACK_IMPORTED_MODULE_4__script_scriptmanager__["a" /* scriptManager */].get(_attr4));
                }

                // Get the max size of the font string to fit within this meter.
                // As the string get's bigger, it will be scaled to fit.
                this.maxFontStrSize = __WEBPACK_IMPORTED_MODULE_6__utilities_xmlparsehelper__["j" /* loadSize */](node);
            }

            //
            //  DESC: Load the control specific info from XML node
            //

        }, {
            key: 'loadControlFromNode',
            value: function loadControlFromNode(controlNode) {
                // Call the parent
                _get(UIMeter.prototype.__proto__ || Object.getPrototypeOf(UIMeter.prototype), 'loadControlFromNode', this).call(this, controlNode);

                // Find the sprite that renders the font
                this.findFontSprite();
            }

            // 
            //  DESC: Init the meter
            //  NOTE: Used to init this control manually
            //

        }, {
            key: 'initMeter',
            value: function initMeter(fastBangTime, scaleType, sizeW, sizeH) {
                this.fastBangTime = fastBangTime;
                this.scaleType = scaleType;
                this.maxFontStrSize = new __WEBPACK_IMPORTED_MODULE_2__common_size__["a" /* Size */](sizeW, sizeH);
            }

            // 
            //  DESC: Set the bang range
            //  NOTE: Used to init this control manually
            //

        }, {
            key: 'setBangeRange',
            value: function setBangeRange(target, bangUpType, velocity, estimatedTime, slowStartTime) {
                this.bangRangeAry.push(new BangRange(target, bangUpType, velocity, estimatedTime, slowStartTime));
            }

            // 
            //  DESC: Load a sprite from an array
            //  NOTE: Used to init this control manually
            //

        }, {
            key: 'loadSpriteFromArray',
            value: function loadSpriteFromArray(objectNameAry, spriteApplyIndex) {
                var stencilMaskSprite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

                _get(UIMeter.prototype.__proto__ || Object.getPrototypeOf(UIMeter.prototype), 'loadSpriteFromArray', this).call(this, objectNameAry);

                // Find the sprite that renders the font
                this.findFontSprite();
            }

            //
            //  DESC: Find the sprite that renders the font
            //

        }, {
            key: 'findFontSprite',
            value: function findFontSprite() {
                for (var i = 0; i < this.spriteAry.length; ++i) {
                    if (this.spriteAry[i].visualComponent.isFontSprite()) {
                        this.fontSprite = this.spriteAry[i];
                        break;
                    }
                }

                if (this.fontSprite == null) throw new Error('UI Meter doesn\'t have a sprite for rendering a font string (' + this.name + ').');
            }

            //
            //  DESC: Set the amount to the meter without banging up
            //

        }, {
            key: 'set',
            value: function set(amount) {
                if (amount > 0 && amount !== this.currentValue) {
                    this.lastValue = this.currentValue;
                    this.currentValue = this.targetValue = amount;

                    // Display the value in the meter
                    this.displayValue();
                }
            }

            //
            //  DESC: Start the bang range
            //

        }, {
            key: 'startBangUp',
            value: function startBangUp(amount) {
                if (amount !== this.currentValue) {
                    this.targetValue = amount;
                    this.bangUp = true;

                    this.setBangRange();
                }
            }

            //
            //  DESC: Set the bang range
            //

        }, {
            key: 'setBangRange',
            value: function setBangRange() {
                var found = false;

                for (var i = 0; i < this.bangRangeAry; ++i) {
                    if (this.targetValue - this.currentValue <= this.bangRangeAry[i].target) {
                        found = true;
                        this.initBangRange(this.bangRangeAry[i]);
                        break;
                    }
                }

                if (!found) this.initBangRange(this.bangRangeAry[this.bangRangeAry.length - 1]);
            }

            //
            //  DESC: Init the bang range
            //

        }, {
            key: 'initBangRange',
            value: function initBangRange(bangRange) {
                this.bangRange = bangRange;
                this.terminalVelocity = 0.0;
                this.acceleration = 0.0;
                this.impulse = 0.0;
                this.bangScaleAdjustment.set(1, 1);

                this.fontSprite.setScaleXYZ(1, 1, 1);

                this.velocity = bangRange.velocity / 1000.0;

                var range = this.targetValue - this.currentValue;

                // Ramp up from start to finish
                if (bangRange.bangType === EBT_RAMP_UP) {
                    this.impulse = range / (bangRange.estimatedTime * bangRange.estimatedTime * 1000.0);
                    this.acceleration = this.impulse;
                }
                // Linear bang up from the start
                else if (bangRange.bangType === EBT_LINEAR) {
                        this.acceleration = range / (bangRange.estimatedTime * 1000.0);
                    }
                    // combination of ramp up and linear
                    else if (bangRange.bangType === EBT_HYBRID) {
                            this.terminalVelocity = range / (bangRange.estimatedTime * 1000.0);
                            this.impulse = range / (bangRange.estimatedTime * bangRange.estimatedTime * 500.0);
                            this.acceleration = impulse;
                        }

                // Set the timer to allow the bang-up to start off slowly
                this.startUpTimer.set(bangRange.slowStartTime);

                var scriptFunc = this.meterScriptFunction.get(__WEBPACK_IMPORTED_MODULE_5__common_defs__["_31" /* EMSF_ON_START */]);
                if (scriptFunc) this.fontSprite.prepareScriptFactory(scriptFunc);
            }

            //
            //  DESC: Do a fast bang
            //

        }, {
            key: 'fastBang',
            value: function fastBang() {
                if (this.bangUp) {
                    var acceleration = (this.targetValue - this.currentValue) / this.fastBangTime;

                    // use the fast bang acceleration if the current one is less
                    if (this.acceleration < acceleration) this.acceleration = acceleration;
                }
            }

            //
            //  DESC: Update the control
            //

        }, {
            key: 'update',
            value: function update() {
                _get(UIMeter.prototype.__proto__ || Object.getPrototypeOf(UIMeter.prototype), 'update', this).call(this);

                if (this.bangUp) {
                    var elapsedTime = __WEBPACK_IMPORTED_MODULE_1__utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;

                    // Ramp up from start to finish
                    if (this.bangRange.bangType === EBT_RAMP_UP) {
                        this.currentValue += this.velocity * elapsedTime;

                        if (this.startUpTimer.expired()) {
                            this.velocity += this.acceleration * elapsedTime;
                            this.acceleration += this.impulse * elapsedTime;
                        } else {
                            this.velocity += this.acceleration * elapsedTime;
                        }
                    }
                    // Linear bang up from the start
                    else if (this.bangRange.this.bangType === EBT_LINEAR) {
                            this.currentValue += this.velocity;

                            if (this.startUpTimer.expired()) this.velocity += this.acceleration * elapsedTime;
                        }
                        // combination of ramp up and linear
                        else if (this.bangRange.bangType === EBT_HYBRID) {
                                this.currentValue += this.velocity;

                                if (this.startUpTimer.expired()) {
                                    if (this.terminalVelocity > this.acceleration) {
                                        this.velocity += this.acceleration * elapsedTime;
                                        this.acceleration += this.impulse * elapsedTime;
                                    } else {
                                        this.velocity += this.acceleration * elapsedTime;
                                    }
                                } else {
                                    this.velocity += this.acceleration * elapsedTime;
                                }
                            }

                    // Only update the meter if the value is different
                    if (this.lastValue != this.currentValue) {
                        this.lastValue = this.currentValue;

                        // check if the bang up has finished
                        if (this.currentValue > this.targetValue) {
                            this.currentValue = this.targetValue;
                            this.bangUp = false;

                            // Call the script function if one is defined
                            var scriptFunc = this.meterScriptFunction.get(__WEBPACK_IMPORTED_MODULE_5__common_defs__["_31" /* EMSF_ON_START */]);
                            if (scriptFunc) this.fontSprite.prepareScriptFactory(scriptFunc);
                        }

                        // Display the value in the meter
                        this.displayValue();
                    }
                }
            }

            //
            //  DESC: Display the value in the meter
            //

        }, {
            key: 'displayValue',
            value: function displayValue() {
                // Display the new value
                this.fontSprite.visualComponent.createFontString(Math.trunc(this.currentValue).toString());

                // Get the font size
                var size = this.fontSprite.visualComponent.getFontSize();

                // Check if the font string size is greater then what is allowed
                if (size.w > this.maxFontStrSize.w || size.h > this.maxFontStrSize.h) {
                    var difW = this.maxFontStrSize.w / size.w;
                    var difH = this.maxFontStrSize.h / size.h;

                    // Is the difference less then the last size change
                    if (difW < this.bangScaleAdjustment.w || difH < this.bangScaleAdjustment.h) {
                        this.bangScaleAdjustment.set(difW, difH);

                        var scaleX = this.fontSprite.scale.x;
                        var scaleY = this.fontSprite.scale.y;
                        if (difW < difH) {
                            scaleX = difW;

                            if (this.scaleType !== EST_AXIS) scaleY = difW;
                        } else {
                            scaleY = difH;

                            if (this.scaleType !== EST_AXIS) scaleX = difH;
                        }

                        this.fontSprite.setScaleXYZ(scaleX, scaleY);
                    }
                }
            }

            //
            //  DESC: Clear the meter
            //

        }, {
            key: 'clear',
            value: function clear() {
                this.lastValue = this.currentValue = this.targetValue = 0;
                this.bangUp = false;

                var scriptFunc = this.meterScriptFunction.get(__WEBPACK_IMPORTED_MODULE_5__common_defs__["_29" /* EMSF_ON_CLEAR */]);
                if (scriptFunc) this.fontSprite.prepareScriptFactory(scriptFunc);else this.fontSprite.visualComponent.createFontString(this.currentValue.toString());
            }

            //
            //  DESC: Is the meter banging
            //

        }, {
            key: 'isBanging',
            value: function isBanging() {
                return this.bangUp;
            }
        }]);

        return UIMeter;
    }(__WEBPACK_IMPORTED_MODULE_3__uicontrol__["a" /* UIControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = UIMeter;

    /***/
},
/* 88 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME: timer.js
    //  DESC:      timer class
    //


    var Timer = function () {
        function Timer() {
            var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var startExpired = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            _classCallCheck(this, Timer);

            // Expired time
            this.expiredTime = false;

            // time interval
            this.timeInterval = interval;

            // Disabled flag
            this.disabled = false;

            // Disabled return value.
            // This value allows a disabled timer to act as expired or not
            this.disableValue = false;

            if (startExpired) this.setExpired();else this.reset();
        }

        //
        //  DESC: Reset the timer to start over
        //


        _createClass(Timer, [{
            key: 'reset',
            value: function reset() {
                this.expiredTime = this.timeInterval + performance.now();
                this.disabled = false;
            }

            //
            //  DESC: Set the time to have expired
            //

        }, {
            key: 'setExpired',
            value: function setExpired() {
                this.expiredTime = performance.now();
            }

            //
            //  DESC: Set the timer interval
            //

        }, {
            key: 'set',
            value: function set(interval) {
                this.timeInterval = interval;
                this.reset();
            }

            //
            //  DESC: Has the timer expired?
            //

        }, {
            key: 'expired',
            value: function expired(resetOnExpire) {
                // Has the timer been disabled
                if (this.disabled) return this.disableValue;

                var result = false;

                if (performance.now() > this.expiredTime) {
                    result = true;

                    if (resetOnExpire) this.reset();
                }

                return result;
            }

            //
            //  DESC: Disable this timer
            //

        }, {
            key: 'disable',
            value: function disable(disabled) {
                this.disabled = disabled;
            }

            //
            //  DESC: Set the value returned by Expired when the timer is disabled
            //

        }, {
            key: 'setDisableValue',
            value: function setDisableValue(disableValue) {
                this.disableValue = disableValue;
            }
        }]);

        return Timer;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Timer;

    /***/
},
/* 89 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__common_defs__ = __webpack_require__(0);
    // 
    //  FILE NAME: menutree.js
    //  DESC:      Class that hold a tree of menus
    //


    var MenuTree = function () {
        function MenuTree(name, menuMap, rootMenu, defaultMenu) {
            var interfaceMenu = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

            _classCallCheck(this, MenuTree);

            // Name of the tree
            this.name = name;

            // Map of the menus
            this.menuMap = menuMap;

            // root menu
            this.rootMenu = menuMap.get(rootMenu);

            // default menu
            this.defaultMenu = menuMap.get(defaultMenu);

            // Is interface menu?
            this.interfaceMenu = interfaceMenu;

            // Name of menu we are transitioning to
            this.toMenu = '';

            // Array of the path taken through the menu
            this.menuPathAry = [];

            // menu tree state
            this.state = __WEBPACK_IMPORTED_MODULE_1__common_defs__["_37" /* EMTS_IDLE */];
        }

        // 
        //  DESC: Init the tree for use
        //


        _createClass(MenuTree, [{
            key: 'init',
            value: function init() {
                this.menuPathAry = [];

                if (this.rootMenu !== undefined) {
                    // If we have a root menu, add it to the path
                    this.menuPathAry.push(this.rootMenu);

                    this.rootMenu.activateMenu();
                }
            }

            // 
            //  DESC: Update the menu tree
            //

        }, {
            key: 'update',
            value: function update() {
                if (this.menuPathAry.length) this.menuPathAry[this.menuPathAry.length - 1].update();
            }

            // 
            //  DESC: Transform the menu tree
            //

        }, {
            key: 'doTransform',
            value: function doTransform() {
                if (this.menuPathAry.length) this.menuPathAry[this.menuPathAry.length - 1].doTransform();
            }

            // 
            //  DESC: do the render
            //

        }, {
            key: 'render',
            value: function render(matrix) {
                if (this.menuPathAry.length) this.menuPathAry[this.menuPathAry.length - 1].render(matrix);
            }

            // 
            //  DESC: Is a menu active?
            //

        }, {
            key: 'isActive',
            value: function isActive() {
                return this.menuPathAry.length > 0;
            }

            // 
            //  DESC: Does this tee have a root menu
            //

        }, {
            key: 'hasRootMenu',
            value: function hasRootMenu() {
                return this.rootMenu != undefined;
            }

            // 
            //  DESC: Handle events
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                // Trap only controller events to check for actions
                if (!this.interfaceMenu) {
                    if (this.menuPathAry.length) this.menuPathAry[this.menuPathAry.length - 1].handleEvent(event);

                    if (event instanceof CustomEvent) {
                        if (this.state === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_37" /* EMTS_IDLE */]) {
                            if (event.detail.type === __WEBPACK_IMPORTED_MODULE_1__common_defs__["Y" /* EGE_MENU_ESCAPE_ACTION */]) {
                                this.onEscape(event);
                            } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_12" /* EGE_MENU_TOGGLE_ACTION */]) {
                                this.onToggle(event);
                            } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_1__common_defs__["V" /* EGE_MENU_BACK_ACTION */]) {
                                this.onBack(event);
                            } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_14" /* EGE_MENU_TO_TREE */]) {
                                this.onToTree(event);
                            } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_13" /* EGE_MENU_TO_MENU */]) {
                                this.onToMenu(event);
                            }
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_15" /* EGE_MENU_TRANS_IN */]) {
                            this.onTransIn(event);
                        } else if (event.detail.type === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_16" /* EGE_MENU_TRANS_OUT */]) {
                            this.onTransOut(event);
                        }
                    }
                } else {
                    // Don't process menu specific messages for an interface menu
                    if (event instanceof CustomEvent && event.detail.type <= __WEBPACK_IMPORTED_MODULE_1__common_defs__["Z" /* EGE_MENU_GAME_STATE_CHANGE */]) return;

                    if (this.menuPathAry.length) this.menuPathAry[this.menuPathAry.length - 1].handleEvent(event);
                }
            }

            // 
            //  DESC: Transition the menu
            //

        }, {
            key: 'transitionMenu',
            value: function transitionMenu() {
                // If the path array is empty, transition to the default menu
                if (this.menuPathAry.length === 0) {
                    // Make sure the menu exists
                    if (this.defaultMenu === undefined) throw new Error('Default menu does not exist!');

                    // Add the default menu to the path
                    this.menuPathAry.push(this.defaultMenu);

                    // Get the name of the menu we are transitioning to
                    // This is also used as a flag to indicate moving up the menu tree
                    this.toMenu = this.defaultMenu.name;

                    // Set the state as "active" so that input messages are ignored
                    this.state = __WEBPACK_IMPORTED_MODULE_1__common_defs__["_36" /* EMTS_ACTIVE */];

                    // Start the transition in
                    __WEBPACK_IMPORTED_MODULE_0__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_1__common_defs__["_15" /* EGE_MENU_TRANS_IN */], __WEBPACK_IMPORTED_MODULE_1__common_defs__["_50" /* ETC_BEGIN */]);
                } else {
                    // If this isn't the root menu, start the transition out
                    if (this.menuPathAry[this.menuPathAry.length - 1] != this.rootMenu) {
                        // Set the state as "active" so that input messages are ignored
                        this.state = __WEBPACK_IMPORTED_MODULE_1__common_defs__["_36" /* EMTS_ACTIVE */];

                        // Start the transition out
                        __WEBPACK_IMPORTED_MODULE_0__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_1__common_defs__["_16" /* EGE_MENU_TRANS_OUT */], __WEBPACK_IMPORTED_MODULE_1__common_defs__["_50" /* ETC_BEGIN */]);
                    }
                }
            }

            // 
            //  DESC: Handle OnEscape message
            //

        }, {
            key: 'onEscape',
            value: function onEscape(event) {
                var nameStr = event.detail.arg[0];
                if (this.menuPathAry.length || nameStr !== null && nameStr === this.name) {
                    this.transitionMenu();
                }
            }

            // 
            //  DESC: Handle OnToggle message
            //

        }, {
            key: 'onToggle',
            value: function onToggle(event) {
                var nameStr = event.detail.arg[0];
                if (this.menuPathAry.length || nameStr !== null && nameStr === this.name) {
                    // Toggle "on" only works when there is no root menu
                    if (this.rootMenu === undefined) {
                        this.transitionMenu();

                        // For toggle, clear out the path array except for the current menu
                        // The current menu will then be used for the transitions out
                        if (this.menuPathAry.length > 1) {
                            var curMenu = this.menuPathAry[this.menuPathAry.length - 1];
                            this.menuPathAry = [];
                            this.menuPathAry.push(curMenu);
                        }
                    } else {
                        if (this.menuPathAry.length > 1) this.transitionMenu();

                        // For toggle, clear out the path array except for the current and root menu
                        // The current menu will then be used for the transitions out
                        if (this.menuPathAry.length > 2) {
                            var _curMenu = this.menuPathAry[this.menuPathAry.length - 1];
                            this.menuPathAry = [];
                            this.menuPathAry.push(this.rootMenu);
                            this.menuPathAry.push(_curMenu);
                        }
                    }
                }
            }

            // 
            //  DESC: Handle OnBack message
            //

        }, {
            key: 'onBack',
            value: function onBack(event) {
                // Going back one require there to be a active menu that is not root
                if (this.menuPathAry.length && this.menuPathAry[this.menuPathAry.length - 1] != this.rootMenu) {
                    this.transitionMenu();
                }
            }

            // 
            //  DESC: Handle OnToTree message
            //

        }, {
            key: 'onToTree',
            value: function onToTree(event) {
                var nameStr = event.detail.arg[0];
                if (nameStr !== null && nameStr === this.name) {
                    // Only works when there is no root menu
                    if (this.rootMenu === undefined) this.transitionMenu();
                }
            }

            // 
            //  DESC: Handle OnToMenu message
            //

        }, {
            key: 'onToMenu',
            value: function onToMenu(event) {
                // Going to a menu require there to be a active menu
                // and the calling control is on a menu on this tree
                if (this.menuPathAry.length && this.menuPathAry[this.menuPathAry.length - 1].getActiveControl() == event.detail.arg[1]) {
                    // Set the state as "active" so that input messages are ignored
                    this.state = __WEBPACK_IMPORTED_MODULE_1__common_defs__["_36" /* EMTS_ACTIVE */];

                    // Get the name of the menu we are transitioning to
                    // This is also used as a flag to indicate moving deaper into the menu tree
                    this.toMenu = event.detail.arg[0];

                    // Do a sanity check to make sure the menu exists
                    if (this.menuMap.get(this.toMenu) === undefined) throw new Error('Menu does not exist! (' + this.toMenu + ').');

                    // Start the transition out
                    __WEBPACK_IMPORTED_MODULE_0__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_1__common_defs__["_16" /* EGE_MENU_TRANS_OUT */], __WEBPACK_IMPORTED_MODULE_1__common_defs__["_50" /* ETC_BEGIN */]);
                }
            }

            // 
            //  DESC: Handle OnTransOut message
            //

        }, {
            key: 'onTransOut',
            value: function onTransOut(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_51" /* ETC_END */]) {
                    if (this.toMenu.length) {
                        this.menuPathAry.push(this.menuMap.get(this.toMenu));
                        __WEBPACK_IMPORTED_MODULE_0__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_1__common_defs__["_15" /* EGE_MENU_TRANS_IN */], __WEBPACK_IMPORTED_MODULE_1__common_defs__["_50" /* ETC_BEGIN */]);
                    } else if (this.menuPathAry.length && this.menuPathAry[this.menuPathAry.length - 1] !== this.rootMenu) {
                        // Pop it off the array because this menu is done
                        var menu = this.menuPathAry.pop();

                        // Do a full reset on all the controls
                        menu.reset();

                        if (this.menuPathAry.length) __WEBPACK_IMPORTED_MODULE_0__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_1__common_defs__["_15" /* EGE_MENU_TRANS_IN */], __WEBPACK_IMPORTED_MODULE_1__common_defs__["_50" /* ETC_BEGIN */]);
                    }

                    // Normally, after one menu transitions out, the next menu transitions in
                    // Only set the idle state if this transition out is final
                    if (this.menuPathAry.length === 0) this.state = __WEBPACK_IMPORTED_MODULE_1__common_defs__["_37" /* EMTS_IDLE */];
                }
            }

            // 
            //  DESC: Handle OnTransIn message
            //

        }, {
            key: 'onTransIn',
            value: function onTransIn(event) {
                if (event.detail.arg[0] === __WEBPACK_IMPORTED_MODULE_1__common_defs__["_51" /* ETC_END */]) {
                    // m_toMenu is also used as a flag to indicate moving up the menu tree
                    // When moving up the menu tree, activate the first control on the menu
                    // When backing out of the menu tree, activate the last control used
                    __WEBPACK_IMPORTED_MODULE_0__managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_1__common_defs__["_9" /* EGE_MENU_SET_ACTIVE_CONTROL */], this.toMenu.length === 0 ? __WEBPACK_IMPORTED_MODULE_1__common_defs__["j" /* EAC_LAST_ACTIVE_CONTROL */] : __WEBPACK_IMPORTED_MODULE_1__common_defs__["i" /* EAC_FIRST_ACTIVE_CONTROL */]);

                    // Set to idle to allow for input messages to come through
                    this.state = __WEBPACK_IMPORTED_MODULE_1__common_defs__["_37" /* EMTS_IDLE */];

                    // Clear in the event we start backing out of the menu tree
                    this.toMenu = '';
                }
            }

            // 
            //  DESC: Get the active menu
            //

        }, {
            key: 'getActiveMenu',
            value: function getActiveMenu() {
                if (this.menuPathAry.length === 0) throw new Error('There is no active menu!');

                return this.menuPathAry[this.menuPathAry.length - 1];
            }

            // 
            //  DESC: Get the scroll param data
            //

        }, {
            key: 'getScrollParam',
            value: function getScrollParam(msg) {
                if (this.menuPathAry.length === 0) throw new Error('There is no active menu!');

                return this.menuPathAry[this.menuPathAry.length - 1].getScrollParam(msg);
            }

            // 
            //  DESC: Is a menu item active
            //

        }, {
            key: 'isMenuItemActive',
            value: function isMenuItemActive() {
                if (this.isActive()) {
                    if (this.getActiveMenu().getActiveControl() !== null) return false;
                }

                return false;
            }
        }]);

        return MenuTree;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = MenuTree;

    /***/
},
/* 90 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME: sound.js
    //  DESC:      Class to hold the sound reference and type
    //


    var Sound = function () {
        function Sound() {
            var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            _classCallCheck(this, Sound);

            // Sound type - loaded or stream
            this.type = type;

            // Audio context
            this.context = null;

            // Sound buffer
            this.buffer = null;

            // Sound source that needs to be recreated
            // each time the sound is played
            this.source = null;

            // Default volume of sound
            this.defaultVolume = 1;

            // Gain node for volume
            this.gainNode = null;

            // The time the sound started
            this.startTime = null;

            // Pause flag
            this.paused = false;

            // The play time
            this.playDuration = 0;
        }

        //
        //  DESC: Init the sound
        //


        _createClass(Sound, [{
            key: 'loadFromNode',
            value: function loadFromNode(node) {
                // Set the volume if defined
                var attr = node.getAttribute('volume');
                if (attr) this.defaultVolume = Number(attr);
            }

            //
            //  DESC: Init the sound
            //

        }, {
            key: 'init',
            value: function init(context, buffer) {
                this.context = context;
                this.buffer = buffer;

                this.gainNode = this.context.createGain();
                this.gainNode.gain.value = this.defaultVolume;
            }

            //
            //  DESC: Play the sound
            //

        }, {
            key: 'play',
            value: function play() {
                var loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                this.stop();

                this.playDuration = offset;
                this.source = this.context.createBufferSource();
                this.source.buffer = this.buffer;

                this.source.loop = loop;

                this.source.connect(this.gainNode);
                this.gainNode.connect(this.context.destination);

                this.startTime = this.context.currentTime;
                this.source.start(0, offset);
            }

            //
            //  DESC: Stop the sound
            //

        }, {
            key: 'stop',
            value: function stop() {
                if (this.startTime) {
                    this.startTime = null;
                    this.paused = false;
                    this.playDuration = 0;
                    this.source.stop();
                }
            }

            //
            //  DESC: Pause the sound
            //

        }, {
            key: 'pause',
            value: function pause() {
                if (!this.paused && this.startTime) {
                    this.paused = true;
                    this.playDuration += this.context.currentTime - this.startTime;
                    this.source.stop();
                }
            }

            //
            //  DESC: Resume the sound
            //

        }, {
            key: 'resume',
            value: function resume() {
                if (this.paused) {
                    this.paused = false;
                    this.play(false, this.playDuration);
                }
            }

            //
            //  DESC: Set/get the volume (0..1)
            //

        }, {
            key: 'setVolume',
            value: function setVolume(volume) {
                if (this.gainNode) this.gainNode.gain.value = volume;
            }
        }, {
            key: 'setVolume',
            value: function setVolume(volume) {
                if (this.gainNode) return this.gainNode.gain.value;

                return 0;
            }

            //
            //  DESC: Is playing?
            //

        }, {
            key: 'isPlaying',
            value: function isPlaying() {
                return this.startTime !== null;
            }

            //
            //  DESC: Is paused?
            //

        }, {
            key: 'isPaused',
            value: function isPaused() {
                return this.paused;
            }
        }]);

        return Sound;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Sound;

    /***/
},
/* 91 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__utilities_genfunc__ = __webpack_require__(3);

    // 
    //  FILE NAME: playlist.js
    //  DESC:      Play list class
    //


    // EPlayListType
    var EST_NULL = 0,
        EST_RANDOM = 1,
        EST_SEQUENTIAL = 2;
    /* unused harmony export EST_NULL */

    /* unused harmony export EST_RANDOM */

    /* unused harmony export EST_SEQUENTIAL */

    var PlayList = function () {
        function PlayList() {
            _classCallCheck(this, PlayList);

            // Counter
            this.counter = 0;

            // current index
            this.current = 0;

            // playlist type - random or sequential
            this.type = EST_NULL;

            // array of sounds
            this.soundAry = [];
        }

        // 
        //  DESC: load the playlist from node
        //


        _createClass(PlayList, [{
            key: 'loadFromNode',
            value: function loadFromNode(node, soundGroupMap, group, filePath) {
                // Get the play type
                var playtype = node.getAttribute('playtype');
                if (playtype) {
                    if (playtype === 'random') this.type = EST_RANDOM;else if (playtype === 'sequential') this.type = EST_SEQUENTIAL;
                }

                // Get the sound list node
                var soundNode = node.children;
                if (soundNode.length) {
                    for (var i = 0; i < soundNode.length; ++i) {
                        // Get the id
                        var _id5 = soundNode[i].getAttribute("id");

                        // Add the sound to the playlist
                        var snd = soundGroupMap.get(_id5);
                        if (snd) this.soundAry.push(snd);else throw new Error('Playlist sound Id does not exist (' + _id5 + ', ' + group + ', ' + filePath + ')!');
                    }
                }
            }

            // 
            //  DESC: Get the sound for the playlist
            //

        }, {
            key: 'getSound',
            value: function getSound() {
                // Is it time to shuffle?
                if (this.type === EST_RANDOM && this.counter === 0) __WEBPACK_IMPORTED_MODULE_0__utilities_genfunc__["e" /* shuffle */](this.soundAry);

                this.current = this.counter;
                this.counter = (this.counter + 1) % this.soundAry.length;

                return this.soundAry[this.current];
            }

            // 
            //  DESC: Play the play list
            //

        }, {
            key: 'play',
            value: function play(channel, loopCount) {
                if (this.type === EST_RANDOM && this.counter === 0) __WEBPACK_IMPORTED_MODULE_0__utilities_genfunc__["e" /* shuffle */](this.soundAry);

                this.current = this.counter;
                this.soundAry[tihs.current].play(channel, loopCount);
                this.counter = (this.counter + 1) % this.soundAry.length;
            }

            // 
            //  DESC: Stop the sound
            //

        }, {
            key: 'stop',
            value: function stop() {
                this.soundAry[this.current].stop();
            }

            // 
            //  DESC: Pause the sound
            //

        }, {
            key: 'pause',
            value: function pause() {
                this.soundAry[this.current].pause();
            }

            // 
            //  DESC: Resume the sound
            //

        }, {
            key: 'resume',
            value: function resume() {
                this.soundAry[this.current].resume();
            }

            // 
            //  DESC: Set/Get the volume for music or channel
            //

        }, {
            key: 'setVolume',
            value: function setVolume(volume) {
                this.soundAry[this.current].setVolume(volume);
            }
        }, {
            key: 'getVolume',
            value: function getVolume() {
                return this.soundAry[this.current].getVolume();
            }

            // 
            //  DESC: Is music or channel playing?
            //

        }, {
            key: 'isPlaying',
            value: function isPlaying() {
                return this.soundAry[this.current].isPlaying();
            }

            // 
            //  DESC: Is music or channel paused?
            //

        }, {
            key: 'isPaused',
            value: function isPaused() {
                return this.soundAry[this.current].isPaused();
            }
        }]);

        return PlayList;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = PlayList;

    /***/
},
/* 92 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME: statemessage.js
    //  DESC:      This class is custom per game project
    //


    var StateMessage = function () {
        function StateMessage() {
            _classCallCheck(this, StateMessage);

            this.loadState = 0;
            this.unloadState = 0;
        }

        _createClass(StateMessage, [{
            key: 'setMsg',
            value: function setMsg(loadState, unloadState) {
                this.loadState = loadState;
                this.unloadState = unloadState;
            }
        }]);

        return StateMessage;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = StateMessage;

    /***/
},
/* 93 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__visualcomponent3d__ = __webpack_require__(94);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__script_scriptcomponent__ = __webpack_require__(21);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__script_scriptmanager__ = __webpack_require__(14);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__object3d__ = __webpack_require__(48);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__utilities_matrix__ = __webpack_require__(10);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME:  sprite2d.js
    //  DESC:       2D sprite class
    //


    var Sprite3D = function (_WEBPACK_IMPORTED_MO26) {
        _inherits(Sprite3D, _WEBPACK_IMPORTED_MO26);

        function Sprite3D(objData) {
            _classCallCheck(this, Sprite3D);

            // The object data
            var _this40 = _possibleConstructorReturn(this, (Sprite3D.__proto__ || Object.getPrototypeOf(Sprite3D)).call(this));

            _this40.objData = objData;

            // The visual part of the 2d sprite
            _this40.visualComponent = new __WEBPACK_IMPORTED_MODULE_0__visualcomponent3d__["a" /* VisualComponent3D */](objData.visualData);

            // The script part of the 2d sprite
            _this40.scriptComponent = new __WEBPACK_IMPORTED_MODULE_1__script_scriptcomponent__["a" /* ScriptComponent */]();

            // If there's no visual data, set the hide flag
            _this40.setVisible(objData.visualData.isActive());
            return _this40;
        }

        //
        //  DESC: Update the sprite
        //


        _createClass(Sprite3D, [{
            key: 'update',
            value: function update() {
                m_scriptComponent.Update();
            }

            // 
            //  DESC: Update the physics
            //

        }, {
            key: 'physicsUpdate',
            value: function physicsUpdate() {}
            //m_physicsComponent.Update( this );


            // 
            //  DESC: do the render
            //

        }, {
            key: 'render',
            value: function render(projMatrix, camera) {
                if (this.isVisible()) {
                    this.visualComponent.render(this.matrix, projMatrix, this.rotMatrix, camera);
                }
            }
        }]);

        return Sprite3D;
    }(__WEBPACK_IMPORTED_MODULE_3__object3d__["a" /* Object3D */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Sprite3D;

    /***/
},
/* 94 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__managers_meshmanager__ = __webpack_require__(29);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__managers_shadermanager__ = __webpack_require__(15);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__managers_texturemanager__ = __webpack_require__(6);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__utilities_matrix__ = __webpack_require__(10);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__common_color__ = __webpack_require__(16);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME:  visualcomponent3d.js
    //  DESC:       Class for handling the visual part of the sprite
    //


    // Global final matrix to be reused by every render call so that an object specific
    // one doesn't have to be created each time a render call is made or a perminate one
    // allocated and heald within each class
    var gFinalMatrix = new __WEBPACK_IMPORTED_MODULE_3__utilities_matrix__["a" /* Matrix */]();

    var VisualComponent3D = function () {
        function VisualComponent3D(visualData) {
            _classCallCheck(this, VisualComponent3D);

            this.visualData = visualData;
            this.shaderData = null;
            this.vertexLocation = null;
            this.normalLocation = null;
            this.uvLocation = null;
            this.text0Location = null;
            this.colorLocation = null;
            this.matrixLocation = null;
            this.normalMatrixLocation = null;
            this.VERTEX_BUF_SIZE = 24;

            this.color = new __WEBPACK_IMPORTED_MODULE_4__common_color__["a" /* Color */]();

            if (visualData.isActive()) {
                this.meshAry = visualData.meshGrp.meshAry;
                this.shaderData = __WEBPACK_IMPORTED_MODULE_1__managers_shadermanager__["a" /* shaderManager */].getShaderData(visualData.shaderID);

                // Common shader members
                this.vertexLocation = this.shaderData.getLocation('in_position');
                this.normalLocation = this.shaderData.getLocation('in_normal');
                this.matrixLocation = this.shaderData.getLocation('cameraViewProjMatrix');
                this.normalMatrixLocation = this.shaderData.getLocation('normalMatrix');
                this.colorLocation = this.shaderData.getLocation('color');

                if (this.meshAry[0].textureAry.length) {
                    this.VERTEX_BUF_SIZE = 32;
                    this.uvLocation = this.shaderData.getLocation('in_uv');
                    this.text0Location = this.shaderData.getLocation('text0');
                }

                this.color.copy(this.visualData.color);
            }
        }

        //
        //  DESC: do the render
        //


        _createClass(VisualComponent3D, [{
            key: 'render',
            value: function render(objMatrix, projMatrix, rotMatrix, camera) {
                for (var i = 0; i < this.meshAry.length; ++i) {
                    // Increment our stat counter to keep track of what is going on.
                    //CStatCounter::Instance().IncDisplayCounter();

                    // Bind the VBO and IBO
                    __WEBPACK_IMPORTED_MODULE_0__managers_meshmanager__["a" /* meshManager */].bind(this.meshAry[i].vbo, this.meshAry[i].ibo);

                    // Bind the shader. This must be done first
                    __WEBPACK_IMPORTED_MODULE_1__managers_shadermanager__["a" /* shaderManager */].bind(this.shaderData);

                    // Setup the vertex attribute shader data
                    __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].vertexAttribPointer(this.vertexLocation, 3, __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].FLOAT, false, this.VERTEX_BUF_SIZE, 0);

                    // Setup the normal attribute shade data
                    __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].vertexAttribPointer(this.normalLocation, 3, __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].FLOAT, false, this.VERTEX_BUF_SIZE, 12);

                    // Enable the UV attribute shade data
                    if (this.uvLocation) {
                        // Bind the texture
                        for (var j = 0; j < this.meshAry[i].textureAry.length; ++j) {
                            __WEBPACK_IMPORTED_MODULE_2__managers_texturemanager__["a" /* textureManager */].bind(this.meshAry[i].textureAry[j].id);
                            __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].uniform1i(this.text0Location, 0); // future implementation - this.meshAry[i].textureAry[j].type ); // 0 = TEXTURE0
                        }

                        // Setup the uv attribute shade data
                        __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].vertexAttribPointer(this.uvLocation, 2, __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].FLOAT, false, this.VERTEX_BUF_SIZE, 24);
                    }

                    // Send the color to the shader
                    __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].uniform4fv(this.colorLocation, this.color.data);

                    gFinalMatrix.initilizeMatrix();
                    gFinalMatrix.mergeMatrix(objMatrix.matrix);
                    gFinalMatrix.mergeMatrix(camera.matrix.matrix);
                    gFinalMatrix.mergeMatrix(projMatrix.matrix);
                    __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].uniformMatrix4fv(this.matrixLocation, false, gFinalMatrix.matrix);

                    gFinalMatrix.initilizeMatrix();
                    gFinalMatrix.mergeMatrix(rotMatrix.matrix);
                    gFinalMatrix.mergeMatrix(camera.rotMatrix.matrix);
                    __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].uniformMatrix4fv(this.normalMatrixLocation, false, gFinalMatrix.matrix);

                    // Render it
                    __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].drawElements(__WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].TRIANGLES, this.meshAry[i].iboCount, __WEBPACK_IMPORTED_MODULE_5__system_device__["b" /* gl */].UNSIGNED_SHORT, 0);
                }
            }
        }]);

        return VisualComponent3D;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = VisualComponent3D;

    /***/
},
/* 95 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__utilities_matrix__ = __webpack_require__(10);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__3d_object3d__ = __webpack_require__(48);

    // 
    //  FILE NAME: camera.js
    //  DESC:      class that holds the camera position and rotation
    //


    var Camera = function (_WEBPACK_IMPORTED_MO27) {
        _inherits(Camera, _WEBPACK_IMPORTED_MO27);

        function Camera() {
            _classCallCheck(this, Camera);

            return _possibleConstructorReturn(this, (Camera.__proto__ || Object.getPrototypeOf(Camera)).call(this));
        }

        //
        //  DESC: Set the object's position
        //


        _createClass(Camera, [{
            key: 'setPos',
            value: function setPos(pos) {
                _get(Camera.prototype.__proto__ || Object.getPrototypeOf(Camera.prototype), 'setPosXYZ', this).call(this, -pos.x, -pos.y, -pos.z);
            }
        }, {
            key: 'setPosXYZ',
            value: function setPosXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                _get(Camera.prototype.__proto__ || Object.getPrototypeOf(Camera.prototype), 'setPosXYZ', this).call(this, -x, -y, -z);
            }
        }, {
            key: 'incPos',
            value: function incPos(pos) {
                _get(Camera.prototype.__proto__ || Object.getPrototypeOf(Camera.prototype), 'incPosXYZ', this).call(this, -pos.x, -pos.y, -pos.z);
            }
        }, {
            key: 'incPosXYZ',
            value: function incPosXYZ() {
                var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                _get(Camera.prototype.__proto__ || Object.getPrototypeOf(Camera.prototype), 'incPosXYZ', this).call(this, -x, -y, -z);
            }
        }]);

        return Camera;
    }(__WEBPACK_IMPORTED_MODULE_1__3d_object3d__["a" /* Object3D */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Camera;

    /***/
},
/* 96 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony export (immutable) */
    __webpack_exports__["a"] = loadScripts;
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_0__library_utilities_highresolutiontimer__ = __webpack_require__(8);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__ = __webpack_require__(14);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__library_managers_eventmanager__ = __webpack_require__(7);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__library_managers_soundmanager__ = __webpack_require__(35);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__library_common_color__ = __webpack_require__(16);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__utilityscripts__ = __webpack_require__(49);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__library_common_defs__ = __webpack_require__(0);

    //
    //  FILE NAME: menuscripts.js
    //  DESC:      script for the menus
    //


    //
    //  DESC: Script for playing the active sound
    //

    var Control_OnActive = function () {
        function Control_OnActive(control) {
            _classCallCheck(this, Control_OnActive);

            this.control = control;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_OnActive, [{
            key: 'execute',
            value: function execute() {
                __WEBPACK_IMPORTED_MODULE_3__library_managers_soundmanager__["a" /* soundManager */].play('(menu)', 'active');
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return true;
            }
        }]);

        return Control_OnActive;
    }();

    //
    //  DESC: Script for playing the select sound
    //


    var Control_OnSelect = function () {
        function Control_OnSelect(control) {
            _classCallCheck(this, Control_OnSelect);

            this.control = control;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_OnSelect, [{
            key: 'execute',
            value: function execute() {
                __WEBPACK_IMPORTED_MODULE_3__library_managers_soundmanager__["a" /* soundManager */].play('(menu)', 'select');
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return true;
            }
        }]);

        return Control_OnSelect;
    }();

    //
    //  DESC: Script for fading in the menu
    //


    var Menu_TransIn = function (_WEBPACK_IMPORTED_MO28) {
        _inherits(Menu_TransIn, _WEBPACK_IMPORTED_MO28);

        function Menu_TransIn(menu) {
            _classCallCheck(this, Menu_TransIn);

            var _this42 = _possibleConstructorReturn(this, (Menu_TransIn.__proto__ || Object.getPrototypeOf(Menu_TransIn)).call(this, 0, 1, 250));

            _this42.menu = menu;
            _this42.menu.setAlpha(_this42.current);
            _this42.menu.setVisible(true);
            return _this42;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Menu_TransIn, [{
            key: 'execute',
            value: function execute() {
                _get(Menu_TransIn.prototype.__proto__ || Object.getPrototypeOf(Menu_TransIn.prototype), 'execute', this).call(this);

                if (this.finished) {
                    this.menu.setAlpha(this.final);

                    __WEBPACK_IMPORTED_MODULE_2__library_managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_6__library_common_defs__["_15" /* EGE_MENU_TRANS_IN */], __WEBPACK_IMPORTED_MODULE_6__library_common_defs__["_51" /* ETC_END */]);
                } else {
                    this.menu.setAlpha(this.current);
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Menu_TransIn;
    }(__WEBPACK_IMPORTED_MODULE_5__utilityscripts__["b" /* FadeTo */]);

    //
    //  DESC: Script for fading out the menu
    //


    var Menu_TransOut = function (_WEBPACK_IMPORTED_MO29) {
        _inherits(Menu_TransOut, _WEBPACK_IMPORTED_MO29);

        function Menu_TransOut(menu) {
            _classCallCheck(this, Menu_TransOut);

            var _this43 = _possibleConstructorReturn(this, (Menu_TransOut.__proto__ || Object.getPrototypeOf(Menu_TransOut)).call(this, 1, 0, 250));

            _this43.menu = menu;
            return _this43;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Menu_TransOut, [{
            key: 'execute',
            value: function execute() {
                _get(Menu_TransOut.prototype.__proto__ || Object.getPrototypeOf(Menu_TransOut.prototype), 'execute', this).call(this);

                if (this.finished) {
                    this.menu.setAlpha(this.final);
                    this.menu.setVisible(false);

                    __WEBPACK_IMPORTED_MODULE_2__library_managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_6__library_common_defs__["_16" /* EGE_MENU_TRANS_OUT */], __WEBPACK_IMPORTED_MODULE_6__library_common_defs__["_51" /* ETC_END */]);
                } else {
                    this.menu.setAlpha(this.current);
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Menu_TransOut;
    }(__WEBPACK_IMPORTED_MODULE_5__utilityscripts__["b" /* FadeTo */]);

    //
    //  DESC: Script for setting the look of the disabled state
    //


    var Control_Disabled = function () {
        function Control_Disabled(sprite) {
            _classCallCheck(this, Control_Disabled);

            this.sprite = sprite;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Disabled, [{
            key: 'execute',
            value: function execute() {
                var color = new __WEBPACK_IMPORTED_MODULE_4__library_common_color__["a" /* Color */]();
                color.copy(this.sprite.getDefaultColor());
                color.transformHSV(0, 0, 1);

                this.sprite.setColor(color);

                this.finished = true;
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Disabled;
    }();

    //
    //  DESC: Script for setting the look of the inactive state
    //


    var Control_Inactive = function () {
        function Control_Inactive(sprite) {
            _classCallCheck(this, Control_Inactive);

            this.sprite = sprite;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Inactive, [{
            key: 'execute',
            value: function execute() {
                this.sprite.setColor(this.sprite.getDefaultColor());

                this.finished = true;
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Inactive;
    }();

    //
    //  DESC: Script for setting the look of the hidden state
    //


    var Control_Hidden = function () {
        function Control_Hidden(sprite) {
            _classCallCheck(this, Control_Hidden);

            this.sprite = sprite;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Hidden, [{
            key: 'execute',
            value: function execute() {
                this.sprite.setVisible(false);

                this.finished = true;
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Hidden;
    }();

    //
    //  DESC: Base script for animating the look of the active state
    //


    var Base_Control_Active = function () {
        function Base_Control_Active(sprite, hiHSV, lowHSV) {
            _classCallCheck(this, Base_Control_Active);

            this.sprite = sprite;

            sprite.setVisible(true);

            this.hiColor = new __WEBPACK_IMPORTED_MODULE_4__library_common_color__["a" /* Color */]();
            this.hiColor.copy(sprite.getDefaultColor());
            this.hiColor.transformHSV(0, 1, hiHSV);

            this.lowColor = new __WEBPACK_IMPORTED_MODULE_4__library_common_color__["a" /* Color */]();
            this.lowColor.copy(sprite.getDefaultColor());
            this.lowColor.transformHSV(0, 1, lowHSV);

            this.colorTo = new __WEBPACK_IMPORTED_MODULE_5__utilityscripts__["a" /* ColorTo */]();
            this.colorTo.init(sprite.getColor(), this.hiColor, 500);

            this.toggle = false;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Base_Control_Active, [{
            key: 'execute',
            value: function execute() {
                this.colorTo.execute();

                this.sprite.setColor(this.colorTo.color);

                if (this.colorTo.isFinished) {
                    if (this.toggle) this.colorTo.init(this.sprite.getColor(), this.hiColor, 500);else this.colorTo.init(this.sprite.getColor(), this.lowColor, 500);

                    this.toggle = !this.toggle;
                }
            }
        }]);

        return Base_Control_Active;
    }();

    var Control_Active = function (_Base_Control_Active) {
        _inherits(Control_Active, _Base_Control_Active);

        function Control_Active(sprite) {
            _classCallCheck(this, Control_Active);

            return _possibleConstructorReturn(this, (Control_Active.__proto__ || Object.getPrototypeOf(Control_Active)).call(this, sprite, 1.3, .5));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Active, [{
            key: 'execute',
            value: function execute() {
                _get(Control_Active.prototype.__proto__ || Object.getPrototypeOf(Control_Active.prototype), 'execute', this).call(this);
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return false;
            }
        }]);

        return Control_Active;
    }(Base_Control_Active);

    var Control_Solid_Active = function (_Base_Control_Active2) {
        _inherits(Control_Solid_Active, _Base_Control_Active2);

        function Control_Solid_Active(sprite) {
            _classCallCheck(this, Control_Solid_Active);

            return _possibleConstructorReturn(this, (Control_Solid_Active.__proto__ || Object.getPrototypeOf(Control_Solid_Active)).call(this, sprite, 1.1, .5));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Solid_Active, [{
            key: 'execute',
            value: function execute() {
                _get(Control_Solid_Active.prototype.__proto__ || Object.getPrototypeOf(Control_Solid_Active.prototype), 'execute', this).call(this);
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return false;
            }
        }]);

        return Control_Solid_Active;
    }(Base_Control_Active);

    //
    //  DESC: Base script for animating the look of the selected state
    //        NOTE: Start the button on the hi color, transition
    //              to the low color and then back to the hi color
    //


    var Base_Control_Selected = function () {
        function Base_Control_Selected(sprite, hiHSV, lowHSV) {
            _classCallCheck(this, Base_Control_Selected);

            this.sprite = sprite;

            sprite.setVisible(true);

            this.hiColor = new __WEBPACK_IMPORTED_MODULE_4__library_common_color__["a" /* Color */]();
            this.hiColor.copy(sprite.getDefaultColor());
            this.hiColor.transformHSV(0, 1, hiHSV);

            this.lowColor = new __WEBPACK_IMPORTED_MODULE_4__library_common_color__["a" /* Color */]();
            this.lowColor.copy(sprite.getDefaultColor());
            this.lowColor.transformHSV(0, 1, lowHSV);

            this.colorTo = new __WEBPACK_IMPORTED_MODULE_5__utilityscripts__["a" /* ColorTo */]();
            this.colorTo.init(this.hiColor, this.lowColor, 120);

            this.toggle = false;
            this.finished = false;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Base_Control_Selected, [{
            key: 'execute',
            value: function execute() {
                this.colorTo.execute();

                this.sprite.setColor(this.colorTo.color);

                if (this.colorTo.isFinished) {
                    if (this.toggle) {
                        this.sprite.setColor(this.sprite.getDefaultColor());
                        this.finished = true;
                    } else {
                        this.colorTo.init(this.sprite.getColor(), this.hiColor, 100);

                        this.toggle = true;
                    }
                }
            }
        }]);

        return Base_Control_Selected;
    }();

    //
    //  DESC: Animates the selected state and sends a message
    //


    var Control_Selected_Dispatch_Exe = function (_Base_Control_Selecte) {
        _inherits(Control_Selected_Dispatch_Exe, _Base_Control_Selecte);

        function Control_Selected_Dispatch_Exe(sprite) {
            _classCallCheck(this, Control_Selected_Dispatch_Exe);

            return _possibleConstructorReturn(this, (Control_Selected_Dispatch_Exe.__proto__ || Object.getPrototypeOf(Control_Selected_Dispatch_Exe)).call(this, sprite, 1.7, 0.6));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Selected_Dispatch_Exe, [{
            key: 'execute',
            value: function execute() {
                _get(Control_Selected_Dispatch_Exe.prototype.__proto__ || Object.getPrototypeOf(Control_Selected_Dispatch_Exe.prototype), 'execute', this).call(this);

                if (this.finished) {
                    __WEBPACK_IMPORTED_MODULE_2__library_managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_6__library_common_defs__["_8" /* EGE_MENU_SELECT_EXECUTE */]);
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Selected_Dispatch_Exe;
    }(Base_Control_Selected);

    var Control_Selected_Dispatch_Exe_Act = function (_Base_Control_Selecte2) {
        _inherits(Control_Selected_Dispatch_Exe_Act, _Base_Control_Selecte2);

        function Control_Selected_Dispatch_Exe_Act(sprite) {
            _classCallCheck(this, Control_Selected_Dispatch_Exe_Act);

            return _possibleConstructorReturn(this, (Control_Selected_Dispatch_Exe_Act.__proto__ || Object.getPrototypeOf(Control_Selected_Dispatch_Exe_Act)).call(this, sprite, 1.7, 0.6));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Selected_Dispatch_Exe_Act, [{
            key: 'execute',
            value: function execute() {
                _get(Control_Selected_Dispatch_Exe_Act.prototype.__proto__ || Object.getPrototypeOf(Control_Selected_Dispatch_Exe_Act.prototype), 'execute', this).call(this);

                if (this.finished) {
                    __WEBPACK_IMPORTED_MODULE_2__library_managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_6__library_common_defs__["_8" /* EGE_MENU_SELECT_EXECUTE */]);
                    __WEBPACK_IMPORTED_MODULE_2__library_managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_6__library_common_defs__["_1" /* EGE_MENU_REACTIVATE */]);
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Selected_Dispatch_Exe_Act;
    }(Base_Control_Selected);

    var Control_Selected_Visible = function (_Base_Control_Selecte3) {
        _inherits(Control_Selected_Visible, _Base_Control_Selecte3);

        function Control_Selected_Visible(sprite) {
            _classCallCheck(this, Control_Selected_Visible);

            return _possibleConstructorReturn(this, (Control_Selected_Visible.__proto__ || Object.getPrototypeOf(Control_Selected_Visible)).call(this, sprite, 1.7, 0.6));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Selected_Visible, [{
            key: 'execute',
            value: function execute() {
                _get(Control_Selected_Visible.prototype.__proto__ || Object.getPrototypeOf(Control_Selected_Visible.prototype), 'execute', this).call(this);
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Selected_Visible;
    }(Base_Control_Selected);

    //
    //  DESC: Animates the selected state and sends a message
    //


    var Control_Solid_Selected_visible = function (_Base_Control_Selecte4) {
        _inherits(Control_Solid_Selected_visible, _Base_Control_Selecte4);

        function Control_Solid_Selected_visible(sprite) {
            _classCallCheck(this, Control_Solid_Selected_visible);

            return _possibleConstructorReturn(this, (Control_Solid_Selected_visible.__proto__ || Object.getPrototypeOf(Control_Solid_Selected_visible)).call(this, sprite, 1.5, 0.6));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Solid_Selected_visible, [{
            key: 'execute',
            value: function execute() {
                _get(Control_Solid_Selected_visible.prototype.__proto__ || Object.getPrototypeOf(Control_Solid_Selected_visible.prototype), 'execute', this).call(this);
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Solid_Selected_visible;
    }(Base_Control_Selected);

    var Control_Selected = function (_Base_Control_Selecte5) {
        _inherits(Control_Selected, _Base_Control_Selecte5);

        function Control_Selected(sprite) {
            _classCallCheck(this, Control_Selected);

            return _possibleConstructorReturn(this, (Control_Selected.__proto__ || Object.getPrototypeOf(Control_Selected)).call(this, sprite, 1.7, 0.6));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Selected, [{
            key: 'execute',
            value: function execute() {
                _get(Control_Selected.prototype.__proto__ || Object.getPrototypeOf(Control_Selected.prototype), 'execute', this).call(this);

                if (this.finished) this.sprite.setVisible(false);
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Selected;
    }(Base_Control_Selected);

    var Control_Solid_Selected = function (_Base_Control_Selecte6) {
        _inherits(Control_Solid_Selected, _Base_Control_Selecte6);

        function Control_Solid_Selected(sprite) {
            _classCallCheck(this, Control_Solid_Selected);

            return _possibleConstructorReturn(this, (Control_Solid_Selected.__proto__ || Object.getPrototypeOf(Control_Solid_Selected)).call(this, sprite, 1.5, 0.6));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Solid_Selected, [{
            key: 'execute',
            value: function execute() {
                _get(Control_Solid_Selected.prototype.__proto__ || Object.getPrototypeOf(Control_Solid_Selected.prototype), 'execute', this).call(this);

                if (this.finished) this.sprite.setVisible(false);
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Solid_Selected;
    }(Base_Control_Selected);

    var Control_Selected_frame_highlight = function (_Base_Control_Selecte7) {
        _inherits(Control_Selected_frame_highlight, _Base_Control_Selecte7);

        function Control_Selected_frame_highlight(sprite) {
            _classCallCheck(this, Control_Selected_frame_highlight);

            return _possibleConstructorReturn(this, (Control_Selected_frame_highlight.__proto__ || Object.getPrototypeOf(Control_Selected_frame_highlight)).call(this, sprite, 1.7, 0.6));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Selected_frame_highlight, [{
            key: 'execute',
            value: function execute() {
                _get(Control_Selected_frame_highlight.prototype.__proto__ || Object.getPrototypeOf(Control_Selected_frame_highlight.prototype), 'execute', this).call(this);

                if (this.finished) this.sprite.setRGBA(1, 1, 1, 1);
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Selected_frame_highlight;
    }(Base_Control_Selected);

    //
    //  DESC: Fast display of selected state
    //


    var Base_Control_Fast_Selected = function Base_Control_Fast_Selected(sprite, hiHSV) {
        _classCallCheck(this, Base_Control_Fast_Selected);

        this.sprite = sprite;

        sprite.setVisible(true);

        this.hiColor = new __WEBPACK_IMPORTED_MODULE_4__library_common_color__["a" /* Color */]();
        this.hiColor.copy(sprite.getDefaultColor());
        this.hiColor.transformHSV(0, 1, hiHSV);
        this.finished = false;

        this.sprite.setColor(this.hiColor);
    };

    var Control_Fast_Face_Selected = function (_Base_Control_Fast_Se) {
        _inherits(Control_Fast_Face_Selected, _Base_Control_Fast_Se);

        function Control_Fast_Face_Selected(sprite) {
            _classCallCheck(this, Control_Fast_Face_Selected);

            var _this53 = _possibleConstructorReturn(this, (Control_Fast_Face_Selected.__proto__ || Object.getPrototypeOf(Control_Fast_Face_Selected)).call(this, sprite, 1.7));

            _this53.time = 80;
            return _this53;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Fast_Face_Selected, [{
            key: 'execute',
            value: function execute() {
                this.time -= __WEBPACK_IMPORTED_MODULE_0__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;

                if (this.time < 0) {
                    this.sprite.setDefaultColor();
                    this.finished = true;
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Fast_Face_Selected;
    }(Base_Control_Fast_Selected);

    var Control_Fast_Face_Selected_Act = function (_Base_Control_Fast_Se2) {
        _inherits(Control_Fast_Face_Selected_Act, _Base_Control_Fast_Se2);

        function Control_Fast_Face_Selected_Act(sprite) {
            _classCallCheck(this, Control_Fast_Face_Selected_Act);

            var _this54 = _possibleConstructorReturn(this, (Control_Fast_Face_Selected_Act.__proto__ || Object.getPrototypeOf(Control_Fast_Face_Selected_Act)).call(this, sprite, 1.7));

            _this54.time = 80;
            return _this54;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Fast_Face_Selected_Act, [{
            key: 'execute',
            value: function execute() {
                this.time -= __WEBPACK_IMPORTED_MODULE_0__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;

                if (this.time < 0) {
                    this.sprite.setDefaultColor();
                    __WEBPACK_IMPORTED_MODULE_2__library_managers_eventmanager__["a" /* eventManager */].dispatchEvent(__WEBPACK_IMPORTED_MODULE_6__library_common_defs__["_1" /* EGE_MENU_REACTIVATE */]);
                    this.finished = true;
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Fast_Face_Selected_Act;
    }(Base_Control_Fast_Selected);

    var Control_Fast_Selected = function (_Base_Control_Fast_Se3) {
        _inherits(Control_Fast_Selected, _Base_Control_Fast_Se3);

        function Control_Fast_Selected(sprite) {
            _classCallCheck(this, Control_Fast_Selected);

            var _this55 = _possibleConstructorReturn(this, (Control_Fast_Selected.__proto__ || Object.getPrototypeOf(Control_Fast_Selected)).call(this, sprite, 1.7));

            _this55.time = 80;
            return _this55;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Fast_Selected, [{
            key: 'execute',
            value: function execute() {
                this.time -= __WEBPACK_IMPORTED_MODULE_0__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;

                if (this.time < 0) {
                    this.sprite.setVisible(false);
                    this.finished = true;
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Fast_Selected;
    }(Base_Control_Fast_Selected);

    var Control_Fast_Solid_Selected = function (_Base_Control_Fast_Se4) {
        _inherits(Control_Fast_Solid_Selected, _Base_Control_Fast_Se4);

        function Control_Fast_Solid_Selected(sprite) {
            _classCallCheck(this, Control_Fast_Solid_Selected);

            var _this56 = _possibleConstructorReturn(this, (Control_Fast_Solid_Selected.__proto__ || Object.getPrototypeOf(Control_Fast_Solid_Selected)).call(this, sprite, 1.7));

            _this56.time = 80;
            return _this56;
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_Fast_Solid_Selected, [{
            key: 'execute',
            value: function execute() {
                this.time -= __WEBPACK_IMPORTED_MODULE_0__library_utilities_highresolutiontimer__["a" /* highResTimer */].elapsedTime;

                if (this.time < 0) {
                    this.sprite.setVisible(false);
                    this.finished = true;
                }
            }

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return this.finished;
            }
        }]);

        return Control_Fast_Solid_Selected;
    }(Base_Control_Fast_Selected);

    var Control_slider_btn_Selected = function (_Base_Control_Fast_Se5) {
        _inherits(Control_slider_btn_Selected, _Base_Control_Fast_Se5);

        function Control_slider_btn_Selected(sprite) {
            _classCallCheck(this, Control_slider_btn_Selected);

            return _possibleConstructorReturn(this, (Control_slider_btn_Selected.__proto__ || Object.getPrototypeOf(Control_slider_btn_Selected)).call(this, sprite, 1.7));
        }

        // 
        //  DESC: Execute this script object
        //


        _createClass(Control_slider_btn_Selected, [{
            key: 'execute',
            value: function execute() {}

            // 
            //  DESC: Finished access function
            //

        }, {
            key: 'isFinished',
            get: function get() {
                return true;
            }
        }]);

        return Control_slider_btn_Selected;
    }(Base_Control_Fast_Selected);

    // 
    //  DESC: Load XML files
    //


    function loadScripts() {
        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_OnActive', function (control) {
            return new Control_OnActive(control);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_OnSelect', function (control) {
            return new Control_OnSelect(control);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Menu_TransIn', function (menu) {
            return new Menu_TransIn(menu);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Menu_TransOut', function (menu) {
            return new Menu_TransOut(menu);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Disabled', function (sprite) {
            return new Control_Disabled(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Inactive', function (sprite) {
            return new Control_Inactive(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Hidden', function (sprite) {
            return new Control_Hidden(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Active', function (sprite) {
            return new Control_Active(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Solid_Active', function (sprite) {
            return new Control_Solid_Active(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Selected_Dispatch_Exe', function (sprite) {
            return new Control_Selected_Dispatch_Exe(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Selected_Dispatch_Exe_Act', function (sprite) {
            return new Control_Selected_Dispatch_Exe_Act(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Selected_Visible', function (sprite) {
            return new Control_Selected_Visible(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Solid_Selected_visible', function (sprite) {
            return new Control_Solid_Selected_visible(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Selected', function (sprite) {
            return new Control_Selected(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Solid_Selected', function (sprite) {
            return new Control_Solid_Selected(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Selected_frame_highlight', function (sprite) {
            return new Control_Selected_frame_highlight(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Fast_Face_Selected', function (sprite) {
            return new Control_Fast_Face_Selected(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Fast_Face_Selected_Act', function (sprite) {
            return new Control_Fast_Face_Selected_Act(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Fast_Selected', function (sprite) {
            return new Control_Fast_Selected(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_Fast_Solid_Selected', function (sprite) {
            return new Control_Fast_Solid_Selected(sprite);
        });

        __WEBPACK_IMPORTED_MODULE_1__library_script_scriptmanager__["a" /* scriptManager */].set('Control_slider_btn_Selected', function (sprite) {
            return new Control_slider_btn_Selected(sprite);
        });
    }

    /***/
},
/* 97 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__ = __webpack_require__(15);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__library_managers_texturemanager__ = __webpack_require__(6);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__library_managers_vertexbuffermanager__ = __webpack_require__(19);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__library_managers_loadmanager__ = __webpack_require__(28);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__ = __webpack_require__(11);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_5__library_utilities_settings__ = __webpack_require__(9);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_6__library_2d_sprite2d__ = __webpack_require__(13);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_7__library_utilities_highresolutiontimer__ = __webpack_require__(8);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_8__library_system_device__ = __webpack_require__(2);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_9__state_titlescreenstate__ = __webpack_require__(36);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_10__state_runstate__ = __webpack_require__(50);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_11__gamestate__ = __webpack_require__(22);

    // 
    //  FILE NAME: loadstate.js
    //  DESC:      All this state does is unload/load and does a state change.
    //


    var MIN_LOAD_TIME = 1000;

    var LoadState = function (_WEBPACK_IMPORTED_MO30) {
        _inherits(LoadState, _WEBPACK_IMPORTED_MO30);

        function LoadState(stateMessage, stateChangeCallback) {
            _classCallCheck(this, LoadState);

            var _this58 = _possibleConstructorReturn(this, (LoadState.__proto__ || Object.getPrototypeOf(LoadState)).call(this, __WEBPACK_IMPORTED_MODULE_11__gamestate__["a" /* GAME_STATE_LOAD */], stateMessage.loadState, stateChangeCallback));

            _this58.stateMessage.loadState = stateMessage.loadState;
            _this58.stateMessage.unloadState = stateMessage.unloadState;

            _this58.loadAnim = new __WEBPACK_IMPORTED_MODULE_6__library_2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_4__library_objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData('(loadingScreen)', 'loadAnim'));
            _this58.loadAnim.setPosXYZ(__WEBPACK_IMPORTED_MODULE_5__library_utilities_settings__["a" /* settings */].defaultSize_half.w - 150, -(__WEBPACK_IMPORTED_MODULE_5__library_utilities_settings__["a" /* settings */].defaultSize_half.h - 150), 0);
            _this58.loadAnim.transform();

            _this58.frameCount = _this58.loadAnim.getFrameCount();

            _this58.loadFrameCounter = 0;

            _this58.stateChange = true;

            _this58.loadAnimInterval = 0;
            return _this58;
        }

        // 
        //  DESC: Do any pre-game loop init's
        //


        _createClass(LoadState, [{
            key: 'init',
            value: function init() {
                // Use the simple timer to see how long the download is
                __WEBPACK_IMPORTED_MODULE_7__library_utilities_highresolutiontimer__["a" /* highResTimer */].timerStart();

                var loadAnim = this.loadAnimUpdate.bind(this);
                this.loadAnimInterval = setInterval(function () {
                    return loadAnim();
                }, 83);

                __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__["a" /* shaderManager */].setShaderValue4fv('shader_2d_spriteSheet', 'additive', [1, 1, 1, 1]);

                // Set the load manager's callback when everything is loaded
                __WEBPACK_IMPORTED_MODULE_3__library_managers_loadmanager__["a" /* loadManager */].loadCompleteCallback = this.loadFinished.bind(this);

                if (this.stateMessage.loadState === __WEBPACK_IMPORTED_MODULE_11__gamestate__["d" /* GAME_STATE_TITLESCREEN */]) __WEBPACK_IMPORTED_MODULE_9__state_titlescreenstate__["b" /* load */]();else if (this.stateMessage.loadState === __WEBPACK_IMPORTED_MODULE_11__gamestate__["b" /* GAME_STATE_RUN */]) __WEBPACK_IMPORTED_MODULE_10__state_runstate__["b" /* load */]();

                // Start the load
                __WEBPACK_IMPORTED_MODULE_3__library_managers_loadmanager__["a" /* loadManager */].load();
            }

            // 
            //  DESC: Load is completed so fade the logo out
            //

        }, {
            key: 'loadFinished',
            value: function loadFinished() {
                var loadTime = __WEBPACK_IMPORTED_MODULE_7__library_utilities_highresolutiontimer__["a" /* highResTimer */].timerStop();

                if (loadTime > MIN_LOAD_TIME) {
                    this.displayComplete();
                } else {
                    var displayCompleteCallback = this.displayComplete.bind(this);
                    setTimeout(function () {
                        return displayCompleteCallback();
                    }, MIN_LOAD_TIME - loadTime);
                }
            }

            // 
            //  DESC: Load is completed so fade the logo out
            //

        }, {
            key: 'displayComplete',
            value: function displayComplete() {
                if (this.loadAnimInterval !== 0) clearInterval(this.loadAnimInterval);

                // Load is complete so continue onto the next state
                this.callback();
            }

            // 
            //  DESC: Clean up after the startup state
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {
                __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__["a" /* shaderManager */].setShaderValue4fv('shader_2d_spriteSheet', 'additive', [0, 0, 0, 1]);
            }

            // 
            //  DESC: progress bar update
            //

        }, {
            key: 'loadAnimUpdate',
            value: function loadAnimUpdate() {
                __WEBPACK_IMPORTED_MODULE_8__library_system_device__["b" /* gl */].clear(__WEBPACK_IMPORTED_MODULE_8__library_system_device__["b" /* gl */].COLOR_BUFFER_BIT);

                this.loadAnim.render(__WEBPACK_IMPORTED_MODULE_8__library_system_device__["a" /* device */].orthographicMatrix);

                ++this.loadFrameCounter;

                this.loadAnim.setFrame(this.loadFrameCounter % this.frameCount);

                // Unbind everything after a round of rendering
                __WEBPACK_IMPORTED_MODULE_0__library_managers_shadermanager__["a" /* shaderManager */].unbind();
                __WEBPACK_IMPORTED_MODULE_1__library_managers_texturemanager__["a" /* textureManager */].unbind();
                __WEBPACK_IMPORTED_MODULE_2__library_managers_vertexbuffermanager__["a" /* vertexBufferManager */].unbind();
            }
        }]);

        return LoadState;
    }(__WEBPACK_IMPORTED_MODULE_11__gamestate__["e" /* GameState */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = LoadState;

    /***/
},
/* 98 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__common_ispritestrategy__ = __webpack_require__(99);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__2d_sector2d__ = __webpack_require__(100);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__common_object__ = __webpack_require__(41);

    // 
    //  FILE NAME: basicstagestrategy2d.js
    //  DESC:      Basic 2D stage strategy
    //


    var BasicStageStrategy2D = function (_WEBPACK_IMPORTED_MO31) {
        _inherits(BasicStageStrategy2D, _WEBPACK_IMPORTED_MO31);

        function BasicStageStrategy2D() {
            _classCallCheck(this, BasicStageStrategy2D);

            // Deque of the sector 2d sprites
            var _this59 = _possibleConstructorReturn(this, (BasicStageStrategy2D.__proto__ || Object.getPrototypeOf(BasicStageStrategy2D)).call(this));

            _this59.sectorAry = [];

            // default camera position
            _this59.defaultCameraPos = new __WEBPACK_IMPORTED_MODULE_2__common_object__["a" /* Object */]();
            return _this59;
        }

        //
        //  DESC: Load the data from xml node
        //


        _createClass(BasicStageStrategy2D, [{
            key: 'loadFromNode',
            value: function loadFromNode(node, filePath, downloadFileCallback, finishCallback) {
                // Get the node to the sound files
                var cameraNode = node.getElementsByTagName('cameraPosition');
                if (cameraNode.length) this.defaultCameraPos.loadTransFromNode(cameraNode[0]);

                var sectorNode = node.getElementsByTagName('sector');

                for (var i = 0; i < sectorNode.length; ++i) {
                    var sector = new __WEBPACK_IMPORTED_MODULE_1__2d_sector2d__["a" /* Sector2D */]();
                    this.sectorAry.push(sector);

                    sector.loadTransFromNode(sectorNode[i]);

                    // load the sector file
                    downloadFileCallback('xml', '', sectorNode[i].getAttribute('file'), finishCallback, sector.loadFromNode.bind(sector));
                }
            }
        }]);

        return BasicStageStrategy2D;
    }(__WEBPACK_IMPORTED_MODULE_0__common_ispritestrategy__["a" /* iSpriteStrategy */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = BasicStageStrategy2D;

    /***/
},
/* 99 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    // 
    //  FILE NAME: ispritestrategy.js
    //  DESC:      Sprite Strategy Interface Class - Represents a group of sprites
    //


    var iSpriteStrategy = function () {
        function iSpriteStrategy() {
            _classCallCheck(this, iSpriteStrategy);
        }

        //
        //  DESC: Load the data from file
        //


        _createClass(iSpriteStrategy, [{
            key: 'loadFromNode',
            value: function loadFromNode(node, filePath, downloadFileCallback, finishCallback) {}
            // Empty function to be overwritten


            //
            //  DESC: Allow player sprite to respond to input
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {}
            // Empty function to be overwritten


            //
            //  DESC: Handle messages
            //

        }, {
            key: 'handleMessage',
            value: function handleMessage(msg) {}
            // Empty function to be overwritten


            //
            //  DESC: Create the sprite
            //

        }, {
            key: 'create',
            value: function create(name, id, pos, rot, scale) {}
            // Empty function to be overwritten


            //
            //  DESC: Do any pre-loop init
            //

        }, {
            key: 'init',
            value: function init() {}
            // Empty function to be overwritten


            //
            //  DESC: Do some cleanup
            //

        }, {
            key: 'cleanUp',
            value: function cleanUp() {}
            // Empty function to be overwritten


            //
            //  DESC: Load the data from file
            //

        }, {
            key: 'miscProcess',
            value: function miscProcess() {}
            // Empty function to be overwritten


            //
            //  DESC: Load the data from file
            //

        }, {
            key: 'update',
            value: function update() {}
            // Empty function to be overwritten


            //
            //  DESC: Transform the sprite
            //

        }, {
            key: 'transform',
            value: function transform() {
                // Empty function to be overwritten
            }
        }, {
            key: 'transform',
            value: function transform(object) {}
            // Empty function to be overwritten


            //
            //  DESC: Render the sprite
            //

        }, {
            key: 'render',
            value: function render(matrix) {}
            // Empty function to be overwritten


            //
            //  DESC: Delete any sprites scheduled to die
            //

        }, {
            key: 'handleDelete',
            value: function handleDelete() {
                // Empty function to be overwritten
            }
        }]);

        return iSpriteStrategy;
    }();
    /* harmony export (immutable) */

    __webpack_exports__["a"] = iSpriteStrategy;

    /***/
},
/* 100 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__object2d__ = __webpack_require__(25);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__utilities_settings__ = __webpack_require__(9);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__2d_sprite2d__ = __webpack_require__(13);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_3__objectdatamanager_objectdatamanager__ = __webpack_require__(11);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_4__managers_signalmanager__ = __webpack_require__(18);

    // 
    //  FILE NAME: sector2d.js
    //  DESC:      Class the creates & renders all the sector sprites
    //


    var Sector2D = function (_WEBPACK_IMPORTED_MO32) {
        _inherits(Sector2D, _WEBPACK_IMPORTED_MO32);

        function Sector2D() {
            _classCallCheck(this, Sector2D);

            // sprite allocation array
            var _this60 = _possibleConstructorReturn(this, (Sector2D.__proto__ || Object.getPrototypeOf(Sector2D)).call(this));

            _this60.spriteAry = [];

            // The projection type
            _this60.projectionType = __WEBPACK_IMPORTED_MODULE_1__utilities_settings__["a" /* settings */].projectionType;

            // Half of the sector size
            _this60.sectorSizeHalf = __WEBPACK_IMPORTED_MODULE_1__utilities_settings__["a" /* settings */].sectorSizeHalf;
            return _this60;
        }

        //
        //  DESC: Load the data from xml node
        //        NOTE: group not used
        //


        _createClass(Sector2D, [{
            key: 'loadFromNode',
            value: function loadFromNode(group, xmlNode, filePath, finishCallback) {
                var defaultObjName = '';
                var defaultGroup = '';
                var defaultId = -1;
                var defaultAIName = '';

                var attr = xmlNode.getAttribute('defaultObjectName');
                if (attr) defaultObjName = attr;

                attr = xmlNode.getAttribute('defaultGroup');
                if (attr) defaultGroup = attr;

                attr = xmlNode.getAttribute('defaultId');
                if (attr) defaultId = Number(attr);

                attr = xmlNode.getAttribute('defaultAIName');
                if (attr) defaultAIName = attr;

                var spriteNode = xmlNode.getElementsByTagName('sprite');

                for (var i = 0; i < spriteNode.length; ++i) {
                    var objName = defaultObjName;
                    var _group = defaultGroup;
                    var _id6 = defaultId;
                    var aiName = defaultAIName;

                    attr = spriteNode[i].getAttribute('objectName');
                    if (attr) objName = attr;

                    attr = spriteNode[i].getAttribute('group');
                    if (attr) _group = attr;

                    attr = spriteNode[i].getAttribute('id');
                    if (attr) _id6 = Number(attr);

                    attr = spriteNode[i].getAttribute('aiName');
                    if (attr) aiName = attr;

                    // Allocate the sprite and add it to the array
                    var sprite = new __WEBPACK_IMPORTED_MODULE_2__2d_sprite2d__["a" /* Sprite2D */](__WEBPACK_IMPORTED_MODULE_3__objectdatamanager_objectdatamanager__["a" /* objectDataManager */].getData(_group, objName), _id6);
                    this.spriteAry.push(sprite);

                    // Load the transform data from node
                    sprite.loadTransFromNode(spriteNode[i]);

                    // Init the physics
                    sprite.initPhysics();

                    // Broadcast the signal to create the sprite AI
                    if (aiName !== '') __WEBPACK_IMPORTED_MODULE_4__managers_signalmanager__["a" /* signalManager */].broadcast_aiCreate(aiName, sprite);
                }
            }
        }]);

        return Sector2D;
    }(__WEBPACK_IMPORTED_MODULE_0__object2d__["a" /* Object2D */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = Sector2D;

    /***/
},
/* 101 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__library_gui_ismartguibase__ = __webpack_require__(102);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__ = __webpack_require__(24);
    /* harmony import */var __WEBPACK_IMPORTED_MODULE_2__library_common_defs__ = __webpack_require__(0);

    // 
    //  FILE NAME: smartconfirmbtn.js
    //  DESC:      Class CSmartExitBtn
    //


    var SmartConfirmBtn = function (_WEBPACK_IMPORTED_MO33) {
        _inherits(SmartConfirmBtn, _WEBPACK_IMPORTED_MO33);

        function SmartConfirmBtn(uiControl) {
            _classCallCheck(this, SmartConfirmBtn);

            return _possibleConstructorReturn(this, (SmartConfirmBtn.__proto__ || Object.getPrototypeOf(SmartConfirmBtn)).call(this, uiControl));
        }

        //
        //  DESC: Called when the control is executed
        //


        _createClass(SmartConfirmBtn, [{
            key: 'execute',
            value: function execute() {
                var menu = __WEBPACK_IMPORTED_MODULE_1__library_gui_menumanager__["a" /* menuManager */].getMenu("confirmation_menu");
                var yesBtn = menu.getControl("yes_btn");
                var megLbl = menu.getControl("message_lbl");

                var smartGuiCtrl = null;
                var conformationMsg = '';
                var executionAction = '';
                var actionType = __WEBPACK_IMPORTED_MODULE_2__library_common_defs__["s" /* ECAT_BACK */];

                if (this.uiControl.name === 'main_menu_btn') {
                    conformationMsg = 'Are you sure you|want to go back to|the main menu?';
                    actionType = __WEBPACK_IMPORTED_MODULE_2__library_common_defs__["v" /* ECAT_GAME_STATE_CHANGE */];
                    executionAction = 'title_screen_state';
                }

                // Set the conformation menu
                yesBtn.smartGui = smartGuiCtrl;
                yesBtn.actionType = actionType;
                yesBtn.executionAction = executionAction;
                megLbl.createFontStr(conformationMsg);
            }
        }]);

        return SmartConfirmBtn;
    }(__WEBPACK_IMPORTED_MODULE_0__library_gui_ismartguibase__["a" /* SmartGuiControl */]);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = SmartConfirmBtn;

    /***/
},
/* 102 */
/***/function (module, __webpack_exports__, __webpack_require__) {

    "use strict";

    //
    //  FILE NAME: ismartguibase.js
    //  DESC:      Smart Gui interface & Base Classes
    //


    // 
    //  DESC: Smart GUI interface class
    //

    var iSmartGui = function () {
        function iSmartGui() {
            _classCallCheck(this, iSmartGui);
        }

        // 
        //  DESC: Called when the control is created
        //


        _createClass(iSmartGui, [{
            key: 'create',
            value: function create() {}
            // Empty function to be overwritten


            // 
            //  DESC: Called during the handle user imput
            //

        }, {
            key: 'handleEvent',
            value: function handleEvent(event) {
                // Empty function to be overwritten
            }
        }]);

        return iSmartGui;
    }();

    // 
    //  DESC: Smart GUI Menu class
    //


    var SmartGuiMenu = function (_iSmartGui) {
        _inherits(SmartGuiMenu, _iSmartGui);

        function SmartGuiMenu(uiMenu) {
            _classCallCheck(this, SmartGuiMenu);

            var _this62 = _possibleConstructorReturn(this, (SmartGuiMenu.__proto__ || Object.getPrototypeOf(SmartGuiMenu)).call(this));

            _this62.uiMenu = uiMenu;
            return _this62;
        }

        return SmartGuiMenu;
    }(iSmartGui);
    /* unused harmony export SmartGuiMenu */

    // 
    //  DESC: Smart GUI Control
    //


    var SmartGuiControl = function (_iSmartGui2) {
        _inherits(SmartGuiControl, _iSmartGui2);

        function SmartGuiControl(uiControl) {
            _classCallCheck(this, SmartGuiControl);

            var _this63 = _possibleConstructorReturn(this, (SmartGuiControl.__proto__ || Object.getPrototypeOf(SmartGuiControl)).call(this));

            _this63.uiControl = uiControl;
            return _this63;
        }

        // 
        //  DESC: Called when the control is executed
        //


        _createClass(SmartGuiControl, [{
            key: 'execute',
            value: function execute() {
                // Empty function to be overwritten
            }
        }]);

        return SmartGuiControl;
    }(iSmartGui);
    /* harmony export (immutable) */

    __webpack_exports__["a"] = SmartGuiControl;

    /***/
}]
/******/);
